"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ClientMetricReportDirection_1 = __importDefault(require("../clientmetricreport/ClientMetricReportDirection"));
const ClientMetricReportMediaType_1 = __importDefault(require("../clientmetricreport/ClientMetricReportMediaType"));
const ReconnectionHealthPolicy_1 = __importDefault(require("../connectionhealthpolicy/ReconnectionHealthPolicy"));
const SendingAudioFailureConnectionHealthPolicy_1 = __importDefault(require("../connectionhealthpolicy/SendingAudioFailureConnectionHealthPolicy"));
const UnusableAudioWarningConnectionHealthPolicy_1 = __importDefault(require("../connectionhealthpolicy/UnusableAudioWarningConnectionHealthPolicy"));
const VideoEncodingConnectionHealthPolicyName_1 = __importDefault(require("../connectionhealthpolicy/VideoEncodingConnectionHealthPolicyName"));
const MeetingSessionStatus_1 = __importDefault(require("../meetingsession/MeetingSessionStatus"));
const MeetingSessionStatusCode_1 = __importDefault(require("../meetingsession/MeetingSessionStatusCode"));
const VideoCodecCapability_1 = __importDefault(require("../sdp/VideoCodecCapability"));
const SignalingClientEventType_1 = __importDefault(require("../signalingclient/SignalingClientEventType"));
const SignalingProtocol_1 = require("../signalingprotocol/SignalingProtocol");
const AudioLogEvent_1 = __importDefault(require("../statscollector/AudioLogEvent"));
const Types_1 = require("../utils/Types");
const BaseTask_1 = __importDefault(require("./BaseTask"));
/*
 * [[MonitorTask]] monitors connections using SignalingAndMetricsConnectionMonitor.
 */
class MonitorTask extends BaseTask_1.default {
    constructor(context, connectionHealthPolicyConfiguration, initialConnectionHealthData) {
        super(context.logger);
        this.context = context;
        this.initialConnectionHealthData = initialConnectionHealthData;
        this.taskName = 'MonitorTask';
        this.prevSignalStrength = 1;
        this.currentAvailableStreamAvgBitrates = null;
        this.hasSignalingError = false;
        this.presenceHandlerCalled = false;
        // See comment above invocation of `pauseResubscribeCheck` in `DefaultAudioVideoController`
        // for explanation.
        this.isResubscribeCheckPaused = false;
        this.pendingMetricsReport = undefined;
        this.isMeetingConnected = false;
        this.videoEncodingHealthPolicies = [];
        this.checkAndSendWeakSignalEvent = (signalStrength) => {
            const isCurrentSignalBad = signalStrength < 1;
            const isPrevSignalBad = this.prevSignalStrength < 1;
            const signalStrengthEventType = isCurrentSignalBad
                ? !isPrevSignalBad
                    ? AudioLogEvent_1.default.RedmicStartLoss
                    : null
                : isPrevSignalBad
                    ? AudioLogEvent_1.default.RedmicEndLoss
                    : null;
            if (signalStrengthEventType) {
                this.context.statsCollector.logAudioEvent(signalStrengthEventType);
            }
            this.prevSignalStrength = signalStrength;
        };
        this.realtimeFatalErrorCallback = (error) => {
            this.logger.error(`realtime error: ${error}: ${error.stack}`);
            this.context.audioVideoController.handleMeetingSessionStatus(new MeetingSessionStatus_1.default(MeetingSessionStatusCode_1.default.RealtimeApiFailed), error);
        };
        this.realtimeAttendeeIdPresenceHandler = (presentAttendeeId, present) => {
            var _a;
            const attendeeId = this.context.meetingSessionConfiguration.credentials.attendeeId;
            this.logger.info(`attendeePresenceReceived: ${attendeeId}`);
            if (attendeeId === presentAttendeeId && present && !this.presenceHandlerCalled) {
                this.presenceHandlerCalled = true;
                this.context.attendeePresenceDurationMs = Date.now() - this.context.startAudioVideoTimestamp;
                (_a = this.context.eventController) === null || _a === void 0 ? void 0 : _a.publishEvent('attendeePresenceReceived', {
                    attendeePresenceDurationMs: this.context.attendeePresenceDurationMs,
                });
            }
        };
        this.generateBaseAudioVideoEventAttributes = () => {
            const { signalingOpenDurationMs, startTimeMs, iceGatheringDurationMs, attendeePresenceDurationMs, meetingStartDurationMs, } = this.context;
            return {
                meetingDurationMs: startTimeMs === null ? 0 : Math.round(Date.now() - startTimeMs),
                signalingOpenDurationMs,
                iceGatheringDurationMs,
                attendeePresenceDurationMs,
                meetingStartDurationMs,
            };
        };
        this.generateAudioVideoEventAttributesForReceivingAudioDropped = () => {
            const baseAttributes = this.generateBaseAudioVideoEventAttributes();
            return Object.assign(Object.assign({}, baseAttributes), { maxVideoTileCount: this.context.maxVideoTileCount, poorConnectionCount: this.context.poorConnectionCount });
        };
        this.reconnectionHealthPolicy = new ReconnectionHealthPolicy_1.default(context.logger, Object.assign({}, connectionHealthPolicyConfiguration), this.initialConnectionHealthData.clone());
        this.unusableAudioWarningHealthPolicy = new UnusableAudioWarningConnectionHealthPolicy_1.default(Object.assign({}, connectionHealthPolicyConfiguration), this.initialConnectionHealthData.clone());
        this.sendingAudioFailureHealthPolicy = new SendingAudioFailureConnectionHealthPolicy_1.default(context.logger, Object.assign({}, connectionHealthPolicyConfiguration), this.initialConnectionHealthData.clone());
        for (const policy of connectionHealthPolicyConfiguration.videoEncodingHealthPolicies) {
            this.videoEncodingHealthPolicies.push(new policy(Object.assign({}, connectionHealthPolicyConfiguration), this.initialConnectionHealthData.clone()));
        }
    }
    removeObserver() {
        this.context.audioVideoController.removeObserver(this);
        this.context.realtimeController.realtimeUnsubscribeToFatalError(this.realtimeFatalErrorCallback);
        this.context.realtimeController.realtimeUnsubscribeToLocalSignalStrengthChange(this.checkAndSendWeakSignalEvent);
        this.context.realtimeController.realtimeUnsubscribeToAttendeeIdPresence(this.realtimeAttendeeIdPresenceHandler);
        this.context.signalingClient.removeObserver(this);
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            this.context.removableObservers.push(this);
            this.context.audioVideoController.addObserver(this);
            this.context.realtimeController.realtimeSubscribeToFatalError(this.realtimeFatalErrorCallback);
            this.context.realtimeController.realtimeSubscribeToLocalSignalStrengthChange(this.checkAndSendWeakSignalEvent);
            this.context.realtimeController.realtimeSubscribeToAttendeeIdPresence(this.realtimeAttendeeIdPresenceHandler);
            this.context.connectionMonitor.start();
            this.context.statsCollector.start(this.context.signalingClient, this.context.videoStreamIndex);
            this.context.signalingClient.registerObserver(this);
        });
    }
    pauseResubscribeCheck() {
        this.isResubscribeCheckPaused = true;
    }
    resumeResubscribeCheck() {
        if (!this.isResubscribeCheckPaused) {
            // Do not recheck subcribe if it wasn't paused to begin with.
            return;
        }
        this.isResubscribeCheckPaused = false;
        if (this.pendingMetricsReport) {
            this.context.logger.info('Resuming resubscribe check with pending metrics report');
            if (this.checkResubscribe(this.pendingMetricsReport)) {
                this.context.audioVideoController.update({ needsRenegotiation: false });
            }
        }
    }
    videoTileDidUpdate(_tileState) {
        this.context.maxVideoTileCount = Math.max(this.context.maxVideoTileCount, this.context.videoTileController.getAllVideoTiles().length);
    }
    checkResubscribe(clientMetricReport) {
        if (this.isResubscribeCheckPaused) {
            this.context.logger.info('Resubscribe check is paused, setting incoming client metric report as pending');
            this.pendingMetricsReport = clientMetricReport;
            return;
        }
        else {
            this.pendingMetricsReport = undefined;
        }
        const metricReport = clientMetricReport.getObservableMetrics();
        const availableSendBandwidth = metricReport.availableOutgoingBitrate;
        const nackCountPerSecond = metricReport.nackCountReceivedPerSecond;
        let needResubscribe = false;
        this.context.videoDownlinkBandwidthPolicy.updateMetrics(clientMetricReport);
        const resubscribeForDownlink = this.context.videoDownlinkBandwidthPolicy.wantsResubscribe();
        needResubscribe = needResubscribe || resubscribeForDownlink;
        if (resubscribeForDownlink) {
            const videoSubscriptionIdSet = this.context.videoDownlinkBandwidthPolicy.chooseSubscriptions();
            // Same logic as in `ReceiveVideoStreamIndexTask`, immediately truncating rather then truncating on subscribe
            // avoids any issues with components (e.g. transceiver controller) along the way.
            this.context.videosToReceive = videoSubscriptionIdSet.truncate(this.context.videoSubscriptionLimit);
            if (videoSubscriptionIdSet.size() > this.context.videosToReceive.size()) {
                this.logger.warn(`Video receive limit exceeded. Limiting the videos to ${this.context.videosToReceive.size()}. Please consider using AllHighestVideoBandwidthPolicy or VideoPriorityBasedPolicy along with chooseRemoteVideoSources api to select the video sources to be displayed.`);
            }
            this.logger.info(`trigger resubscribe for down=${resubscribeForDownlink}; videosToReceive=[${this.context.videosToReceive.array()}]`);
        }
        if (this.context.videoTileController.hasStartedLocalVideoTile()) {
            this.context.videoUplinkBandwidthPolicy.updateConnectionMetric({
                uplinkKbps: availableSendBandwidth / 1000,
                nackCountPerSecond: nackCountPerSecond,
            });
            const resubscribeForUplink = this.context.videoUplinkBandwidthPolicy.wantsResubscribe();
            needResubscribe = needResubscribe || resubscribeForUplink;
            if (resubscribeForUplink) {
                this.logger.info(`trigger resubscribe for up=${resubscribeForUplink}; videosToReceive=[${this.context.videosToReceive.array()}]`);
                this.context.videoUplinkBandwidthPolicy.chooseEncodingParameters();
            }
        }
        return needResubscribe;
    }
    metricsDidReceive(clientMetricReport) {
        if (this.checkResubscribe(clientMetricReport)) {
            this.context.audioVideoController.update({ needsRenegotiation: false });
        }
        if (!this.currentAvailableStreamAvgBitrates) {
            return;
        }
        const streamMetricReport = clientMetricReport.streamMetricReports;
        const downlinkVideoStream = new Map();
        // TODO: move those logic to stats collector.
        for (const ssrc in streamMetricReport) {
            if (streamMetricReport[ssrc].mediaType === ClientMetricReportMediaType_1.default.VIDEO &&
                streamMetricReport[ssrc].direction === ClientMetricReportDirection_1.default.DOWNSTREAM) {
                downlinkVideoStream.set(streamMetricReport[ssrc].streamId, streamMetricReport[ssrc]);
            }
        }
    }
    connectionHealthDidChange(connectionHealthData) {
        if (connectionHealthData.consecutiveMissedPongs === 0) {
            if (this.context.reconnectController) {
                this.context.reconnectController.setLastActiveTimestampMs(Date.now());
            }
        }
        this.applyHealthPolicy(this.reconnectionHealthPolicy, connectionHealthData, () => {
            this.context.audioVideoController.handleMeetingSessionStatus(new MeetingSessionStatus_1.default(MeetingSessionStatusCode_1.default.ConnectionHealthReconnect), null);
        });
        this.applyHealthPolicy(this.unusableAudioWarningHealthPolicy, connectionHealthData, () => {
            var _a;
            this.context.poorConnectionCount += 1;
            const attributes = this.generateAudioVideoEventAttributesForReceivingAudioDropped();
            (_a = this.context.eventController) === null || _a === void 0 ? void 0 : _a.publishEvent('receivingAudioDropped', attributes);
            if (this.context.videoTileController.haveVideoTilesWithStreams()) {
                this.context.audioVideoController.forEachObserver((observer) => {
                    Types_1.Maybe.of(observer.connectionDidSuggestStopVideo).map(f => f.bind(observer)());
                });
            }
            else {
                this.context.audioVideoController.forEachObserver((observer) => {
                    Types_1.Maybe.of(observer.connectionDidBecomePoor).map(f => f.bind(observer)());
                });
            }
        }, () => {
            this.context.audioVideoController.forEachObserver((observer) => {
                Types_1.Maybe.of(observer.connectionDidBecomeGood).map(f => f.bind(observer)());
            });
        });
        for (const policy of this.videoEncodingHealthPolicies) {
            this.applyHealthPolicy(policy, connectionHealthData, () => {
                this.degradeVideoCodec(policy.name);
                switch (policy.name) {
                    case VideoEncodingConnectionHealthPolicyName_1.default.VideoEncodingCpuHealth:
                        this.context.statsCollector.videoCodecDegradationHighEncodeCpuDidReceive();
                        break;
                    case VideoEncodingConnectionHealthPolicyName_1.default.VideoEncodingFramerateHealth:
                        this.context.statsCollector.videoCodecDegradationEncodeFailureDidReceive();
                        break;
                }
            });
        }
        if (this.isMeetingConnected) {
            this.applyHealthPolicy(this.sendingAudioFailureHealthPolicy, connectionHealthData, () => {
                var _a;
                const attributes = this.generateBaseAudioVideoEventAttributes();
                (_a = this.context.eventController) === null || _a === void 0 ? void 0 : _a.publishEvent('sendingAudioFailed', attributes);
            }, () => {
                var _a;
                const attributes = this.generateBaseAudioVideoEventAttributes();
                (_a = this.context.eventController) === null || _a === void 0 ? void 0 : _a.publishEvent('sendingAudioRecovered', attributes);
            });
        }
    }
    audioVideoDidStart() {
        this.isMeetingConnected = true;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    audioVideoDidStartConnecting(reconnecting) {
        // The expectation here is that the flag will be set to true again when audioVideoDidStart() is eventually called.
        this.isMeetingConnected = false;
    }
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    audioVideoDidStop(sessionStatus) {
        this.isMeetingConnected = false;
    }
    applyHealthPolicy(healthPolicy, connectionHealthData, unhealthyCallback, healthyCallback) {
        healthPolicy.update(connectionHealthData);
        const healthValue = healthPolicy.healthIfChanged();
        if (healthValue !== null) {
            this.logger.info(`${healthPolicy.name} value is now ${healthValue}`);
            if (healthValue <= healthPolicy.minimumHealth()) {
                Types_1.Maybe.of(unhealthyCallback).map(f => f.bind(this)());
            }
            else {
                Types_1.Maybe.of(healthyCallback).map(f => f.bind(this)());
            }
        }
    }
    handleBitrateFrame(bitrates) {
        this.currentAvailableStreamAvgBitrates = bitrates;
        if (bitrates.serverAvailableOutgoingBitrate > 0) {
            this.logger.info(`Received server side estimation of available incoming bitrate ${bitrates.serverAvailableOutgoingBitrate}kbps`);
            // This value will be included in the 'Bitrates' signaling message if we are using
            // server side remote video quality adaption, since if that is the case we will
            // be using TWCC and will therefore not likely have an estimate on the client
            // for available incoming bitrate
            this.context.statsCollector.overrideObservableMetric('availableIncomingBitrate', bitrates.serverAvailableOutgoingBitrate * 1000);
        }
    }
    handleSignalingClientEvent(event) {
        var _a;
        // Don't add two or more consecutive "signalingDropped" states.
        if ((event.type === SignalingClientEventType_1.default.WebSocketClosed &&
            (event.closeCode === 4410 || (event.closeCode >= 4500 && event.closeCode < 4600))) ||
            event.type === SignalingClientEventType_1.default.WebSocketError ||
            event.type === SignalingClientEventType_1.default.WebSocketFailed) {
            if (!this.hasSignalingError) {
                const attributes = this.generateAudioVideoEventAttributesForReceivingAudioDropped();
                (_a = this.context.eventController) === null || _a === void 0 ? void 0 : _a.publishEvent('signalingDropped', attributes);
                this.hasSignalingError = true;
            }
        }
        else if (event.type === SignalingClientEventType_1.default.WebSocketOpen) {
            this.hasSignalingError = false;
        }
        if (event.type === SignalingClientEventType_1.default.ReceivedSignalFrame) {
            if (event.message.type === SignalingProtocol_1.SdkSignalFrame.Type.NOTIFICATION) {
                switch (event.message.notification.level) {
                    case SignalingProtocol_1.SdkNotificationFrame.NotificationLevel.INFO:
                        this.logger.info(`Received notification from server: ${event.message.notification.message}`);
                        break;
                    case SignalingProtocol_1.SdkNotificationFrame.NotificationLevel.WARNING:
                        this.logger.warn(`Received warning from server: ${event.message.notification.message}`);
                        break;
                    case SignalingProtocol_1.SdkNotificationFrame.NotificationLevel.ERROR:
                        this.logger.error(`Received error from server: ${event.message.notification.message}`);
                        break;
                    default:
                        this.logger.error(`Received notification from server with unknown level ${event.message.notification.level}: ${event.message.notification.message}`);
                        break;
                }
                return;
            }
            if (!!event.message.bitrates) {
                const bitrateFrame = event.message.bitrates;
                this.context.videoStreamIndex.integrateBitratesFrame(bitrateFrame);
                this.context.videoDownlinkBandwidthPolicy.updateIndex(this.context.videoStreamIndex);
                this.handleBitrateFrame(event.message.bitrates);
            }
            const status = MeetingSessionStatus_1.default.fromSignalFrame(event.message);
            // Primary meeting join ack status will be handled by `PromoteToPrimaryMeetingTask`
            if (event.message.type !== SignalingProtocol_1.SdkSignalFrame.Type.PRIMARY_MEETING_JOIN_ACK &&
                status.statusCode() !== MeetingSessionStatusCode_1.default.OK) {
                this.context.audioVideoController.handleMeetingSessionStatus(status, null);
            }
        }
    }
    /**
     * Degrade video codec to an alternative codec
     */
    degradeVideoCodec(cause) {
        // Degrade video codec if there are other codec options and current codec is not H264 CBP or VP8
        if (this.context.meetingSupportedVideoSendCodecPreferences !== undefined &&
            this.context.meetingSupportedVideoSendCodecPreferences.length > 1 &&
            !(this.context.meetingSupportedVideoSendCodecPreferences[0].equals(VideoCodecCapability_1.default.h264ConstrainedBaselineProfile()) ||
                this.context.meetingSupportedVideoSendCodecPreferences[0].equals(VideoCodecCapability_1.default.vp8()))) {
            const newMeetingSupportedVideoSendCodecPreferences = [];
            for (const capability of this.context.videoSendCodecPreferences) {
                if (!capability.equals(this.context.meetingSupportedVideoSendCodecPreferences[0])) {
                    newMeetingSupportedVideoSendCodecPreferences.push(capability);
                }
            }
            if (newMeetingSupportedVideoSendCodecPreferences.length > 0) {
                this.context.logger.info(`Downgrading codec from ${this.context.meetingSupportedVideoSendCodecPreferences[0].codecName} to ${newMeetingSupportedVideoSendCodecPreferences[0].codecName} due to ${cause}`);
                this.context.degradedVideoSendCodecs.push(this.context.meetingSupportedVideoSendCodecPreferences[0]);
                this.context.meetingSupportedVideoSendCodecPreferences = newMeetingSupportedVideoSendCodecPreferences;
                if (this.context.videoUplinkBandwidthPolicy.setMeetingSupportedVideoSendCodecs) {
                    this.context.videoUplinkBandwidthPolicy.setMeetingSupportedVideoSendCodecs(this.context.meetingSupportedVideoSendCodecPreferences, this.context.videoSendCodecPreferences);
                }
                this.context.audioVideoController.update({ needsRenegotiation: true });
            }
            else {
                this.context.logger.warn(`Degrading video codec failed since there is no alternative codec to select. Currently degraded codecs: ${this.context.degradedVideoSendCodecs
                    .map(capability => capability.codecName)
                    .join(',')}`);
            }
        }
    }
}
exports.default = MonitorTask;
//# sourceMappingURL=MonitorTask.js.map
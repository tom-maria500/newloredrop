{"version":3,"file":"OnceTask.js","sourceRoot":"","sources":["../../src/task/OnceTask.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport Logger from '../logger/Logger';\nimport LogLevel from '../logger/LogLevel';\nimport AsyncScheduler from '../scheduler/AsyncScheduler';\nimport Task from './Task';\n\n/**\n * A task that wraps another task and ensures it is run only once,\n * regardless of how many times `run` is called.\n *\n * This allows you to implement a kind of barrier synchronization.\n */\nexport default class OnceTask implements Task {\n  // Our dependencies or the inner task.\n  private ongoing: Promise<void> | undefined;\n\n  // The output promise, so that we can cancel.\n  private promise: Promise<void> | undefined;\n\n  private cancelPromise: ((e: Error) => void) | undefined;\n\n  // Whether we have canceled.\n  private canceled = false;\n\n  constructor(\n    private logger: Logger,\n    private task: Task,\n    private dependencies?: (Task | undefined)[]\n  ) {}\n\n  name(): string {\n    return `${this.task.name()} (once)`;\n  }\n\n  cancel(): void {\n    // We want to preserve one interesting property: the deepest dependency that hasn't\n    // already finished or been canceled is the first to be canceled, and its failure\n    // will propagate back up the promise chain.\n    //\n    // We can't just cancel ourselves with cancelPromise -- we will cut off the rest of\n    // the tree. Nor can we necessarily do it on the same event loop tick, because the\n    // cancelation might be subtly async.\n    //\n    // Instead, we immediately cancel each dependency, and then we cancel the current\n    // task (if it's running), and then we cancel via our promise escape hatch if needed.\n\n    /* istanbul ignore if */\n    if (this.canceled) {\n      return;\n    }\n\n    if (this.dependencies) {\n      for (const dep of this.dependencies) {\n        dep.cancel();\n      }\n    }\n\n    // Do this on the next tick so that our canceled dependencies cascade.\n    this.logger.info(`Canceling ${this.name()}`);\n    AsyncScheduler.nextTick(() => this.task.cancel());\n    this.canceled = true;\n\n    if (this.cancelPromise) {\n      AsyncScheduler.nextTick(() => this.cancelPromise(new Error(`canceling ${this.name()}`)));\n    }\n  }\n\n  logDependencies(): void {\n    if (this.logger.getLogLevel() > LogLevel.INFO) {\n      return;\n    }\n    if (!this.dependencies) {\n      return;\n    }\n    const names = this.dependencies\n      .filter(d => d)\n      .map(d => d.name())\n      .join(', ');\n    this.logger.info(`${this.task.name()} waiting for dependencies: ${names}`);\n  }\n\n  run(): Promise<void> {\n    if (this.promise) {\n      return this.promise;\n    }\n\n    const dependencies = this.dependencies\n      ? Promise.all(this.dependencies.map(d => d?.run()))\n      : Promise.resolve();\n\n    this.logDependencies();\n\n    this.ongoing = dependencies.then(() => this.task.run());\n\n    return (this.promise = new Promise((resolve, reject) => {\n      this.cancelPromise = reject;\n      this.ongoing.then(resolve).catch(reject);\n    }));\n  }\n\n  setParent(parentTask: Task): void {\n    this.task.setParent(parentTask);\n  }\n}\n"]}
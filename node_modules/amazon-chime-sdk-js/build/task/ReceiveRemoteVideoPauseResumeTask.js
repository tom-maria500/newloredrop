"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const SignalingClientEventType_1 = __importDefault(require("../signalingclient/SignalingClientEventType"));
const SignalingProtocol_js_1 = require("../signalingprotocol/SignalingProtocol.js");
const BaseTask_1 = __importDefault(require("./BaseTask"));
/*
 * [[ReceiveRemoteVideoPauseResume]] receives [[SdkPauseFrame]] from the server side (only if
 * `VideoDownlinkBandwidthPolicy.getServerSideNetworkAdaption()` == `BandwidthProbingAndRemoteVideoQualityAdaption`)
 * which indicates remote video sources that have been paused or resumed and updates [[VideoDownlinkBandwidthPolicy]]
 * and [[VideoTileController]]
 *
 */
class ReceiveRemoteVideoPauseResume extends BaseTask_1.default {
    constructor(context) {
        super(context.logger);
        this.context = context;
        this.taskName = 'ReceiveRemoteVideoPauseResume';
        this.serverPausedVideoTileIds = new Set();
    }
    removeObserver() {
        this.context.signalingClient.removeObserver(this);
    }
    run() {
        return __awaiter(this, void 0, void 0, function* () {
            this.context.signalingClient.registerObserver(this);
            this.context.removableObservers.push(this);
        });
    }
    updateSubscribedGroupdIds(groupIds) {
        const existingVideoTileIds = new Set();
        for (const groupId of groupIds) {
            const attendeeId = this.context.videoStreamIndex.attendeeIdForGroupId(groupId);
            if (attendeeId.length === 0) {
                this.logger.warn(`Could not find attendee ID for newly subscribed group ID ${groupId}`);
                continue;
            }
            let videoTile = this.context.videoTileController.getVideoTileForAttendeeId(attendeeId);
            if (videoTile === undefined) {
                this.logger.info(`No existing video tile for attendee ID ${attendeeId} with new group ID ${groupId}. Creating new one.`);
                videoTile = this.context.videoTileController.addVideoTile();
                videoTile.bindVideoStream(attendeeId, false, null, 0, 0, 0, null);
            }
            existingVideoTileIds.add(videoTile.id());
        }
        this.serverPausedVideoTileIds.forEach(id => {
            if (!existingVideoTileIds.has(id)) {
                this.serverPausedVideoTileIds.delete(id);
            }
        });
    }
    handleSignalingClientEvent(event) {
        if (event.type !== SignalingClientEventType_1.default.ReceivedSignalFrame ||
            (event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.PAUSE &&
                event.message.type !== SignalingProtocol_js_1.SdkSignalFrame.Type.RESUME)) {
            return;
        }
        // @ts-ignore: force cast to SdkPauseFrame
        const pauseResumeFrame = event.message.pause;
        const messageType = event.message.type;
        this.logger.info(`Received new ${messageType === SignalingProtocol_js_1.SdkSignalFrame.Type.PAUSE ? 'pause' : 'resume'} frame: ${JSON.stringify(pauseResumeFrame)}`);
        if (!pauseResumeFrame ||
            this.context.videoTileController.getVideoTileForAttendeeId === undefined ||
            this.context.videoDownlinkBandwidthPolicy.forEachObserver === undefined ||
            this.context.videoStreamIndex.attendeeIdForGroupId === undefined) {
            return;
        }
        const tiles = pauseResumeFrame.groupIds.map((groupId) => {
            const attendeeId = this.context.videoStreamIndex.attendeeIdForGroupId(groupId);
            if (attendeeId.length === 0) {
                this.logger.warn(`Could not find attendee ID for paused group ID ${groupId}`);
                return undefined;
            }
            return this.context.videoTileController.getVideoTileForAttendeeId(attendeeId);
        });
        for (const tile of tiles) {
            if (tile === undefined) {
                // Warning is logged above
                continue;
            }
            if (messageType === SignalingProtocol_js_1.SdkSignalFrame.Type.PAUSE) {
                if (!tile.state().paused) {
                    this.serverPausedVideoTileIds.add(tile.id());
                    this.context.videoDownlinkBandwidthPolicy.forEachObserver((observer) => {
                        observer.tileWillBePausedByDownlinkPolicy(tile.id());
                    });
                    // This circumvents the tile controller so it will not send
                    // any signaling messages to server side.
                    tile.pause();
                }
            }
            else {
                // Don't resume user paused video tiles
                if (tile.state().paused && this.serverPausedVideoTileIds.has(tile.id())) {
                    this.serverPausedVideoTileIds.delete(tile.id());
                    this.context.videoDownlinkBandwidthPolicy.forEachObserver((observer) => {
                        observer.tileWillBeUnpausedByDownlinkPolicy(tile.id());
                    });
                    // See comment above.
                    tile.unpause();
                }
            }
        }
    }
}
exports.default = ReceiveRemoteVideoPauseResume;
//# sourceMappingURL=ReceiveRemoteVideoPauseResumeTask.js.map
"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultModality_1 = __importDefault(require("../modality/DefaultModality"));
const SDP_1 = __importDefault(require("../sdp/SDP"));
const VideoCodecCapability_1 = __importDefault(require("../sdp/VideoCodecCapability"));
const BaseTask_1 = __importDefault(require("./BaseTask"));
/*
 * [[SetRemoteDescriptionTask]] asynchronously calls [[setRemoteDescription]] on the
 * peer connection and then waits for the tracks to be added and for the ICE connection
 * to complete.
 */
class SetRemoteDescriptionTask extends BaseTask_1.default {
    constructor(context) {
        super(context.logger);
        this.context = context;
        this.taskName = 'SetRemoteDescriptionTask';
    }
    cancel() {
        if (this.cancelICEPromise) {
            this.cancelICEPromise();
        }
    }
    run() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const peer = this.context.peer;
            if (!peer) {
                this.logAndThrow('session does not have peer connection; bypass set remote description');
            }
            let sdp = this.context.sdpAnswer;
            sdp = new SDP_1.default(sdp).withoutServerReflexiveCandidates().sdp;
            if (this.context.audioProfile) {
                sdp = new SDP_1.default(sdp).withAudioMaxAverageBitrate(this.context.audioProfile.audioBitrateBps).sdp;
                if (this.context.audioProfile.isStereo()) {
                    sdp = new SDP_1.default(sdp).withStereoAudio().sdp;
                }
            }
            if (this.context.videoSendCodecPreferences !== undefined &&
                this.context.videoSendCodecPreferences.length > 0) {
                sdp = new SDP_1.default(sdp).withVideoSendCodecPreferences(this.context.meetingSupportedVideoSendCodecPreferences !== undefined
                    ? this.context.meetingSupportedVideoSendCodecPreferences
                    : this.context.videoSendCodecPreferences).sdp;
            }
            this.context.prioritizedSendVideoCodecCapabilities = new SDP_1.default(sdp).prioritizedSendVideoCodecCapabilities();
            this.context.currentVideoSendCodec =
                this.context.prioritizedSendVideoCodecCapabilities.length > 0
                    ? this.context.prioritizedSendVideoCodecCapabilities[0]
                    : undefined;
            const mediaStream = this.context.activeVideoInput;
            if (mediaStream !== undefined) {
                const attendeeId = this.context.audioVideoController.configuration.credentials.attendeeId;
                const isContent = new DefaultModality_1.default(attendeeId).hasModality(DefaultModality_1.default.MODALITY_CONTENT);
                const videoTrack = mediaStream.getVideoTracks()[0];
                if (isContent) {
                    if (((_a = this.context.currentVideoSendCodec) === null || _a === void 0 ? void 0 : _a.codecName) === VideoCodecCapability_1.default.av1Main().codecName) {
                        // Based on our experiments: "text" contentHint gives good coding performance for content share using AV1
                        // @ts-ignore
                        videoTrack.contentHint = 'text';
                        this.logger.info(`Setting content hint to text for AV1, attendee: ${attendeeId}`);
                    }
                    else if (this.context.audioVideoController.configuration.enableSVC) {
                        // Set content hint to `motion` as a workaround for the issue Chrome cannot enable
                        // temporal scalability for screen share
                        // https://bugs.chromium.org/p/chromium/issues/detail?id=1433486
                        // @ts-ignore
                        videoTrack.contentHint = 'motion';
                        this.logger.info(`Setting content hint to motion to enable SVC, attendee: ${attendeeId}`);
                    }
                }
            }
            this.logger.info(`processed remote description is >>>${sdp}<<<`);
            const remoteDescription = {
                type: 'answer',
                sdp: sdp,
                toJSON: null,
            };
            try {
                yield this.createICEConnectionCompletedPromise(remoteDescription);
            }
            catch (err) {
                throw err;
            }
        });
    }
    createICEConnectionCompletedPromise(remoteDescription) {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            const checkConnectionCompleted = () => {
                if (this.context.peer.iceConnectionState === 'connected' ||
                    this.context.peer.iceConnectionState === 'completed') {
                    this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);
                    resolve();
                }
            };
            this.cancelICEPromise = () => {
                if (this.context.peer) {
                    this.context.peer.removeEventListener('iceconnectionstatechange', checkConnectionCompleted);
                }
                reject(new Error(`${this.name()} got canceled while waiting for the ICE connection state`));
            };
            this.context.peer.addEventListener('iceconnectionstatechange', checkConnectionCompleted);
            try {
                yield this.context.peer.setRemoteDescription(remoteDescription);
                this.logger.info('set remote description, waiting for ICE connection');
                checkConnectionCompleted();
            }
            catch (err) {
                reject(err);
            }
        }));
    }
}
exports.default = SetRemoteDescriptionTask;
//# sourceMappingURL=SetRemoteDescriptionTask.js.map
{"version":3,"file":"ReceiveVideoStreamIndexTask.js","sourceRoot":"","sources":["../../src/task/ReceiveVideoStreamIndexTask.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport AudioVideoControllerState from '../audiovideocontroller/AudioVideoControllerState';\nimport AudioVideoObserver from '../audiovideoobserver/AudioVideoObserver';\nimport MeetingSessionVideoAvailability from '../meetingsession/MeetingSessionVideoAvailability';\nimport DefaultModality from '../modality/DefaultModality';\nimport RemovableObserver from '../removableobserver/RemovableObserver';\nimport VideoCodecCapability from '../sdp/VideoCodecCapability';\nimport SignalingClientEvent from '../signalingclient/SignalingClientEvent';\nimport SignalingClientEventType from '../signalingclient/SignalingClientEventType';\nimport SignalingClientObserver from '../signalingclientobserver/SignalingClientObserver';\nimport {\n  SdkIndexFrame,\n  SdkSignalFrame,\n  SdkStreamServiceType,\n} from '../signalingprotocol/SignalingProtocol.js';\nimport { Maybe } from '../utils/Types';\nimport VideoDownlinkBandwidthPolicy from '../videodownlinkbandwidthpolicy/VideoDownlinkBandwidthPolicy';\nimport VideoSource from '../videosource/VideoSource';\nimport VideoStreamIdSet from '../videostreamidset/VideoStreamIdSet';\nimport VideoUplinkBandwidthPolicy from '../videouplinkbandwidthpolicy/VideoUplinkBandwidthPolicy';\nimport BaseTask from './BaseTask';\n\n/*\n * [[ReceiveVideoStreamIndexTask]] receives [[SdkIndexFrame]] and updates [[VideoUplinkBandwidthPolicy]] and [[VideoDownlinkBandwidthPolicy]].\n */\nexport default class ReceiveVideoStreamIndexTask\n  extends BaseTask\n  implements SignalingClientObserver, RemovableObserver {\n  protected taskName = 'ReceiveVideoStreamIndexTask';\n\n  // See comment above invocation of `pauseIngestion` in `DefaultAudioVideoController`\n  // for explanation.\n  private isIngestionPaused: boolean = false;\n  private pendingIndex: SdkIndexFrame | null = null;\n\n  constructor(private context: AudioVideoControllerState) {\n    super(context.logger);\n  }\n\n  removeObserver(): void {\n    this.context.signalingClient.removeObserver(this);\n  }\n\n  async run(): Promise<void> {\n    this.handleIndexFrame(this.context.indexFrame);\n    this.context.signalingClient.registerObserver(this);\n    this.context.removableObservers.push(this);\n  }\n\n  handleSignalingClientEvent(event: SignalingClientEvent): void {\n    if (\n      event.type !== SignalingClientEventType.ReceivedSignalFrame ||\n      event.message.type !== SdkSignalFrame.Type.INDEX\n    ) {\n      return;\n    }\n    // @ts-ignore: force cast to SdkIndexFrame\n    const indexFrame: SdkIndexFrame = event.message.index;\n    this.context.logger.info(`received new index ${JSON.stringify(indexFrame)}`);\n    this.handleIndexFrame(indexFrame);\n  }\n\n  pauseIngestion(): void {\n    this.isIngestionPaused = true;\n  }\n\n  resumeIngestion(): void {\n    if (!this.isIngestionPaused) {\n      // Do not recheck subcribe if it wasn't paused to begin with.\n      return;\n    }\n    this.isIngestionPaused = false;\n    if (this.pendingIndex) {\n      this.context.logger.info('Resuming index ingestion with pending index');\n      this.handleIndexFrame(this.pendingIndex);\n    }\n  }\n\n  private handleIndexFrame(indexFrame: SdkIndexFrame | null): void {\n    if (!indexFrame) {\n      return;\n    }\n\n    if (this.isIngestionPaused) {\n      this.context.logger.info(`Index ingestion is paused, setting most recent index as pending`);\n      this.pendingIndex = indexFrame;\n      return;\n    } else {\n      this.pendingIndex = null;\n    }\n\n    // Filter out self content share video\n    const selfAttendeeId = this.context.audioVideoController.configuration.credentials.attendeeId;\n    indexFrame.sources = indexFrame.sources.filter(source => {\n      const modality = new DefaultModality(source.attendeeId);\n      return !(\n        modality.base() === selfAttendeeId && modality.hasModality(DefaultModality.MODALITY_CONTENT)\n      );\n    });\n\n    const {\n      videoStreamIndex,\n      videoDownlinkBandwidthPolicy,\n      videoUplinkBandwidthPolicy,\n    } = this.context;\n\n    const oldVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n    videoStreamIndex.integrateIndexFrame(indexFrame);\n    videoDownlinkBandwidthPolicy.updateIndex(videoStreamIndex);\n    videoUplinkBandwidthPolicy.updateIndex(videoStreamIndex);\n\n    this.resubscribe(videoDownlinkBandwidthPolicy, videoUplinkBandwidthPolicy);\n    this.updateVideoAvailability(indexFrame);\n    this.handleIndexVideosPausedAtSource();\n    if (indexFrame.supportedReceiveCodecIntersection.length > 0) {\n      this.handleSupportedVideoReceiveCodecIntersection(indexFrame);\n    }\n    // `forEachObserver`is asynchronous anyways so it doesn't matter (for better or worse) whether we\n    // trigger it before or after the policy update + possible resubscribe kickoff\n    const newVideoSources = videoStreamIndex.allVideoSendingSourcesExcludingSelf(selfAttendeeId);\n    if (!this.areVideoSourcesEqual(oldVideoSources, newVideoSources)) {\n      this.context.audioVideoController.forEachObserver((observer: AudioVideoObserver) => {\n        Maybe.of(observer.remoteVideoSourcesDidChange).map(f => f.bind(observer)(newVideoSources));\n      });\n    }\n  }\n\n  private areVideoSourcesEqual(\n    oldVideoSources: VideoSource[],\n    newVideoSources: VideoSource[]\n  ): boolean {\n    if (oldVideoSources.length !== newVideoSources.length) {\n      return false;\n    }\n    const compare = (videoSourceA: VideoSource, videoSourceB: VideoSource): number =>\n      videoSourceA.attendee.attendeeId.localeCompare(videoSourceB.attendee.attendeeId);\n\n    const sortedOldVideoSources = [...oldVideoSources].sort(compare);\n    const sortedNewVideoSources = [...newVideoSources].sort(compare);\n\n    for (let i = 0; i < sortedOldVideoSources.length; i++) {\n      if (\n        sortedOldVideoSources[i].attendee.attendeeId !==\n        sortedNewVideoSources[i].attendee.attendeeId\n      ) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  private resubscribe(\n    videoDownlinkBandwidthPolicy: VideoDownlinkBandwidthPolicy,\n    videoUplinkBandwidthPolicy: VideoUplinkBandwidthPolicy\n  ): void {\n    const resubscribeForDownlink: boolean = videoDownlinkBandwidthPolicy.wantsResubscribe();\n    const resubscribeForUplink: boolean =\n      (this.context.videoDuplexMode === SdkStreamServiceType.TX ||\n        this.context.videoDuplexMode === SdkStreamServiceType.DUPLEX) &&\n      videoUplinkBandwidthPolicy.wantsResubscribe();\n    const shouldResubscribe = resubscribeForDownlink || resubscribeForUplink;\n    this.logger.info(\n      `should resubscribe: ${shouldResubscribe} (downlink: ${resubscribeForDownlink} uplink: ${resubscribeForUplink})`\n    );\n    if (!shouldResubscribe) {\n      return;\n    }\n\n    const videoSubscriptionIdSet = videoDownlinkBandwidthPolicy.chooseSubscriptions();\n    this.context.videosToReceive = videoSubscriptionIdSet.truncate(\n      this.context.videoSubscriptionLimit\n    );\n\n    if (videoSubscriptionIdSet.size() > this.context.videosToReceive.size()) {\n      this.logger.warn(\n        `Video receive limit exceeded. Limiting the videos to ${this.context.videosToReceive.size()}. Please consider using AllHighestVideoBandwidthPolicy or VideoPriorityBasedPolicy along with chooseRemoteVideoSources api to select the video sources to be displayed.`\n      );\n    }\n\n    this.context.videoCaptureAndEncodeParameter = videoUplinkBandwidthPolicy.chooseCaptureAndEncodeParameters();\n    this.logger.info(\n      `trigger resubscribe for up=${resubscribeForUplink} down=${resubscribeForDownlink}; videosToReceive=[${this.context.videosToReceive.array()}] captureParams=${JSON.stringify(\n        this.context.videoCaptureAndEncodeParameter\n      )}`\n    );\n    this.context.audioVideoController.update({ needsRenegotiation: false });\n  }\n\n  private updateVideoAvailability(indexFrame: SdkIndexFrame): void {\n    if (!this.context.videosToReceive) {\n      this.logger.error('videosToReceive must be set in the meeting context.');\n      return;\n    }\n\n    const videoAvailability = new MeetingSessionVideoAvailability();\n    videoAvailability.remoteVideoAvailable = !this.context.videosToReceive.empty();\n    videoAvailability.canStartLocalVideo = !indexFrame.atCapacity;\n    if (\n      !this.context.lastKnownVideoAvailability ||\n      !this.context.lastKnownVideoAvailability.equal(videoAvailability)\n    ) {\n      this.context.lastKnownVideoAvailability = videoAvailability.clone();\n      this.context.audioVideoController.forEachObserver((observer: AudioVideoObserver) => {\n        Maybe.of(observer.videoAvailabilityDidChange).map(f =>\n          f.bind(observer)(videoAvailability.clone())\n        );\n      });\n    }\n  }\n\n  private handleSupportedVideoReceiveCodecIntersection(index: SdkIndexFrame): void {\n    if (this.context.videoSendCodecPreferences === undefined) {\n      return;\n    }\n\n    // The following list contains the configured send codec preferences filtered to\n    // only what is supported by the meeting\n    const newMeetingSupportedVideoSendCodecPreferences: VideoCodecCapability[] = [];\n    // Will be set to true if we need to force a negotiation to change the codec\n    let willNeedUpdate = false;\n\n    // Intersect `this.context.videoSendCodecPreferences` with `index.supportedReceiveCodecIntersection`\n    // and filter out any send video codecs we have determined to be degraded\n    for (const capability of this.context.videoSendCodecPreferences) {\n      if (\n        this.context.degradedVideoSendCodecs.some(degradedCapability =>\n          capability.equals(degradedCapability)\n        )\n      ) {\n        this.logger.info(\n          `Skipping ${capability.codecName} since the codec has been identfied as degraded`\n        );\n        continue;\n      }\n      for (const signaledCapability of index.supportedReceiveCodecIntersection) {\n        if (capability.equals(VideoCodecCapability.fromSignaled(signaledCapability))) {\n          newMeetingSupportedVideoSendCodecPreferences.push(capability);\n          break;\n        }\n      }\n    }\n\n    if (newMeetingSupportedVideoSendCodecPreferences.length > 0) {\n      // We need to renegotiate if we are currently sending a codec that is no longer supported in the call, or if we can\n      // start sending a higher preference codec again (due to a constrained remote attendee leaving)\n\n      // First we find the first codec from our send preferences that has already been intersected with the\n      // codecs supported by the meeting, that we know we can support. This is what we want to send.\n      const firstMatchingCodecPreference = newMeetingSupportedVideoSendCodecPreferences.find(\n        capability =>\n          this.context.prioritizedSendVideoCodecCapabilities.some(prioritizedCapability =>\n            capability.equals(prioritizedCapability)\n          )\n      );\n      // If that codec is not what we are sending, trigger an update\n      if (\n        this.context.currentVideoSendCodec !== undefined &&\n        (firstMatchingCodecPreference === undefined ||\n          !this.context.currentVideoSendCodec.equals(firstMatchingCodecPreference))\n      ) {\n        willNeedUpdate = true;\n      }\n      this.context.meetingSupportedVideoSendCodecPreferences = newMeetingSupportedVideoSendCodecPreferences;\n    } else {\n      this.logger.warn(\n        'Interesection of meeting receive codec support and send codec preferences has no overlap, falling back to just values provided in `setVideoCodecSendPreferences`'\n      );\n      this.context.meetingSupportedVideoSendCodecPreferences = undefined;\n    }\n\n    if (this.context.videoUplinkBandwidthPolicy.setMeetingSupportedVideoSendCodecs) {\n      this.context.videoUplinkBandwidthPolicy.setMeetingSupportedVideoSendCodecs(\n        this.context.meetingSupportedVideoSendCodecPreferences,\n        this.context.videoSendCodecPreferences\n      );\n    }\n\n    if (willNeedUpdate) {\n      this.context.audioVideoController.update({ needsRenegotiation: true });\n    }\n  }\n\n  private handleIndexVideosPausedAtSource(): void {\n    const streamsPausedAtSource: VideoStreamIdSet = this.context.videoStreamIndex.streamsPausedAtSource();\n    for (const tile of this.context.videoTileController.getAllVideoTiles()) {\n      const tileState = tile.state();\n      if (streamsPausedAtSource.contain(tileState.streamId)) {\n        if (tile.markPoorConnection()) {\n          this.logger.info(`marks the tile ${tileState.tileId} as having a poor connection`);\n        }\n      } else {\n        if (tile.unmarkPoorConnection()) {\n          this.logger.info(`unmarks the tile ${tileState.tileId} as having a poor connection`);\n        }\n      }\n    }\n  }\n}\n"]}
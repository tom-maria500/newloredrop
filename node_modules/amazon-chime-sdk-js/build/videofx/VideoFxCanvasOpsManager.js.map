{"version":3,"file":"VideoFxCanvasOpsManager.js","sourceRoot":"","sources":["../../src/videofx/VideoFxCanvasOpsManager.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport Logger from '../logger/Logger';\nimport VideoFxConfig from './VideoFxConfig';\nimport { SEGMENTATION_MODEL } from './VideoFxConstants';\nimport { VideoFxStreamParameters } from './VideoFxStreamParameters';\n\n/**\n * [[VideoFxCanvasOpsManager]] Mechanism drives the canvas based operations\n * for the VideoFxProcessor. This includes input stream resizing to segmentation model\n * dimensions and managing the canvas loading for background replacement.\n */\nexport class VideoFxCanvasOpsManager {\n  private logger: Logger;\n  private streamParameters: VideoFxStreamParameters;\n  private inferenceCanvas: HTMLCanvasElement;\n  private inferenceCtx: CanvasRenderingContext2D;\n  private outputCanvas: HTMLCanvasElement;\n  private horizontalResizeScalar: number;\n  private verticalResizeScalar: number;\n  private backgroundReplacementCanvas: HTMLCanvasElement;\n  private backgroundReplacementImage: HTMLImageElement;\n\n  constructor(streamParameters: VideoFxStreamParameters, outputCanvas: HTMLCanvasElement) {\n    this.streamParameters = streamParameters;\n    this.outputCanvas = outputCanvas;\n    this.configureCanvasPipeline();\n  }\n\n  /**\n   * Generate the raw image data in a format that is directly importable into\n   * the segmentation model\n   * @param inputCanvas\n   * @returns ImageData\n   */\n  getInferenceInputData(inputCanvas: HTMLCanvasElement): ImageData {\n    // Resize our full resolution frame into a new canvas scaled to the\n    // size of our segmentation model\n    this.inferenceCtx.save();\n    this.inferenceCtx.scale(this.horizontalResizeScalar, this.verticalResizeScalar);\n    this.inferenceCtx.drawImage(inputCanvas, 0, 0);\n    this.inferenceCtx.restore();\n    // Now we can directly take image data that is the desired size of\n    // of our segmentation model linput\n    const inferenceInputData = this.inferenceCtx.getImageData(\n      0,\n      0,\n      SEGMENTATION_MODEL.WIDTH_IN_PIXELS,\n      SEGMENTATION_MODEL.HEIGHT_IN_PIXELS\n    );\n    return inferenceInputData;\n  }\n\n  /**\n   * Reconfigure the canvas operations/pipeline to fit the dimensions of the new\n   * video stream, and resize background replacement canvas.\n   * @param streamParameters an VideoFxStreamParameters object specifying stream dimensions\n   */\n  async configureForStreamParameters(streamParameters: VideoFxStreamParameters): Promise<void> {\n    this.streamParameters = streamParameters;\n    this.outputCanvas.width = this.streamParameters.width;\n    this.outputCanvas.height = this.streamParameters.height;\n\n    // Resize background replacement canvas -- if it exists\n    if (this.backgroundReplacementCanvas) {\n      const resizedCanvas = document.createElement('canvas');\n      resizedCanvas.width = this.streamParameters.width;\n      resizedCanvas.height = this.streamParameters.height;\n      resizedCanvas\n        .getContext('2d')\n        .drawImage(\n          this.backgroundReplacementCanvas,\n          0,\n          0,\n          this.streamParameters.width,\n          this.streamParameters.height\n        );\n      this.backgroundReplacementCanvas = resizedCanvas;\n    }\n\n    this.configureCanvasPipeline();\n  }\n\n  /**\n   * Configure the inference canvas so that write operations to the canvas\n   * result in an image resizing.\n   */\n  private configureCanvasPipeline(): void {\n    // Create new inference canvas and context\n    this.inferenceCanvas = document.createElement('canvas');\n    this.inferenceCtx = this.inferenceCanvas.getContext('2d', {\n      willReadFrequently: true,\n    }) as CanvasRenderingContext2D;\n    // Configure the resize operation, which will be utilized by calling scale\n    // and then drawing any sized input to the canvas\n    this.inferenceCanvas.width = SEGMENTATION_MODEL.WIDTH_IN_PIXELS;\n    this.inferenceCanvas.height = SEGMENTATION_MODEL.HEIGHT_IN_PIXELS;\n    this.horizontalResizeScalar = SEGMENTATION_MODEL.WIDTH_IN_PIXELS / this.streamParameters.width;\n    this.verticalResizeScalar = SEGMENTATION_MODEL.HEIGHT_IN_PIXELS / this.streamParameters.height;\n  }\n\n  /**\n   * Return the background replacement canvas\n   * @returns HTMLCanvasElement\n   */\n  getBackgroundReplacementCanvas(): HTMLCanvasElement {\n    return this.backgroundReplacementCanvas;\n  }\n\n  /**\n   * Attempt to load custom replacement background image from URL, or the default background color.\n   * The backgroundReplacementCanvas is then set from the loaded image.\n   * @param effectConfig\n   */\n  async loadReplacementBackground(effectConfig: VideoFxConfig): Promise<void> {\n    const imageURL = effectConfig.backgroundReplacement.backgroundImageURL;\n    const defaultColor = effectConfig.backgroundReplacement.defaultColor;\n    if (imageURL) {\n      try {\n        const backgroundImage = await this.loadImage(imageURL);\n        this.backgroundReplacementImage = backgroundImage;\n        this.resizeAndSetReplacementImage(this.backgroundReplacementImage);\n      } catch (error) /* istanbul ignore next */ {\n        // The following can only happen due to an intermittent network issue.\n        this.logger.error(error);\n        throw new Error('Failed to set the replacement image.');\n      }\n    } else {\n      this.resizeAndSetReplacementColor(defaultColor);\n    }\n  }\n\n  /**\n   * Draw loaded image on a canvas sized to the stream parameters, which is then set to the\n   * backgroundReplacementCanvas member variable.\n   * @param backgroundImage\n   */\n  private resizeAndSetReplacementImage(backgroundImage: HTMLImageElement): void {\n    const resizedCanvas = document.createElement('canvas');\n    const resizedCtx = resizedCanvas.getContext('2d');\n    resizedCanvas.width = this.streamParameters.width;\n    resizedCanvas.height = this.streamParameters.height;\n    resizedCtx.drawImage(\n      backgroundImage,\n      0,\n      0,\n      this.streamParameters.width,\n      this.streamParameters.height\n    );\n    this.backgroundReplacementCanvas = resizedCanvas;\n  }\n\n  /**\n   * Fill default color on a canvas sized to the stream parameters, which is then set to the\n   * backgroundReplacementCanvas member variable.\n   * @param defaultColor\n   */\n  private resizeAndSetReplacementColor(defaultColor: string): void {\n    const resizedCanvas = document.createElement('canvas');\n    const resizedCtx = resizedCanvas.getContext('2d');\n    resizedCanvas.width = this.streamParameters.width;\n    resizedCanvas.height = this.streamParameters.height;\n    resizedCtx.fillStyle = defaultColor;\n    resizedCtx.fillRect(0, 0, this.streamParameters.width, this.streamParameters.height);\n    this.backgroundReplacementCanvas = resizedCanvas;\n  }\n\n  /**\n   * Attempt to load background image from URL.\n   * @param backgroundImageURL\n   * @returns Promise<HTMLCanvasElement>\n   */\n  async loadImage(backgroundImageURL: string): Promise<HTMLImageElement> {\n    // Attempt to fetch the image\n    const image = await fetch(backgroundImageURL).catch(error => {\n      this.logger.error(error.toString());\n      // Error returned in unit tests from mock fetch is non-compatible\n      /* istanbul ignore next */\n      throw new Error('Failed to fetch image.');\n    });\n\n    // Convert successful fetch into an HTMLImageElement\n    const imageBlob = await image.blob();\n    const img = new Image();\n    img.src = URL.createObjectURL(imageBlob);\n    return new Promise((resolve, reject) => {\n      img.onload = () => {\n        resolve(img);\n      };\n      img.onerror = error => {\n        reject(error);\n      };\n    });\n  }\n}\n"]}
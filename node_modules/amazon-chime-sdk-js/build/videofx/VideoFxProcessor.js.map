{"version":3,"file":"VideoFxProcessor.js","sourceRoot":"","sources":["../../src/videofx/VideoFxProcessor.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport { fetchWithBehavior } from '../../libs/voicefocus/fetch';\nimport { loadWorker } from '../../libs/voicefocus/loader';\nimport { supportsWASM, supportsWorker } from '../../libs/voicefocus/support';\nimport DefaultBrowserBehavior from '../browserbehavior/DefaultBrowserBehavior';\nimport EventController from '../eventcontroller/EventController';\nimport VideoFXEventAttributes from '../eventcontroller/VideoFXEventAttributes';\nimport Logger from '../logger/Logger';\nimport NoOpLogger from '../logger/NoOpLogger';\nimport { getDefaultAssetSpec } from '../utils/Utils';\nimport Versioning from '../versioning/Versioning';\nimport CanvasVideoFrameBuffer from '../videoframeprocessor/CanvasVideoFrameBuffer';\nimport VideoFrameBuffer from '../videoframeprocessor/VideoFrameBuffer';\nimport VideoFrameProcessor from '../videoframeprocessor/VideoFrameProcessor';\nimport { DeferredPromise } from './DeferredPromise';\nimport { VideoFxAssetParams } from './VideoFxAssetParams';\nimport { VideoFxCanvasOpsManager } from './VideoFxCanvasOpsManager';\nimport VideoFxConfig from './VideoFxConfig';\nimport {\n  DEFAULT_STREAM_PARAMETERS,\n  DEFAULT_VIDEO_FX_SPEC,\n  RESOURCE_CONSTRAINTS,\n  SEGMENTATION_MODEL,\n  WORKER_MSG,\n} from './VideoFxConstants';\nimport { VideoFxRenderer } from './VideoFxRenderer';\nimport { VideoFxSegmentationRateManager } from './VideoFxSegmentationRateManager';\nimport VideoFxSpec from './VideoFxSpec';\nimport { VideoFxStreamParameters } from './VideoFxStreamParameters';\n\n/**\n * [[VideoFxProcessor]] Mechanism that drives the data transformation\n * of individual video frames to apply ML-based background blur and\n * background replacement effects on the video stream.\n */\nexport default class VideoFxProcessor implements VideoFrameProcessor {\n  private static isSharedArrayBufferSupported: boolean = typeof SharedArrayBuffer !== 'undefined';\n  private fxLibScript: HTMLScriptElement;\n  private effectConfig: VideoFxConfig;\n  private streamParameters: VideoFxStreamParameters;\n  private engineWorker: Worker;\n  private canvasOpsManager: VideoFxCanvasOpsManager;\n  private renderer: VideoFxRenderer;\n\n  // Shared array buffer fields\n  private sharedImageBuffer: SharedArrayBuffer;\n  private sharedImageData: Uint8ClampedArray;\n\n  // Deferred promises for requests/awaits with engine worker\n  private buildEnginePromise: DeferredPromise<void>;\n  private destroyedAssetsPromise: DeferredPromise<void>;\n\n  //Fields to manage the segmentation process\n  private segmentationRateManager: VideoFxSegmentationRateManager;\n  private segmentationMask: ImageData;\n  private segmentationRequestPromise: DeferredPromise<ImageData>;\n\n  // Configure the buffer for where output frames will be placed\n  private outputCanvas: HTMLCanvasElement = document.createElement('canvas') as HTMLCanvasElement;\n  private canvasVideoFrameBuffer = new CanvasVideoFrameBuffer(this.outputCanvas);\n  private eventController?: EventController | undefined;\n  private videoFxSpec: VideoFxSpec = DEFAULT_VIDEO_FX_SPEC;\n\n  /**\n   * Initializes a new instance of [[VideoFxProcessor]] with a default NoOp [[VideoFxConfig]].\n   * @param logger\n   * @param processingBudgetPerFrame throttling constraint for processing\n   * @param eventController EventController object to manage events\n   */\n  constructor(\n    private logger: Logger,\n    processingBudgetPerFrame: number = RESOURCE_CONSTRAINTS.DEFAULT_PROCESSING_BUDGET_PER_FRAME,\n    eventController?: EventController\n  ) {\n    // Validate the inputted resource constraint\n    try {\n      this.validateProcessingBudgetPerFrame(processingBudgetPerFrame);\n    } catch (error) {\n      this.logger.error(error);\n      throw new Error(\n        `Cannot instantiate VideoFxProcessor due to invalid ` +\n          `processingBudgetPerFrame of ${processingBudgetPerFrame}`\n      );\n    }\n\n    if (eventController) {\n      this.eventController = eventController;\n    }\n\n    // Create a basic effectConfig (noOp)\n    this.effectConfig = {\n      backgroundBlur: {\n        isEnabled: false,\n        strength: 'low',\n      },\n      backgroundReplacement: {\n        isEnabled: false,\n        backgroundImageURL: null,\n        defaultColor: 'black',\n      },\n    };\n\n    // This promise object will be used to coordinate timing of sending/receiving frames from engine\n    this.segmentationRequestPromise = new DeferredPromise<ImageData>();\n    // Configure resource management for the segmentation frequency\n    this.segmentationRateManager = new VideoFxSegmentationRateManager(\n      this.logger,\n      processingBudgetPerFrame\n    );\n\n    // Configure default streamParameters\n    this.streamParameters = {\n      framerate: DEFAULT_STREAM_PARAMETERS.FRAMES_PER_SECOND,\n      width: DEFAULT_STREAM_PARAMETERS.WIDTH_IN_PIXEL,\n      height: DEFAULT_STREAM_PARAMETERS.HEIGHT_IN_PIXEL,\n      channels: DEFAULT_STREAM_PARAMETERS.CHANNEL_COUNT,\n    };\n\n    // Determine if shared array buffer can be used to transfer frame data from\n    // main thread to web worker thread\n    if (VideoFxProcessor.isSharedArrayBufferSupported) {\n      this.sharedImageBuffer = new SharedArrayBuffer(\n        SEGMENTATION_MODEL.WIDTH_IN_PIXELS *\n          SEGMENTATION_MODEL.HEIGHT_IN_PIXELS *\n          this.streamParameters.channels\n      );\n      this.sharedImageData = new Uint8ClampedArray(this.sharedImageBuffer);\n    }\n    this.logger.info(\n      `VideoFx supports Shared Array Buffer: ` + `${VideoFxProcessor.isSharedArrayBufferSupported}`\n    );\n\n    // Determine if filter operations are supported\n    this.canvasOpsManager = new VideoFxCanvasOpsManager(this.streamParameters, this.outputCanvas);\n\n    // Configure the final transformed frame location\n    this.outputCanvas.width = this.streamParameters.width;\n    this.outputCanvas.height = this.streamParameters.height;\n\n    // Set an empty mask at initialization\n    this.segmentationMask = new ImageData(\n      this.streamParameters.width,\n      this.streamParameters.height\n    );\n\n    this.logger.info(\n      `VideoFxProcessor instantiated with a processingBudgetPerFrame of ${processingBudgetPerFrame}`\n    );\n  }\n\n  /**\n   * Apply the [[VideoFxProcessor]]'s specialized effect onto the frame contained by\n   * the buffer parameter.\n   * @param buffers\n   * @returns buffers\n   */\n  async process(buffers: VideoFrameBuffer[]): Promise<VideoFrameBuffer[]> {\n    // Note: Required method through implementation of VideoFrameProcessor.\n    return buffers;\n  }\n\n  /**\n   * Process an input stream and apply the visual effects specified in this effectConfig.\n   * @param buffers the input stream\n   * @returns an output stream of VideoFrameBuffer\n   */\n  private async fxProcess(buffers: VideoFrameBuffer[]): Promise<VideoFrameBuffer[]> {\n    // Process our input image into raw input data\n    const inputCanvas = buffers[0].asCanvasElement() as HTMLCanvasElement;\n\n    // We must confirm that our incoming stream did not change it's parameters\n    if (this.didStreamParametersChange(inputCanvas)) {\n      await this.adjustProcessorForNewStreamParameters(inputCanvas);\n    }\n\n    // Decide to use the existing segmentation or perform a new segmentation\n    try {\n      await this.manageSegmentationMask(inputCanvas);\n    } catch (error) {\n      this.logger.error(error);\n      throw new Error(`Video stream could not be processed`);\n    }\n\n    // Render a final image using the input canvas and the segmentation mask\n    await this.renderer.render(inputCanvas, this.segmentationMask);\n\n    // Send canvas video frame buffer to rest of processor pipeline\n    buffers[0] = this.canvasVideoFrameBuffer;\n    return buffers;\n  }\n\n  /**\n   * Perform a process call that just returns the input stream\n   * @param buffers the input stream\n   * @returns an output stream of VideoFrameBuffer\n   */\n  private async noOpProcess(buffers: VideoFrameBuffer[]): Promise<VideoFrameBuffer[]> {\n    return buffers;\n  }\n\n  /**\n   * Check if the stream dimensions/parameters have changed.\n   * @param stream frame from current video stream about to be processed\n   * @returns boolean representing if the stream parameters changed\n   */\n  private didStreamParametersChange(stream: HTMLCanvasElement): boolean {\n    return (\n      stream.width !== this.streamParameters.width || stream.height !== this.streamParameters.height\n    );\n  }\n\n  /**\n   * Adjust the videoFxProcessor to handle new stream parameters.\n   * @param stream frame from current video stream about to be processed\n   */\n  private async adjustProcessorForNewStreamParameters(stream: HTMLCanvasElement): Promise<void> {\n    // Update the stored streamParameters\n    this.streamParameters.width = stream.width;\n    this.streamParameters.height = stream.height;\n\n    // Notify the canvas ops manager to reconfigure pipeline dimensions\n    await this.canvasOpsManager.configureForStreamParameters(this.streamParameters);\n\n    // Configure the renderer to work with new stream dimensions\n    await this.renderer.configure(\n      this.streamParameters.width,\n      this.streamParameters.height,\n      this.effectConfig\n    );\n  }\n\n  /**\n   * Clean up any excess memory that has been allocated by [[VideoFxProcessor]].\n   */\n  async destroy(): Promise<void> {\n    // Note: Required method through implementation of VideoFrameProcessor.\n    this.canvasVideoFrameBuffer.destroy();\n    if (this.fxLibScript && this.fxLibScript.parentNode) {\n      this.fxLibScript.parentNode.removeChild(this.fxLibScript);\n    }\n    if (this.engineWorker) {\n      // Post message to destroy all assets\n      this.destroyedAssetsPromise = new DeferredPromise<void>();\n      this.engineWorker.postMessage({\n        msg: WORKER_MSG.DESTROY_ASSETS_REQUEST,\n      });\n      // Wait until all the assets are destroyed\n      await this.destroyedAssetsPromise.getPromise();\n\n      // Close the engine worker\n      this.engineWorker.postMessage({\n        msg: WORKER_MSG.CLOSE_WORKER_REQUEST,\n      });\n    }\n    this.logger.info(`VideoFxProcessor destroyed.`);\n  }\n\n  /**\n   * Manage the segmentation mask that is used to generate a final frame. This function\n   * will calculate whether or not to re-generate a segmenation and also monitor\n   * how computationally expensive the rate of segmentation are.\n   * @param inputCanvas canvas to be used for segmentation\n   */\n  private async manageSegmentationMask(inputCanvas: HTMLCanvasElement): Promise<void> {\n    try {\n      this.segmentationRateManager.submitFrame();\n      if (this.segmentationRateManager.shouldApplySegmentation()) {\n        // Perform a segmentation inference on the downsampled current video frame\n        this.segmentationRateManager.startSegmentation();\n        const inferenceInputImageData = this.canvasOpsManager.getInferenceInputData(inputCanvas);\n        this.segmentationMask = await this.generateSegmentationMask(inferenceInputImageData);\n        this.segmentationRateManager.completeSegmentation();\n      }\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Can not properly manage the returned segmentation mask`);\n    }\n  }\n\n  /**\n   * Generate a segmentation mask from the input frame.\n   * @param inferenceImageData\n   * @returns image data representing segmenation mask\n   */\n  private async generateSegmentationMask(inferenceImageData: ImageData): Promise<ImageData> {\n    if (VideoFxProcessor.isSharedArrayBufferSupported) {\n      this.sharedImageData.set(inferenceImageData.data);\n      this.engineWorker.postMessage({\n        msg: WORKER_MSG.PERFORM_SEGMENTATION_SAB_REQUEST,\n        payload: this.sharedImageBuffer,\n      });\n    } else {\n      this.engineWorker.postMessage(\n        {\n          msg: WORKER_MSG.PERFORM_SEGMENTATION_REQUEST,\n          payload: inferenceImageData,\n        },\n        [inferenceImageData.data.buffer]\n      );\n    }\n\n    // Wait for input image to be returned from VideoFxEngine\n    try {\n      const segmentationMask = await this.segmentationRequestPromise.getPromise();\n      return segmentationMask;\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Segmentation mask could not be generated`);\n    }\n  }\n\n  /**\n   * Make a deep copy of the VideoFxConfig passed in. Needs to be updated if additional\n   * fields are added to VideoFxConfig.\n   * @param effectConfig\n   * @returns newEffectConfig\n   */\n  private cloneConfigFrom(effectConfig: VideoFxConfig): VideoFxConfig {\n    return {\n      backgroundBlur: {\n        isEnabled: effectConfig.backgroundBlur.isEnabled,\n        strength: effectConfig.backgroundBlur.strength,\n      },\n      backgroundReplacement: {\n        isEnabled: effectConfig.backgroundReplacement.isEnabled,\n        backgroundImageURL: effectConfig.backgroundReplacement.backgroundImageURL,\n        defaultColor: effectConfig.backgroundReplacement.defaultColor,\n      },\n    };\n  }\n\n  setVideoFxSpec(videoFxSpec: VideoFxSpec): void {\n    if (videoFxSpec.paths) {\n      this.videoFxSpec.paths = videoFxSpec.paths;\n    }\n  }\n  /**\n   * Update the [[VideoFxProcessor]] to apply a new set of effects by updating the instance property\n   * [[VideoFxConfig]]. If the effectConfig parameter fails validation, an error is thrown and there is\n   * no update.\n   * @Param effectConfig updated [[VideoFxConfig]] with new video effects\n   */\n  async setEffectConfig(effectConfig: VideoFxConfig): Promise<void> {\n    if (this.sameVideoFxConfig(effectConfig, this.effectConfig)) {\n      return;\n    }\n\n    const newEffectConfig = this.cloneConfigFrom(effectConfig);\n\n    // Validate the effect config\n    try {\n      await this.validateEffectConfig(newEffectConfig);\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Provided effect config is invalid, not updating VideoFxProcessor`);\n    }\n\n    // Configure background replacement image/canvas\n    if (newEffectConfig.backgroundReplacement.isEnabled) {\n      await this.canvasOpsManager.loadReplacementBackground(newEffectConfig);\n      await this.renderer.setBackgroundReplacementCanvas(\n        this.canvasOpsManager.getBackgroundReplacementCanvas()\n      );\n    }\n\n    // Configure the renderer to implement the desired effect configuration\n    await this.renderer.configure(\n      this.streamParameters.width,\n      this.streamParameters.height,\n      newEffectConfig\n    );\n\n    // Can now officially set the effect config since the rest of the processor is\n    // configured for the new effects\n    this.effectConfig = newEffectConfig;\n\n    // If no effects are enabled, run no op process, otherwise run the effect based processing\n    if (\n      !this.effectConfig.backgroundBlur.isEnabled &&\n      !this.effectConfig.backgroundReplacement.isEnabled\n    ) {\n      this.process = this.noOpProcess;\n    } else {\n      this.process = this.fxProcess;\n    }\n    this.logger.info(\n      `VideoFxProcessor effect configuration updated to: ${JSON.stringify(this.effectConfig)}`\n    );\n\n    if (this.eventController) {\n      this.publishVideoFxConfigEvent();\n    }\n  }\n\n  /**\n   * Confirm that the config consists of valid values.\n   * @param config that will be validated\n   */\n  private async validateEffectConfig(config: VideoFxConfig): Promise<void> {\n    // We confirm that both blur and replacement are not enabled due to builder error\n    if (config.backgroundBlur.isEnabled && config.backgroundReplacement.isEnabled) {\n      throw new Error(\n        `Invalid VideoFx configuration: Background Blur and Background Replacement ` +\n          `can not both be enabled`\n      );\n    } else if (config.backgroundReplacement.isEnabled) {\n      await this.validateReplacementConfig(config);\n    }\n    // backgroundBlur does not need to be validated, as valid blurStrength value\n    // is checked at compile time.\n  }\n\n  /**\n   * Confirm that the config consists of valid values for background replacement.\n   * @param config that will be validated for background replacement\n   */\n  private async validateReplacementConfig(config: VideoFxConfig): Promise<void> {\n    if (\n      config.backgroundReplacement.backgroundImageURL &&\n      config.backgroundReplacement.defaultColor\n    ) {\n      throw new Error(\n        `Invalid VideoFx configuration: Background Replacement can not have both an ` +\n          `image URL and default color`\n      );\n    }\n    if (\n      !config.backgroundReplacement.backgroundImageURL &&\n      !config.backgroundReplacement.defaultColor\n    ) {\n      throw new Error(\n        `Invalid VideoFx configuration: Background Replacement image URL and default ` +\n          `can not both be null/undefined`\n      );\n    }\n\n    // Confirm that the image properly loads\n    try {\n      if (config.backgroundReplacement.backgroundImageURL) {\n        await this.canvasOpsManager.loadImage(config.backgroundReplacement.backgroundImageURL);\n      }\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Invalid VideoFx configuration: backgroundImageURL failed to load`);\n    }\n\n    const defaultColor = config.backgroundReplacement.defaultColor;\n    // Confirm that defaultColor is a valid color for fillStyle. We support black by default.\n    if (\n      defaultColor &&\n      defaultColor !== 'black' &&\n      defaultColor !== '#000000' &&\n      defaultColor !== '#000'\n    ) {\n      // First validate hexadecimal color code\n      if (defaultColor.includes('#')) {\n        const hexRegex = new RegExp(/^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/);\n        if (!hexRegex.test(defaultColor)) {\n          throw new Error(\n            `Invalid hexadecimal color code for default replacement ` +\n              `background: ${defaultColor}`\n          );\n        }\n      }\n      const testColorCanvas = document.createElement('canvas');\n      const testColorCtx = testColorCanvas.getContext('2d');\n      // fillStyle is #000000 black by default\n      const prevFillStyle = testColorCtx.fillStyle;\n      testColorCtx.fillStyle = defaultColor;\n      // fillStyle will not change after assignment if invalid value is used\n      /* istanbul ignore next */\n      if (testColorCtx.fillStyle === prevFillStyle) {\n        throw new Error(`Invalid color for default replacement background: ${defaultColor}`);\n      }\n    }\n  }\n\n  /**\n   * Confirm that the processingBudgePerFrame constraint holds valid values.\n   * @param constraint to be validated\n   */\n  private validateProcessingBudgetPerFrame(processingBudgetPerFrame: number): void {\n    if (\n      processingBudgetPerFrame < RESOURCE_CONSTRAINTS.MIN_PROCESSING_BUDGET ||\n      processingBudgetPerFrame > RESOURCE_CONSTRAINTS.MAX_PROCESSING_BUDGET\n    ) {\n      throw new Error(\n        `Invalid resource constraint: cycle percentage must be within ` +\n          `range of ${RESOURCE_CONSTRAINTS.MIN_PROCESSING_BUDGET} and ` +\n          `${RESOURCE_CONSTRAINTS.MAX_PROCESSING_BUDGET}`\n      );\n    }\n  }\n\n  /**\n   * Loads all of the assets that are associated with the stored effectConfig.\n   */\n  private async loadAssets(): Promise<void> {\n    this.logger.info(`Loading required assets for the VideoFxProcessor`);\n    try {\n      const videoFxAssetParams = this.getVideoFxAssetParams();\n\n      await this.loadEngineWorker(videoFxAssetParams);\n      await this.buildEngine(videoFxAssetParams);\n      await this.loadFxLib(videoFxAssetParams);\n      // @ts-ignore\n      this.renderer = constructRenderer(\n        SEGMENTATION_MODEL.WIDTH_IN_PIXELS,\n        SEGMENTATION_MODEL.HEIGHT_IN_PIXELS,\n        this.effectConfig,\n        this.outputCanvas\n      );\n    } catch (error) {\n      // NOTE: when we update to es2022, throw errors that are chained together\n      this.logger.error(error.toString());\n      throw new Error(`Failed to load necessary assets for the VideoFxProcessor`);\n    }\n    this.logger.info(`Finished loading of essential VideoFxProcessor assets.`);\n  }\n\n  /**\n   * Determines the current set of specifications that define the current SDK version.\n   * @returns an [[VideoFxAssetParams]] object defining the parameters of the\n   * current SDK\n   */\n  private getVideoFxAssetParams(): VideoFxAssetParams {\n    const defaultAssetSpec = getDefaultAssetSpec();\n    const videoFxAssetParams = {\n      assetGroup: defaultAssetSpec.assetGroup,\n      revisionID: defaultAssetSpec.revisionID,\n      sdk: encodeURIComponent(Versioning.sdkVersion),\n      ua: encodeURIComponent(Versioning.sdkUserAgentLowResolution),\n    };\n    return videoFxAssetParams;\n  }\n\n  /**\n   * Generate a final path to an asset belonging to current version of SDK.\n   * @param basePath Base of the path that will be used to generate a final path\n   * @param videoFxAssetParams Parameters of the current SDK version\n   * @returns A final path specific to an asset belonging to current SDK\n   * version\n   */\n  private getPathFromVideoFxAssetParams(\n    basePath: string,\n    videoFxAssetParams: VideoFxAssetParams\n  ): string {\n    const path = new URL(basePath);\n    for (const [key, value] of Object.entries(videoFxAssetParams)) {\n      if (value !== undefined) {\n        // Encode the key and value into uri format\n        const uriEncodedKey = encodeURIComponent(key);\n        const uriEncodedValue = encodeURIComponent(value);\n        // Set encoded key/value as query params\n        path.searchParams.set(uriEncodedKey, uriEncodedValue);\n      }\n    }\n\n    return path.toString();\n  }\n\n  /**\n   * Fetch and then load the engine worker into a web-worker.\n   */\n  private async loadEngineWorker(videoFxAssetParams: VideoFxAssetParams): Promise<void> {\n    // The engine worker will always be a required asset for the VideoFxProcessor\n    try {\n      // Determine engine worker path from versioning of the SDK worker\n      const engineWorkerPath = this.getPathFromVideoFxAssetParams(\n        this.videoFxSpec.paths.cdnBasePath + this.videoFxSpec.paths.workerPath,\n        videoFxAssetParams\n      );\n\n      // Load the worker that will communicate with the VideoFxEngine\n      this.engineWorker = await loadWorker(engineWorkerPath, 'VideoFxEngineWorker', {}, null);\n      this.logger.info(`Successfully loaded the VideoFxProcessor's engine worker`);\n      // Configure a handler to deal with messages received form the engine worker\n      this.engineWorker.addEventListener('message', event => this.engineWorkerReceiver(event));\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Failed to load the VideoFxProcessor's engine worker`);\n    }\n  }\n\n  /**\n   * Build the videoFxEngine.\n   * @param videoFxAssetParams [[VideoFxAssetParams]] defining current version of SDK\n   */\n  private async buildEngine(videoFxAssetParams: VideoFxAssetParams): Promise<void> {\n    // Instantiate the deferred promise so we can wait for the worker to\n    // return a completion message\n    this.buildEnginePromise = new DeferredPromise<void>();\n\n    // Send a message via the engine worker to instantiate\n    // the video fx engine\n    this.engineWorker.postMessage({\n      msg: WORKER_MSG.BUILD_ENGINE_REQUEST,\n      payload: {\n        cdnBasePath: this.videoFxSpec.paths.cdnBasePath,\n        sdkVersioningParams: videoFxAssetParams,\n      },\n    });\n\n    // Wait until the engine finishes building\n    try {\n      await this.buildEnginePromise.getPromise();\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Failed to instantiate the VideoFxEngine`);\n    }\n  }\n\n  /**\n   * Loads the Video Fx library to drive video post-processing, given the versioning\n   * of the SDK worker from the VideoFxAssetParams interface passed as a parameter.\n   * @param videoFxAssetParams\n   */\n  private async loadFxLib(videoFxAssetParams: VideoFxAssetParams): Promise<void> {\n    // Determine engine worker path from versioning of the SDK worker\n    const fxLibPath = this.getPathFromVideoFxAssetParams(\n      this.videoFxSpec.paths.cdnBasePath + this.videoFxSpec.paths.fxLibPath,\n      videoFxAssetParams\n    );\n\n    const WORKER_FETCH_OPTIONS: RequestInit = {\n      method: 'GET',\n      mode: 'cors',\n      credentials: 'omit',\n      redirect: 'follow',\n      referrerPolicy: 'no-referrer',\n    };\n\n    try {\n      const res = await fetchWithBehavior(fxLibPath, WORKER_FETCH_OPTIONS, {});\n      if (!res.ok) {\n        throw new Error('Fetch failed.');\n      }\n      const blobURL = window.URL.createObjectURL(await res.blob());\n      await new Promise((resolve, reject) => {\n        this.fxLibScript = document.createElement('script');\n        this.fxLibScript.setAttribute('src', blobURL);\n        this.fxLibScript.setAttribute('type', 'module');\n        this.fxLibScript.setAttribute('async', 'false');\n        this.fxLibScript.addEventListener('load', resolve);\n        this.fxLibScript.addEventListener('error', reject);\n        document.body.appendChild(this.fxLibScript);\n      });\n    } catch (error) {\n      this.logger.error(error.toString());\n      throw new Error(`Failed to load the fxlib`);\n    }\n  }\n\n  /**\n   * Getter for the current [[VideoFxConfig]] maintained as an instance property of\n   * [[VideoFxProcessor]].\n   * @returns currentEffectConfig\n   */\n  getEffectConfig(): VideoFxConfig {\n    return this.cloneConfigFrom(this.effectConfig);\n  }\n\n  /**\n   * Receives messages from the engine worker and then delegates\n   * the proper response to a different function.\n   * @param event notification to be received from the engine worker\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  private engineWorkerReceiver(event: MessageEvent<any>): void {\n    const msg = event.data;\n    switch (msg.msg) {\n      case WORKER_MSG.BUILD_ENGINE_RESPONSE:\n        this.settleEngineBuildPromise(msg.payload);\n        break;\n      case WORKER_MSG.PERFORM_SEGMENTATION_RESPONSE:\n        this.settleSegmentationPromise(msg.payload.output);\n        break;\n      case WORKER_MSG.PERFORM_SEGMENTATION_SAB_RESPONSE:\n        this.settleSegmentationPromiseSAB();\n        break;\n      case WORKER_MSG.DESTROY_ASSETS_RESPONSE:\n        this.destroyedAssetsPromise.resolvePromise();\n        break;\n      default:\n        this.logger.info(`VideoFx worker received unknown event msg: ${JSON.stringify(msg)}`);\n        break;\n    }\n  }\n\n  /**\n   * Handle the message returned from the VideoFX Engine worker to\n   * settle (resolve/reject) the promise associated with initializing the engine.\n   * @param buildStatus status of the final result of building the engine\n   */\n  private settleEngineBuildPromise(buildStatus: number): void {\n    // Resolve or reject the engineInstantiatedPromise depending on success\n    // of instatiation\n    if (buildStatus !== SEGMENTATION_MODEL.LOAD_SUCCESS) {\n      this.buildEnginePromise.rejectPromise(new Error(`Failed to build VideoFxProcessor's engine`));\n    } else {\n      this.logger.info(`Successfully built the VideoFxEngine`);\n      this.buildEnginePromise.resolvePromise();\n    }\n  }\n\n  /**\n   * Handle the received segmentation mask and then resolve/reject the promise to notify\n   * the main processing function to prepare for the next frame (using ImageData transfer).\n   * @param segmentationMask\n   */\n  private settleSegmentationPromise(segmentationMask: ImageData): void {\n    // Resolve or reject the frameRequestPromise depending on the success of transforming\n    // the input image\n    if (segmentationMask) {\n      // Resolve segmentation promise with mask data\n      this.segmentationRequestPromise.resolveAndReplacePromise(segmentationMask);\n    } else {\n      this.segmentationRequestPromise.rejectAndReplacePromise(\n        new Error(`Failed to perform a segmentation on the input image`)\n      );\n    }\n  }\n\n  /**\n   * Handle the received segmentation mask and then resolve/reject the promise to notify\n   * the main processing function to prepare for the next frame (using shared array buffer).\n   */\n  private settleSegmentationPromiseSAB(): void {\n    try {\n      // Resolve segmentation promise with mask data\n      const transformedImageData = new ImageData(\n        new Uint8ClampedArray(this.sharedImageData),\n        SEGMENTATION_MODEL.WIDTH_IN_PIXELS,\n        SEGMENTATION_MODEL.HEIGHT_IN_PIXELS\n      );\n      this.segmentationRequestPromise.resolveAndReplacePromise(transformedImageData);\n    } catch {\n      this.segmentationRequestPromise.rejectAndReplacePromise(\n        new Error(\n          `Failed to perform a segmentation with a shared ` + `array buffer on the input image`\n        )\n      );\n    }\n  }\n\n  /**\n   * Function that will convert the VideoFxProcessor into a NoOp version of itself.\n   * Will only return input video stream and not use worker, engine, or segmentation\n   * model.\n   */\n  private setToNoOpProcess(): void {\n    this.process = this.noOpProcess;\n  }\n\n  /**\n   * Detect client environment to determine if the [[VideoFxProcessor]] is supported.\n   * @param logger to record/report events of checking processor support\n   * @param attemptAssetLoad will also fetch and build all relevant components of the\n   * processor to ensure end to end feature is supported\n   * @returns a boolean promise that will resolve to true if supported and false if not\n   */\n  static async isSupported(\n    logger: Logger = new NoOpLogger(),\n    attemptAssetLoad: boolean = true\n  ): Promise<boolean> {\n    // allCheckedPassed represents the state of support and we assume it is true until checkEnv tells us otherwise\n    let allCheckedPassed: boolean = true;\n    // checkEnv evaluates a boolean condition, badPromiseCondition, that when true would cause isSupported to fail.\n    // We also log a corresponding error message for each support check so a builder can see what is still needed\n    // in their environment.\n    const checkEnv = (badPromiseCondition: boolean, message: string): void => {\n      if (badPromiseCondition) {\n        logger.info(message);\n        allCheckedPassed = false;\n      }\n    };\n\n    // Get context for operating environment\n    // could not figure out how to remove globalThis to test failure case\n    /* istanbul ignore next */\n    checkEnv(typeof globalThis === 'undefined', 'Browser does not have globalThis.');\n\n    // Check workers are supported\n    checkEnv(!supportsWorker(globalThis, logger), 'Browser does not support web workers.');\n\n    // Check wasm is supported\n    checkEnv(!supportsWASM(globalThis, logger), 'Browser does not support wasm.');\n\n    // Check webgl2 is supported\n    checkEnv(\n      !document.createElement('canvas').getContext('webgl2'),\n      'Browser does not support webgl.'\n    );\n\n    // Check browser support\n    const browserBehavior = new DefaultBrowserBehavior();\n    checkEnv(\n      !browserBehavior.isVideoFxSupportedBrowser(),\n      'Browser is unsupported for VideoFxProcessor'\n    );\n\n    // checkProcessor first checks if we can load all required assets and then tests VideoFxProcessor.\n    const checkProcessor = async (): Promise<boolean> => {\n      if (attemptAssetLoad) {\n        try {\n          const testFxProcessor = new VideoFxProcessor(logger);\n          await testFxProcessor.loadAssets();\n          await testFxProcessor.destroy(); // destroy assets we just temp loaded\n        } catch {\n          logger.info('Browser environment is unable to access the required external assets.');\n          return Promise.resolve(false);\n        }\n      }\n      return Promise.resolve(true);\n    };\n\n    return Promise.resolve(allCheckedPassed ? await checkProcessor() : false);\n  }\n\n  /**\n   * Create a [[VideoFxProcessor]] that has loaded its necessary components, ready to instantly\n   * process a video stream with the effects specified in the passed [[VideoFxConfig]].\n   *\n   * ** NOTICE **\n   *\n   * Amazon Chime background blur 2.0 and background replacement 2.0\n   * Copyright 2023 Amazon.com, Inc. or its affiliates. All Rights Reserved.\n   *\n   * By installing or using this package, you agree to the AWS Customer Agreement, AWS Service Terms, and AWS Privacy Notice.\n   * If you already have an AWS Customer Agreement, you agree that the terms of that agreement govern your download and use of this package.\n   * This package is provided as AWS Content and subject to the AWS Customer agreement and any other agreement with AWS governing your use of\n   * AWS services.\n   */\n  static async create(\n    logger: Logger,\n    effectConfig: VideoFxConfig,\n    processingBudgetPerFrame: number = RESOURCE_CONSTRAINTS.DEFAULT_PROCESSING_BUDGET_PER_FRAME,\n    spec?: VideoFxSpec\n  ): Promise<VideoFxProcessor> {\n    // Create the videoFxProcessor\n    const videoFxProcessor: VideoFxProcessor = new VideoFxProcessor(\n      logger,\n      processingBudgetPerFrame\n    );\n    if (spec) {\n      videoFxProcessor.setVideoFxSpec(spec);\n    }\n    // Load the required assets and set desired effect config\n    try {\n      await videoFxProcessor.loadAssets();\n      await videoFxProcessor.setEffectConfig(effectConfig);\n      return videoFxProcessor;\n    } catch (error) {\n      logger.error(error.toString());\n      // If we fail loading an essential asset from above, we overwrite our\n      // processor to process with no operations or effects\n      videoFxProcessor.setToNoOpProcess();\n      throw new Error(`VideoFxProcessor built with support for only NoOp processing`);\n    }\n  }\n\n  /** @internal */\n  setEventController(eventController: EventController): void {\n    /*\n    if this is a first time we set the eventController, need to publish the current VideoFxConfig.\n    Otherwise, just set the eventController.\n    */\n    if (this.eventController) {\n      this.eventController = eventController;\n    } else {\n      this.eventController = eventController;\n      this.publishVideoFxConfigEvent();\n    }\n  }\n\n  private publishVideoFxConfigEvent(): void {\n    const mediaFXEventAttibutes: VideoFXEventAttributes = {\n      backgroundBlurEnabled: this.effectConfig.backgroundBlur.isEnabled.toString(),\n      backgroundBlurStrength: this.effectConfig.backgroundBlur.strength,\n      backgroundReplacementEnabled: this.effectConfig.backgroundReplacement.isEnabled.toString(),\n      backgroundFilterVersion: 2,\n    };\n    this.eventController.publishEvent('backgroundFilterConfigSelected', mediaFXEventAttibutes);\n  }\n\n  private sameVideoFxConfig(firstConfig: VideoFxConfig, secondConfig: VideoFxConfig): boolean {\n    return (\n      firstConfig.backgroundBlur.isEnabled === secondConfig.backgroundBlur.isEnabled &&\n      firstConfig.backgroundBlur.strength === secondConfig.backgroundBlur.strength &&\n      firstConfig.backgroundReplacement.backgroundImageURL ===\n        secondConfig.backgroundReplacement.backgroundImageURL &&\n      firstConfig.backgroundReplacement.defaultColor ===\n        secondConfig.backgroundReplacement.defaultColor &&\n      firstConfig.backgroundReplacement.isEnabled === secondConfig.backgroundReplacement.isEnabled\n    );\n  }\n}\n"]}
{"version":3,"file":"VideoFxSegmentationRateManager.js","sourceRoot":"","sources":["../../src/videofx/VideoFxSegmentationRateManager.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC;;;AAGtC,yDAA0D;AAE1D;;;;GAIG;AACH,MAAa,8BAA8B;IAczC,YAAY,MAAc,EAAE,2BAAmC;QAC7D,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,mEAAmE;QACnE,yBAAyB;QACzB,IAAI,CAAC,iCAAiC,GAAG,2BAA2B,GAAG,GAAG,CAAC;QAC3E,8CAA8C;QAC9C,IAAI,CAAC,4BAA4B,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,2CAA2C,GAAG,CAAC,CAAC;QACrD,IAAI,CAAC,uBAAuB,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;QACjD,IAAI,CAAC,qBAAqB,GAAG,uCAAoB,CAAC,4CAA4C,CAAC;IACjG,CAAC;IAED;;OAEG;IACH,WAAW;QACT,IAAI,CAAC,4BAA4B,EAAE,CAAC;IACtC,CAAC;IAED;;;;;;OAMG;IACH,uBAAuB;QACrB,OAAO,IAAI,CAAC,4BAA4B,GAAG,IAAI,CAAC,qBAAqB,KAAK,CAAC,CAAC;IAC9E,CAAC;IAED;;OAEG;IACH,iBAAiB;QACf,IAAI,CAAC,0BAA0B,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IACtD,CAAC;IAED;;;;OAIG;IACH,oBAAoB;QAClB,IAAI,CAAC,2CAA2C;YAC9C,WAAW,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,0BAA0B,CAAC;QACtD,qEAAqE;QACrE,mCAAmC;QACnC,IACE,IAAI,CAAC,4BAA4B;YACjC,uCAAoB,CAAC,wCAAwC,EAC7D;YACA,IAAI,CAAC,2BAA2B,CAC9B,IAAI,CAAC,2CAA2C;gBAC9C,CAAC,WAAW,CAAC,GAAG,EAAE,GAAG,IAAI,CAAC,uBAAuB,CAAC,CACrD,CAAC;SACH;IACH,CAAC;IAED;;;;OAIG;IACK,2BAA2B,CAAC,4BAAoC;QACtE,4DAA4D;QAC5D,IAAI,4BAA4B,GAAG,IAAI,CAAC,iCAAiC,EAAE;YACzE,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,oEAAoE;gBAClE,qDAAqD;gBACrD,GAAG,IAAI,CAAC,qBAAqB,SAAS,CACzC,CAAC;YACF,0DAA0D;SAC3D;aAAM,IACL,IAAI,CAAC,qBAAqB,GAAG,CAAC;YAC9B,4BAA4B,GAAG,IAAI,CAAC,iCAAiC,EACrE;YACA,IAAI,CAAC,qBAAqB,EAAE,CAAC;YAC7B,IAAI,CAAC,MAAM,CAAC,IAAI,CACd,oEAAoE;gBAClE,qDAAqD;gBACrD,GAAG,IAAI,CAAC,qBAAqB,SAAS,CACzC,CAAC;SACH;QACD,sCAAsC;QACtC,IAAI,CAAC,2CAA2C,GAAG,CAAC,CAAC;QACrD,IAAI,CAAC,4BAA4B,GAAG,CAAC,CAAC;QACtC,IAAI,CAAC,uBAAuB,GAAG,WAAW,CAAC,GAAG,EAAE,CAAC;IACnD,CAAC;CACF;AAvGD,wEAuGC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport Logger from '../logger/Logger';\nimport { RESOURCE_CONSTRAINTS } from './VideoFxConstants';\n\n/**\n * [[VideoFxSegmentationRateManager]] Mechanism that can be used to maximize\n * frequency of the segmentation operations while maintaining a target amount\n * of resource utilization.\n */\nexport class VideoFxSegmentationRateManager {\n  private logger: Logger;\n  // Target segmentation percentage is defined as the amount of time spent performing\n  // segmentations divided by the total duration of time that has passed\n  private targetSegmentationCyclePercentage: number;\n  private frameCountOverSamplingPeriod: number;\n  private framesPerSegmentation: number;\n  // Measure the start time of a single segmentation\n  private frameSegmentationStartTime: number;\n  // The running sum of single frame segmentation durations over a sampling period\n  private totalSegmentationDurationOverSamplingPeriod: number;\n  // The time that the segmentation period started\n  private samplingPeriodStartTime: number;\n\n  constructor(logger: Logger, targetSegmentationCycleTime: number) {\n    this.logger = logger;\n    // Max amount of compute we want to offer to action (converted from\n    // percentage to decimal)\n    this.targetSegmentationCyclePercentage = targetSegmentationCycleTime / 100;\n    // Variables for recording timing within cycle\n    this.frameCountOverSamplingPeriod = 0;\n    this.totalSegmentationDurationOverSamplingPeriod = 0;\n    this.samplingPeriodStartTime = performance.now();\n    this.framesPerSegmentation = RESOURCE_CONSTRAINTS.SEGMENTATION_DEFAULT_FRAMES_PER_SEGMENTATION;\n  }\n\n  /**\n   * Invoked on every frame to increment the running count of frames being processed\n   */\n  submitFrame(): void {\n    this.frameCountOverSamplingPeriod++;\n  }\n\n  /**\n   * Invoked on every frame to coordinate when the segmentation should be\n   * executed so that we are maintaing a segmentation rate of once per every\n   * framesPerSegmentation frames.\n   * @returns boolean for whether or not we want to perform an action on the current\n   * frame\n   */\n  shouldApplySegmentation(): boolean {\n    return this.frameCountOverSamplingPeriod % this.framesPerSegmentation === 0;\n  }\n\n  /**\n   * Starts the timing of the current action\n   */\n  startSegmentation(): void {\n    this.frameSegmentationStartTime = performance.now();\n  }\n\n  /**\n   * Invoked after the action to notify the compute manager. Afterwards the\n   * manager will make adjustments to action rates to maintain a value below compute\n   * ceiling\n   */\n  completeSegmentation(): void {\n    this.totalSegmentationDurationOverSamplingPeriod +=\n      performance.now() - this.frameSegmentationStartTime;\n    // Check if the sampling period has ended. If so, check if frames per\n    // segmentation needs to be updated\n    if (\n      this.frameCountOverSamplingPeriod >=\n      RESOURCE_CONSTRAINTS.SEGMENTATION_SAMPLING_PERIOD_FRAME_COUNT\n    ) {\n      this.adjustFramesPerSegmentation(\n        this.totalSegmentationDurationOverSamplingPeriod /\n          (performance.now() - this.samplingPeriodStartTime)\n      );\n    }\n  }\n\n  /**\n   * Increase or decrease the frames per segmentation so that we remain as performant as possible,\n   * but also below the targetSegmentationCycleTime\n   * @param currentSegmentationCycleTime Current ratio of frame processing allocated to a specific action\n   */\n  private adjustFramesPerSegmentation(currentSegmentationCycleTime: number): void {\n    // Compute is too high -> increase action period (slow down)\n    if (currentSegmentationCycleTime > this.targetSegmentationCyclePercentage) {\n      this.framesPerSegmentation++;\n      this.logger.info(\n        `Segmentation cycle percentage above the configured maximal value. ` +\n          `Decreasing segmentation rate to 1 segmentation per ` +\n          `${this.framesPerSegmentation} frames`\n      );\n      // Compute is too low -> decrease action period (speed up)\n    } else if (\n      this.framesPerSegmentation > 1 &&\n      currentSegmentationCycleTime < this.targetSegmentationCyclePercentage\n    ) {\n      this.framesPerSegmentation--;\n      this.logger.info(\n        `Segmentation cycle percentage below the configured maximal value. ` +\n          `Increasing segmentation rate to 1 segmentation per ` +\n          `${this.framesPerSegmentation} frames`\n      );\n    }\n    // Reset for next compute sample/cycle\n    this.totalSegmentationDurationOverSamplingPeriod = 0;\n    this.frameCountOverSamplingPeriod = 0;\n    this.samplingPeriodStartTime = performance.now();\n  }\n}\n"]}
"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.VideoFxCanvasOpsManager = void 0;
const VideoFxConstants_1 = require("./VideoFxConstants");
/**
 * [[VideoFxCanvasOpsManager]] Mechanism drives the canvas based operations
 * for the VideoFxProcessor. This includes input stream resizing to segmentation model
 * dimensions and managing the canvas loading for background replacement.
 */
class VideoFxCanvasOpsManager {
    constructor(streamParameters, outputCanvas) {
        this.streamParameters = streamParameters;
        this.outputCanvas = outputCanvas;
        this.configureCanvasPipeline();
    }
    /**
     * Generate the raw image data in a format that is directly importable into
     * the segmentation model
     * @param inputCanvas
     * @returns ImageData
     */
    getInferenceInputData(inputCanvas) {
        // Resize our full resolution frame into a new canvas scaled to the
        // size of our segmentation model
        this.inferenceCtx.save();
        this.inferenceCtx.scale(this.horizontalResizeScalar, this.verticalResizeScalar);
        this.inferenceCtx.drawImage(inputCanvas, 0, 0);
        this.inferenceCtx.restore();
        // Now we can directly take image data that is the desired size of
        // of our segmentation model linput
        const inferenceInputData = this.inferenceCtx.getImageData(0, 0, VideoFxConstants_1.SEGMENTATION_MODEL.WIDTH_IN_PIXELS, VideoFxConstants_1.SEGMENTATION_MODEL.HEIGHT_IN_PIXELS);
        return inferenceInputData;
    }
    /**
     * Reconfigure the canvas operations/pipeline to fit the dimensions of the new
     * video stream, and resize background replacement canvas.
     * @param streamParameters an VideoFxStreamParameters object specifying stream dimensions
     */
    configureForStreamParameters(streamParameters) {
        return __awaiter(this, void 0, void 0, function* () {
            this.streamParameters = streamParameters;
            this.outputCanvas.width = this.streamParameters.width;
            this.outputCanvas.height = this.streamParameters.height;
            // Resize background replacement canvas -- if it exists
            if (this.backgroundReplacementCanvas) {
                const resizedCanvas = document.createElement('canvas');
                resizedCanvas.width = this.streamParameters.width;
                resizedCanvas.height = this.streamParameters.height;
                resizedCanvas
                    .getContext('2d')
                    .drawImage(this.backgroundReplacementCanvas, 0, 0, this.streamParameters.width, this.streamParameters.height);
                this.backgroundReplacementCanvas = resizedCanvas;
            }
            this.configureCanvasPipeline();
        });
    }
    /**
     * Configure the inference canvas so that write operations to the canvas
     * result in an image resizing.
     */
    configureCanvasPipeline() {
        // Create new inference canvas and context
        this.inferenceCanvas = document.createElement('canvas');
        this.inferenceCtx = this.inferenceCanvas.getContext('2d', {
            willReadFrequently: true,
        });
        // Configure the resize operation, which will be utilized by calling scale
        // and then drawing any sized input to the canvas
        this.inferenceCanvas.width = VideoFxConstants_1.SEGMENTATION_MODEL.WIDTH_IN_PIXELS;
        this.inferenceCanvas.height = VideoFxConstants_1.SEGMENTATION_MODEL.HEIGHT_IN_PIXELS;
        this.horizontalResizeScalar = VideoFxConstants_1.SEGMENTATION_MODEL.WIDTH_IN_PIXELS / this.streamParameters.width;
        this.verticalResizeScalar = VideoFxConstants_1.SEGMENTATION_MODEL.HEIGHT_IN_PIXELS / this.streamParameters.height;
    }
    /**
     * Return the background replacement canvas
     * @returns HTMLCanvasElement
     */
    getBackgroundReplacementCanvas() {
        return this.backgroundReplacementCanvas;
    }
    /**
     * Attempt to load custom replacement background image from URL, or the default background color.
     * The backgroundReplacementCanvas is then set from the loaded image.
     * @param effectConfig
     */
    loadReplacementBackground(effectConfig) {
        return __awaiter(this, void 0, void 0, function* () {
            const imageURL = effectConfig.backgroundReplacement.backgroundImageURL;
            const defaultColor = effectConfig.backgroundReplacement.defaultColor;
            if (imageURL) {
                try {
                    const backgroundImage = yield this.loadImage(imageURL);
                    this.backgroundReplacementImage = backgroundImage;
                    this.resizeAndSetReplacementImage(this.backgroundReplacementImage);
                }
                catch (error) /* istanbul ignore next */ {
                    // The following can only happen due to an intermittent network issue.
                    this.logger.error(error);
                    throw new Error('Failed to set the replacement image.');
                }
            }
            else {
                this.resizeAndSetReplacementColor(defaultColor);
            }
        });
    }
    /**
     * Draw loaded image on a canvas sized to the stream parameters, which is then set to the
     * backgroundReplacementCanvas member variable.
     * @param backgroundImage
     */
    resizeAndSetReplacementImage(backgroundImage) {
        const resizedCanvas = document.createElement('canvas');
        const resizedCtx = resizedCanvas.getContext('2d');
        resizedCanvas.width = this.streamParameters.width;
        resizedCanvas.height = this.streamParameters.height;
        resizedCtx.drawImage(backgroundImage, 0, 0, this.streamParameters.width, this.streamParameters.height);
        this.backgroundReplacementCanvas = resizedCanvas;
    }
    /**
     * Fill default color on a canvas sized to the stream parameters, which is then set to the
     * backgroundReplacementCanvas member variable.
     * @param defaultColor
     */
    resizeAndSetReplacementColor(defaultColor) {
        const resizedCanvas = document.createElement('canvas');
        const resizedCtx = resizedCanvas.getContext('2d');
        resizedCanvas.width = this.streamParameters.width;
        resizedCanvas.height = this.streamParameters.height;
        resizedCtx.fillStyle = defaultColor;
        resizedCtx.fillRect(0, 0, this.streamParameters.width, this.streamParameters.height);
        this.backgroundReplacementCanvas = resizedCanvas;
    }
    /**
     * Attempt to load background image from URL.
     * @param backgroundImageURL
     * @returns Promise<HTMLCanvasElement>
     */
    loadImage(backgroundImageURL) {
        return __awaiter(this, void 0, void 0, function* () {
            // Attempt to fetch the image
            const image = yield fetch(backgroundImageURL).catch(error => {
                this.logger.error(error.toString());
                // Error returned in unit tests from mock fetch is non-compatible
                /* istanbul ignore next */
                throw new Error('Failed to fetch image.');
            });
            // Convert successful fetch into an HTMLImageElement
            const imageBlob = yield image.blob();
            const img = new Image();
            img.src = URL.createObjectURL(imageBlob);
            return new Promise((resolve, reject) => {
                img.onload = () => {
                    resolve(img);
                };
                img.onerror = error => {
                    reject(error);
                };
            });
        });
    }
}
exports.VideoFxCanvasOpsManager = VideoFxCanvasOpsManager;
//# sourceMappingURL=VideoFxCanvasOpsManager.js.map
{"version":3,"file":"SDP.js","sourceRoot":"","sources":["../../src/sdp/SDP.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport SDPCandidateType from './SDPCandidateType';\nimport SDPMediaSection from './SDPMediaSection';\nimport VideoCodecCapability from './VideoCodecCapability';\n\n/**\n * [[SDP]] includes a few helper functions for parsing sdp string.\n */\nexport default class SDP {\n  private static CRLF: string = '\\r\\n';\n\n  static rfc7587LowestBitrate = 6000;\n  static rfc7587HighestBitrate = 510000;\n\n  private static dependencyDescriptorRtpHeaderExtensionUrl = `https://aomediacodec.github.io/av1-rtp-spec/#dependency-descriptor-rtp-header-extension`;\n  private static videoLayersAllocationRtpHeaderExtensionUrl = `http://www.webrtc.org/experiments/rtp-hdrext/video-layers-allocation00`;\n\n  /**\n   * Construts a new [[SDP]] object\n   */\n  constructor(public sdp: string) {}\n\n  /**\n   * Clones an SDP\n   */\n  clone(): SDP {\n    return new SDP(this.sdp);\n  }\n\n  /**\n   * Checks if the candidate is a valid RTP candidate\n   */\n  static isRTPCandidate(candidate: string): boolean {\n    const match = /candidate[:](\\S+) (\\d+)/g.exec(candidate);\n    if (match === null || match[2] !== '1') {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Constructs a new SDP with the given set of SDP lines.\n   */\n  static linesToSDP(lines: string[]): SDP {\n    return new SDP(lines.join(SDP.CRLF));\n  }\n\n  /**\n   * Returns an enum of [[candidateType]] for the given string.\n   */\n  static candidateTypeFromString(candidateType: string): SDPCandidateType | null {\n    switch (candidateType) {\n      case SDPCandidateType.Host:\n        return SDPCandidateType.Host;\n      case SDPCandidateType.ServerReflexive:\n        return SDPCandidateType.ServerReflexive;\n      case SDPCandidateType.PeerReflexive:\n        return SDPCandidateType.PeerReflexive;\n      case SDPCandidateType.Relay:\n        return SDPCandidateType.Relay;\n    }\n    return null;\n  }\n\n  /**\n   * Returns the candidate type assocaited with the sdpline.\n   */\n  static candidateType(sdpLine: string): string | null {\n    const match = /a[=]candidate[:].* typ ([a-z]+) /g.exec(sdpLine);\n    if (match === null) {\n      return null;\n    }\n    return SDP.candidateTypeFromString(match[1]);\n  }\n\n  /**\n   * Returns the media type associated with the sdp line.\n   */\n  private static mediaType(sdpLine: string): 'audio' | 'video' | undefined {\n    const match = /m=(audio|video)/g.exec(sdpLine);\n    if (match === null) {\n      return undefined;\n    }\n    return match[1] as 'audio' | 'video';\n  }\n\n  /**\n   * Erase out \"a=mid\"  from the sdp line.\n   */\n  private static mid(sdpLine: string): string | undefined {\n    if (!sdpLine.includes('a=mid:')) {\n      return undefined;\n    }\n    return sdpLine.replace(/^(a=mid:)/, '');\n  }\n\n  /**\n   * Return the direction associated with the sdp line.\n   */\n  private static direction(sdpLine: string): RTCRtpTransceiverDirection | undefined {\n    const match = /a=(sendrecv|sendonly|recvonly|inactive)/g.exec(sdpLine);\n    if (match === null) {\n      return undefined;\n    }\n    return match[1] as RTCRtpTransceiverDirection;\n  }\n\n  /**\n   * Format the sdp string into separate lines.\n   */\n  static splitLines(blob: string): string[] {\n    return blob\n      .trim()\n      .split('\\n')\n      .map((line: string) => {\n        return line.trim();\n      });\n  }\n\n  /**\n   * split the different sdp sections\n   */\n  static splitSections(sdp: string): string[] {\n    // each section starts with \"m=\"\n    const sections = sdp.split('\\nm=');\n    return sections.map((section: string, index: number) => {\n      return (index > 0 ? 'm=' + section : section).trim() + SDP.CRLF;\n    });\n  }\n\n  /**\n   * split the different sdp sections\n   */\n  private static findActiveCameraSection(sections: string[]): number {\n    let cameraLineIndex = 0;\n    let hasCamera = false;\n    for (const sec of sections) {\n      if (/^m=video/.test(sec)) {\n        if (\n          sec.indexOf('sendrecv') > -1 ||\n          // RFC 4566: If none of the attributes \"sendonly\", \"recvonly\", \"inactive\",\n          // and \"sendrecv\" is present, \"sendrecv\" SHOULD be assumed as the\n          // default for sessions\n          (sec.indexOf('sendonly') === -1 &&\n            sec.indexOf('recvonly') === -1 &&\n            sec.indexOf('inactive') === -1)\n        ) {\n          hasCamera = true;\n          break;\n        }\n      }\n      cameraLineIndex++;\n    }\n\n    if (hasCamera === false) {\n      cameraLineIndex = -1;\n    }\n    return cameraLineIndex;\n  }\n\n  /**\n   * Extract the SSRCs from the group line.\n   *\n   * a=ssrc-group:<semantics> <ssrc-id> ...\n   */\n  static extractSSRCsFromFIDGroupLine(figGroupLine: string): string {\n    const ssrcStringMatch = /^a=ssrc-group:FID\\s(.+)/.exec(figGroupLine);\n    return ssrcStringMatch[1];\n  }\n\n  /**\n   * Extracts the lines from the sdp blob that matches the given prefix.\n   */\n  static matchPrefix(blob: string, prefix: string): string[] {\n    return SDP.splitLines(blob).filter((line: string) => {\n      return line.indexOf(prefix) === 0;\n    });\n  }\n\n  /**\n   * Splits SDP string into lines\n   */\n  lines(): string[] {\n    return this.sdp.split(SDP.CRLF);\n  }\n\n  /**\n   * Checks if SDP has a video section.\n   */\n  hasVideo(): boolean {\n    return /^m=video/gm.exec(this.sdp) !== null;\n  }\n\n  /**\n   * Checks whether the SDP has candidates for any m-line\n   */\n  hasCandidates(): boolean {\n    const match = /a[=]candidate[:]/g.exec(this.sdp);\n    if (match === null) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Checks whether the SDP has candidates for all m-lines\n   */\n  hasCandidatesForAllMLines(): boolean {\n    const isAnyCLineUsingLocalHost = this.sdp.indexOf('c=IN IP4 0.0.0.0') > -1;\n    const mLinesHaveCandidates = !isAnyCLineUsingLocalHost;\n    return mLinesHaveCandidates;\n  }\n\n  /**\n   * Removes candidates of a given type from SDP\n   */\n  withoutCandidateType(candidateTypeToExclude: SDPCandidateType): SDP {\n    return SDP.linesToSDP(\n      this.lines().filter(line => SDP.candidateType(line) !== candidateTypeToExclude)\n    );\n  }\n\n  /**\n   * Removes server reflexive candidate from SDP\n   */\n  withoutServerReflexiveCandidates(): SDP {\n    return this.withoutCandidateType(SDPCandidateType.ServerReflexive);\n  }\n\n  /**\n   * Inserts a parameter to the SDP local offer setting the desired average audio bitrate\n   */\n  withAudioMaxAverageBitrate(maxAverageBitrate: number | null): SDP {\n    if (!maxAverageBitrate) {\n      return this.clone();\n    }\n    maxAverageBitrate = Math.trunc(\n      Math.min(Math.max(maxAverageBitrate, SDP.rfc7587LowestBitrate), SDP.rfc7587HighestBitrate)\n    );\n    const srcLines: string[] = this.lines();\n    const fmtpAttributes = SDP.findOpusFmtpAttributes(srcLines);\n    const dstLines = SDP.updateOpusFmtpAttributes(srcLines, fmtpAttributes, [\n      `maxaveragebitrate=${maxAverageBitrate}`,\n    ]);\n    return SDP.linesToSDP(dstLines);\n  }\n\n  /**\n   * Update the SDP to include stereo\n   */\n  withStereoAudio(): SDP {\n    const srcLines: string[] = this.lines();\n    const fmtpAttributes = SDP.findOpusFmtpAttributes(srcLines);\n    const dstLines = SDP.updateOpusFmtpAttributes(srcLines, fmtpAttributes, [\n      'stereo=1',\n      'sprop-stereo=1',\n    ]);\n    return SDP.linesToSDP(dstLines);\n  }\n\n  /**\n   * Here we loop through each line in the SDP\n   * and construct an array containing the fmtp\n   * attribute for all the audio m lines that use\n   * the opus codec. If it doesn't use opus codec\n   * we add null to the array which tells\n   * updateOpusFmtpAttributes that no update is\n   * needed for that particular fmtp attribute line\n   */\n  static findOpusFmtpAttributes(sdpLines: string[]): string[] | null {\n    const opusRtpMapRegex = /^a=rtpmap:\\s*(\\d+)\\s+opus\\/48000/;\n    let lookingForOpusRtpMap = false;\n    const fmtpAttributes: (string | null)[] = [];\n\n    for (const line of sdpLines) {\n      if (line.startsWith('m=audio')) {\n        fmtpAttributes.push(null);\n        lookingForOpusRtpMap = true;\n      }\n      if (line.startsWith('m=video')) {\n        // Opus rtpmap is only part of audio m lines section\n        // Set this to false as we don't need to perform regex\n        // matches for video section\n        lookingForOpusRtpMap = false;\n      }\n      if (lookingForOpusRtpMap) {\n        const match = opusRtpMapRegex.exec(line);\n        if (match !== null) {\n          fmtpAttributes[fmtpAttributes.length - 1] = `a=fmtp:${match[1]} `;\n        }\n      }\n    }\n    return fmtpAttributes;\n  }\n\n  /**\n   * Update the fmtp lines in each audio m section\n   * that correspond to the opus codec with the parameters\n   * specifief in additionalParams\n   */\n  static updateOpusFmtpAttributes(\n    srcLines: string[],\n    fmtpAttributes: (string | null)[],\n    additionalParams: string[]\n  ): string[] {\n    const dstLines: string[] = [];\n    let fmtpIndex = 0;\n    let currFmtpAttribute: string | null = null;\n    for (const line of srcLines) {\n      if (line.startsWith('m=audio')) {\n        currFmtpAttribute = fmtpAttributes[fmtpIndex];\n        fmtpIndex++;\n      }\n      if (line.startsWith('m=video')) {\n        currFmtpAttribute = null;\n      }\n      if (currFmtpAttribute && line.startsWith(currFmtpAttribute)) {\n        const oldParameters: string[] = line.slice(currFmtpAttribute.length).split(';');\n        const newParameters: string[] = [];\n        // If an existing parameter is in additionalParams\n        // dont add it to newParameters as it will be replaced\n        for (const parameter of oldParameters) {\n          const index = additionalParams.findIndex(element =>\n            element.startsWith(parameter.split('=')[0])\n          );\n          if (index < 0) {\n            newParameters.push(parameter);\n          }\n        }\n        for (const parameter of additionalParams) {\n          newParameters.push(parameter);\n        }\n        dstLines.push(currFmtpAttribute + newParameters.join(';'));\n      } else {\n        dstLines.push(line);\n      }\n    }\n    return dstLines;\n  }\n\n  /**\n   * Munges Unified-Plan SDP from different browsers to conform to one format\n   * TODO: will remove this soon.\n   */\n  withUnifiedPlanFormat(): SDP {\n    let originalSdp = this.sdp;\n    if (originalSdp.includes('mozilla')) {\n      return this.clone();\n    } else {\n      originalSdp = originalSdp.replace('o=-', 'o=mozilla-chrome');\n    }\n\n    return new SDP(originalSdp);\n  }\n\n  /**\n   * Returns the total number of unique Rtp header extensions.\n   */\n  getUniqueRtpHeaderExtensionId(srcLines: string[]): number {\n    const headerExtensionIds: number[] = [];\n\n    for (const line of srcLines) {\n      if (/^a=extmap:/.test(line.trim())) {\n        const headerExtension = line.split('a=extmap:')[1].split(' ');\n        const id = +headerExtension[0];\n        if (!headerExtensionIds.includes(id)) {\n          headerExtensionIds.push(id);\n        }\n      }\n    }\n\n    headerExtensionIds.sort((a, b) => a - b);\n    let previousId = 0; // header extension cannot be 0, refer https://datatracker.ietf.org/doc/html/rfc5285\n    for (const id of headerExtensionIds) {\n      if (id - previousId > 1) {\n        return previousId + 1;\n      }\n      previousId = id;\n    }\n\n    // One-Byte Header header extension cannot be bigger than 14, refer https://datatracker.ietf.org/doc/html/rfc5285\n    return previousId === 14 ? -1 : previousId + 1;\n  }\n\n  /**\n   * To avoid resubscribing to preemptively turn off simulcast streams or to switch layers\n   * negotiate with the back end to determine whether to use layers allocation header extension\n   * this will not add the packet overhead unless negotiated to avoid waste\n   */\n  withVideoLayersAllocationRtpHeaderExtension(previousSdp: SDP): SDP {\n    return this.withRtpHeaderExtension(previousSdp, SDP.videoLayersAllocationRtpHeaderExtensionUrl);\n  }\n\n  /**\n   * Dependency descriptors can be used by the backend to designate spatial or temporal layers\n   * on a single encoding. Along with the video layers allocation exension this will\n   * result in the ability for remote attendees to subscribe to individual layers below the top.\n   */\n  withDependencyDescriptorRtpHeaderExtension(previousSdp: SDP): SDP {\n    return this.withRtpHeaderExtension(previousSdp, SDP.dependencyDescriptorRtpHeaderExtensionUrl);\n  }\n\n  /**\n   * If the send transceiver is in a state where the layers allocation extension is not matching up with\n   * the dependency descriptor extension, or we simply don't want to allow for the seperation of spatial\n   * or temporal layers, we can remove the dependency descriptor from the SDP.\n   *\n   * Note: Care should be taken when calling this function since `withDependencyDescriptorRtpHeaderExtension`\n   * if called again will require an accurate ID value. Thus it is recommended to only call `withoutDependencyDescriptorRtpHeaderExtension`\n   * after setting the local description.\n   */\n  withoutDependencyDescriptorRtpHeaderExtension(): SDP {\n    const srcLines: string[] = SDP.splitLines(this.sdp).filter(\n      line => !line.includes(SDP.dependencyDescriptorRtpHeaderExtensionUrl)\n    );\n    return new SDP(srcLines.join(SDP.CRLF) + SDP.CRLF);\n  }\n\n  private withRtpHeaderExtension(previousSdp: SDP, url: string): SDP {\n    // According to https://webrtc.googlesource.com/src/+/b62ee8ce94e5f10e0a94d6f112e715cc4d0cd9dc,\n    // RTP header extension ID change would result in a hard failure. Therefore if the extension exists\n    // in the previous SDP, use the same extension ID to avoid the failure. Otherwise use a new ID\n    const previousId = previousSdp ? previousSdp.getRtpHeaderExtensionId(url) : -1;\n    const id =\n      previousId === -1 ? this.getUniqueRtpHeaderExtensionId(SDP.splitLines(this.sdp)) : previousId;\n\n    const sections = SDP.splitSections(this.sdp);\n    const newSections = [];\n    for (let section of sections) {\n      if (/^m=video/.test(section) && SDP.getRtpHeaderExtensionIdInSection(section, url) === -1) {\n        // Add RTP header extension when it does not already exist\n        const srcLines: string[] = SDP.splitLines(section);\n        const dstLines: string[] = [];\n        if (id === -1 || this.hasRtpHeaderExtensionId(id)) {\n          // if all ids are used or the id is already used, we won't add new line to it\n          newSections.push(section);\n          continue;\n        }\n\n        for (const line of srcLines) {\n          dstLines.push(line);\n          if (/^a=sendrecv/.test(line.trim())) {\n            const targetLine = `a=extmap:` + id + ` ` + url;\n            dstLines.push(targetLine);\n          }\n        }\n        section = dstLines.join(SDP.CRLF) + SDP.CRLF;\n      } else if (\n        previousId !== -1 &&\n        /^m=video/.test(section) &&\n        SDP.getRtpHeaderExtensionIdInSection(section, url) !== previousId\n      ) {\n        // Override extension ID if it does not match previous SDP\n        const srcLines: string[] = SDP.splitLines(section);\n        const dstLines: string[] = [];\n        for (const line of srcLines) {\n          if (/^a=extmap:/.test(line.trim())) {\n            const headerExtension = line.split('a=extmap:')[1].split(' ');\n            if (headerExtension[1] === url) {\n              if (!this.hasRtpHeaderExtensionId(previousId)) {\n                // If previous ID is used by another extension, remove it from this SDP\n                const targetLine = `a=extmap:` + previousId + ` ` + url;\n                dstLines.push(targetLine);\n              }\n              continue;\n            }\n          }\n          dstLines.push(line);\n        }\n        section = dstLines.join(SDP.CRLF) + SDP.CRLF;\n      }\n      newSections.push(section);\n    }\n    const newSdp = newSections.join('');\n    return new SDP(newSdp);\n  }\n\n  /**\n   * Extracts the ssrc for the sendrecv video media section in SDP\n   */\n  ssrcForVideoSendingSection(): string {\n    const srcSDP: string = this.sdp;\n    const sections = SDP.splitSections(srcSDP);\n    if (sections.length < 2) {\n      return '';\n    }\n\n    const cameraLineIndex: number = SDP.findActiveCameraSection(sections);\n    if (cameraLineIndex === -1) {\n      return '';\n    }\n\n    // TODO: match for Firefox. Currently all failures are not Firefox induced.\n    const fidGroupMatch = SDP.matchPrefix(sections[cameraLineIndex], 'a=ssrc-group:FID ');\n    if (fidGroupMatch.length < 1) {\n      return '';\n    }\n\n    const fidGroup = SDP.extractSSRCsFromFIDGroupLine(fidGroupMatch[0]);\n    const [videoSSRC1] = fidGroup.split(' ').map(ssrc => parseInt(ssrc, 10));\n\n    return videoSSRC1.toString();\n  }\n\n  /**\n   * Returns whether the sendrecv video sections if exist have two different SSRCs in SDPs\n   */\n  videoSendSectionHasDifferentSSRC(prevSdp: SDP): boolean {\n    const ssrc1 = this.ssrcForVideoSendingSection();\n    const ssrc2 = prevSdp.ssrcForVideoSendingSection();\n    if (ssrc1 === '' || ssrc2 === '') {\n      return false;\n    }\n    const ssrc1InNumber = parseInt(ssrc1, 10);\n    const ssrc2InNumber = parseInt(ssrc2, 10);\n    if (ssrc1InNumber === ssrc2InNumber) {\n      return false;\n    }\n    return true;\n  }\n\n  /**\n   * Removes H.264 from the send section.\n   */\n  removeH264SupportFromSendSection(): SDP {\n    const srcSDP: string = this.sdp;\n    const sections = SDP.splitSections(srcSDP);\n    const cameraLineIndex: number = SDP.findActiveCameraSection(sections);\n    if (cameraLineIndex === -1) {\n      return new SDP(this.sdp);\n    }\n    const cameraSection = sections[cameraLineIndex];\n    const cameraSectionLines = SDP.splitLines(cameraSection);\n    const payloadTypesForH264: number[] = [];\n    const primaryPayloadTypeToFeedbackPayloadTypes: Map<number, number[]> = new Map();\n    // Loop through camera section (m=video)\n    cameraSectionLines.forEach(attribute => {\n      // Find the payload type with H264 codec line (e.g., a=rtpmap:<payload> H264/90000)\n      if (/^a=rtpmap:/.test(attribute)) {\n        const payloadMatch = /^a=rtpmap:([0-9]+)\\s/.exec(attribute);\n        if (payloadMatch && attribute.toLowerCase().includes('h264')) {\n          payloadTypesForH264.push(parseInt(payloadMatch[1], 10));\n        }\n      }\n\n      // Loop through the rtx payload and create a mapping between it and the primary payload.\n      // a=fmtp:<rtx payload> apt=<primary payload>\n      if (/^a=fmtp:/.test(attribute)) {\n        const feedbackMatches = /^a=fmtp:([0-9]+) apt=([0-9]+)/.exec(attribute);\n        if (feedbackMatches && feedbackMatches.length === 3) {\n          const feedbackPayloadType = parseInt(feedbackMatches[1], 10);\n          const primaryPayloadType = parseInt(feedbackMatches[2], 10);\n          if (primaryPayloadTypeToFeedbackPayloadTypes.has(primaryPayloadType)) {\n            primaryPayloadTypeToFeedbackPayloadTypes\n              .get(primaryPayloadType)\n              .push(feedbackPayloadType);\n          } else {\n            primaryPayloadTypeToFeedbackPayloadTypes.set(primaryPayloadType, [feedbackPayloadType]);\n          }\n        }\n      }\n    });\n\n    // Add the rtx payloads corresponding to the H264 codec to the remove list\n    const payloadTypesToRemove: Set<Number> = new Set();\n    for (const type of payloadTypesForH264) {\n      payloadTypesToRemove.add(type);\n\n      const feedbackTypes = primaryPayloadTypeToFeedbackPayloadTypes.get(type);\n      if (feedbackTypes) {\n        for (const feedbackType of feedbackTypes) {\n          payloadTypesToRemove.add(feedbackType);\n        }\n      }\n    }\n\n    // Remove H264 payload from the media line. m=video 9 UDP/+++ <payload> <payload> <payload>\n    if (payloadTypesForH264.length > 0) {\n      const mline = cameraSectionLines[0].split(' ');\n      cameraSectionLines[0] = mline\n        .filter((text: string) => !payloadTypesToRemove.has(parseInt(text)))\n        .join(' ');\n    }\n\n    // Filter out lines with H264 payload\n    const filteredLines = cameraSectionLines.filter((line: string) => {\n      if (!line.includes('rtpmap') && !line.includes('rtcp-fb') && !line.includes('fmtp')) {\n        return true;\n      }\n      for (const type of payloadTypesToRemove) {\n        if (line.includes(type.toString())) {\n          return false;\n        }\n      }\n      return true;\n    });\n\n    sections[cameraLineIndex] = filteredLines.join(SDP.CRLF) + SDP.CRLF;\n\n    const newSDP = sections.join('');\n    return new SDP(newSDP);\n  }\n\n  /**\n   * List of parsed media sections sections in order they occur on SDP.\n   */\n  mediaSections(): SDPMediaSection[] {\n    const sections = SDP.splitSections(this.sdp);\n    if (sections.length < 2) {\n      return [];\n    }\n\n    const parsedMediaSections: SDPMediaSection[] = [];\n    for (let i = 1; i < sections.length; i++) {\n      const section = new SDPMediaSection();\n      const lines = SDP.splitLines(sections[i]);\n      for (const line of lines) {\n        const mediaType = SDP.mediaType(line);\n        if (mediaType !== undefined) {\n          section.mediaType = mediaType;\n          continue;\n        }\n        const direction = SDP.direction(line);\n        if (direction !== undefined) {\n          section.direction = direction;\n          continue;\n        }\n        const mid = SDP.mid(line);\n        if (mid !== undefined) {\n          section.mid = mid;\n          continue;\n        }\n      }\n      parsedMediaSections.push(section);\n    }\n    return parsedMediaSections;\n  }\n\n  /**\n   * Return RTP header extension ID if the extension exists in section. Return -1 otherwise\n   */\n  static getRtpHeaderExtensionIdInSection(section: string, url: string): number {\n    const lines: string[] = SDP.splitLines(section);\n    for (const line of lines) {\n      if (/^a=extmap:/.test(line.trim())) {\n        const headerExtension = line.split('a=extmap:')[1].split(' ');\n        const id = +headerExtension[0];\n        if (headerExtension[1] === url) {\n          return id;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Return RTP header extension ID if the extension exists in SDP. Return -1 otherwise\n   */\n  getRtpHeaderExtensionId(url: string): number {\n    const sections = SDP.splitSections(this.sdp);\n\n    for (const section of sections) {\n      if (/^m=video/.test(section)) {\n        const id = SDP.getRtpHeaderExtensionIdInSection(section, url);\n        if (id !== -1) {\n          return id;\n        }\n      }\n    }\n    return -1;\n  }\n\n  /**\n   * Return if extension ID exists in the SDP\n   */\n  hasRtpHeaderExtensionId(targetId: number): boolean {\n    const lines = SDP.splitLines(this.sdp);\n\n    for (const line of lines) {\n      if (/^a=extmap:/.test(line.trim())) {\n        const headerExtension = line.split('a=extmap:')[1].split(' ');\n        const id = +headerExtension[0];\n        if (id === targetId) {\n          return true;\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Based off the provided preferences, this function will reorder the payload types listed in the `m=video` line.\n   *\n   * This will be applied to the `a=sendrecv` section so it can be applied on either local or remote SDPs. It can be used to\n   * 'polyfill' `RTCRtpSender.setCodecPreferences' on the offer, but it can also be used on remote SDPs to force the\n   * codec actually being send, since the send codec is currently dependent on the remote answer (i.e. `setCodecPreferences` doesn't actually\n   * have any impact unless the remote side respects the order of codecs which is not true of the Chime SDK media backends).\n   */\n  withVideoSendCodecPreferences(preferences: VideoCodecCapability[]): SDP {\n    const srcSDP: string = this.sdp;\n    const sections = SDP.splitSections(srcSDP);\n    // Note `findActiveCameraSection` looks for `sendrecv` video sections so it\n    // works on both local and remote SDPs.\n    const cameraLineIndex: number = SDP.findActiveCameraSection(sections);\n    if (cameraLineIndex === -1) {\n      return new SDP(this.sdp);\n    }\n    sections[cameraLineIndex] = this.sectionWithCodecPreferences(\n      sections[cameraLineIndex],\n      preferences\n    );\n    const newSDP = sections.join('');\n    return new SDP(newSDP);\n  }\n\n  // Based off the provided preferences, this function will reorder the payload types listed in the `m=video` line.\n  private sectionWithCodecPreferences(\n    section: string,\n    preferences: VideoCodecCapability[]\n  ): string {\n    const payloadTypeToCodec: Map<string, VideoCodecCapability> = new Map();\n    const lines = SDP.splitLines(section);\n\n    // Process each line to map payload types to their respective codecs\n    lines.forEach(line => {\n      if (!line.startsWith('a=rtpmap:')) {\n        return;\n      }\n\n      const payloadMatch = /^a=rtpmap:(\\d+)\\s/.exec(line);\n      if (!payloadMatch) {\n        return;\n      }\n      const payloadTypeString: string = payloadMatch[1];\n\n      for (const preference of preferences) {\n        if (!line.includes(`${preference.codecName}/${preference.codecCapability.clockRate}`)) {\n          continue;\n        }\n\n        let codecMatches = false;\n        if (preference.codecCapability.sdpFmtpLine !== undefined) {\n          let hasVp9ProfileId = false;\n\n          for (const prospectiveFmtpLine of lines) {\n            if (preference.fmtpLineMatches(prospectiveFmtpLine, parseInt(payloadTypeString))) {\n              codecMatches = true;\n              break;\n            }\n\n            hasVp9ProfileId ||= prospectiveFmtpLine.startsWith(\n              `a=fmtp:${payloadTypeString} profile-id=`\n            );\n          }\n\n          if (preference.equals(VideoCodecCapability.vp9Profile0()) && !hasVp9ProfileId) {\n            codecMatches = true;\n          }\n        } else {\n          codecMatches = true;\n        }\n\n        if (codecMatches) {\n          payloadTypeToCodec.set(payloadTypeString, preference);\n          break;\n        }\n      }\n    });\n\n    const payloadTypesToRemove: Set<string> = new Set(payloadTypeToCodec.keys());\n    const mline = lines[0].split(' ').filter(text => !payloadTypesToRemove.has(text));\n\n    const orderedPreferedPayloadTypes = Array.from(payloadTypeToCodec.entries())\n      .sort(([_payloadType1, codec1], [_payloadType2, codec2]) => {\n        const priority1 = preferences.indexOf(codec1);\n        const priority2 = preferences.indexOf(codec2);\n        return priority1 - priority2;\n      })\n      .map(([payloadType, _]) => payloadType);\n\n    mline.splice(3, 0, ...orderedPreferedPayloadTypes);\n    lines[0] = mline.join(' ');\n\n    return lines.join(SDP.CRLF) + SDP.CRLF;\n  }\n\n  /**\n   * Returns the `VideoCodecCapability` which corresponds to the first payload type in the\n   * m-line (e.g. `m=video 9 UDP/+++ <highest priority payload type> <payload type> <payload type> ...`),\n   * parsing the rest of the SDP for relevant information to construct it.\n   *\n   * Returns undefined if there is no video send section or no codecs in the send section\n   *\n   * This function is currently unused/deprecated and will be removed in a future PR.\n   */\n  highestPriorityVideoSendCodec(): VideoCodecCapability | undefined {\n    const prioritizedSendVideoCodecCapabilities = this.prioritizedSendVideoCodecCapabilities();\n    return prioritizedSendVideoCodecCapabilities.length > 0\n      ? prioritizedSendVideoCodecCapabilities[0]\n      : undefined;\n  }\n\n  /**\n   * Returns all `VideoCodecCapability` that can be found in the camera section, in order of priority as defined in\n   * m-line (e.g. `m=video 9 UDP/+++ <highest priority payload type> <payload type> <payload type> ...`),\n   * parsing the rest of the SDP for relevant information to construct it.\n   *\n   * Returns an empty list if there is no video send section or no codecs in the send section\n   */\n  prioritizedSendVideoCodecCapabilities(): VideoCodecCapability[] {\n    const srcSDP: string = this.sdp;\n    const sections = SDP.splitSections(srcSDP);\n    // Note `findActiveCameraSection` looks for `sendrecv` video sections so it\n    // works on both local and remote SDPs.\n    const cameraLineIndex: number = SDP.findActiveCameraSection(sections);\n    if (cameraLineIndex === -1) {\n      return [];\n    }\n\n    const lines = SDP.splitLines(sections[cameraLineIndex]);\n\n    // m=video 9 UDP/+++ <payload> <payload> <payload> ...\n    const mlineTokens = lines[0].split(' ');\n    if (mlineTokens.length < 4) {\n      return [];\n    }\n\n    // Extract payload types from the m-line\n    const payloadTypes = mlineTokens.slice(3);\n\n    // Get VideoCodecCapability for each payload type\n    const capabilities = payloadTypes\n      .map(payloadType => this.videoCodecCapabilityForPayloadType(lines, payloadType))\n      .filter(capability => {\n        // Filter out capabilities that failed to parse or are not codecs (e.g. RTX payload types)\n        return (\n          capability !== undefined && ['VP8', 'H264', 'VP9', 'AV1'].includes(capability.codecName)\n        );\n      });\n\n    return capabilities;\n  }\n\n  private videoCodecCapabilityForPayloadType(\n    sectionLines: string[],\n    payloadType: string\n  ): VideoCodecCapability | undefined {\n    let codecName = undefined;\n    let clockRate = undefined;\n    let fmtpLine = undefined;\n\n    for (const line of sectionLines) {\n      // Match the payload type in rtpmap lines\n      const payloadMatch = /^a=rtpmap:([0-9]+)\\s/.exec(line);\n      if (payloadMatch && payloadMatch[1] === payloadType) {\n        const lineTokens = line.split(' ');\n        const nameAndClockRate = lineTokens[1].split('/');\n        if (nameAndClockRate.length >= 2) {\n          codecName = nameAndClockRate[0];\n          clockRate = nameAndClockRate[1];\n        }\n      }\n\n      // Match fmtp lines for the payload type\n      if (line.startsWith(`a=fmtp:${payloadType} `)) {\n        // `split` will always return 2 items given we have trailing whitespace in check above\n        fmtpLine = line.split(' ')[1];\n      }\n    }\n\n    if (codecName !== undefined) {\n      return new VideoCodecCapability(codecName, {\n        clockRate: parseInt(clockRate),\n        mimeType: `video/${codecName}`,\n        sdpFmtpLine: fmtpLine,\n      });\n    }\n\n    return undefined;\n  }\n\n  getAudioPayloadTypes(): Map<string, number> {\n    const payloadTypeMap: Map<string, number> = new Map<string, number>();\n    const srcSDP: string = this.sdp;\n    const sections = SDP.splitSections(srcSDP);\n    payloadTypeMap.set('opus', SDP.findAudioPayloadType('opus', sections));\n    payloadTypeMap.set('red', SDP.findAudioPayloadType('red', sections));\n    return payloadTypeMap;\n  }\n\n  private static findAudioPayloadType(codecName: string, sections: string[]): number {\n    const codecRegex = `a=rtpmap:\\\\s*(\\\\d+)\\\\s+${codecName}\\\\/48000`;\n    const rtpMapRegex = new RegExp(codecRegex);\n    for (const sec of sections) {\n      if (/^m=audio/.test(sec)) {\n        const match = rtpMapRegex.exec(sec);\n        if (match !== null) {\n          return Number(match[1]);\n        }\n      }\n    }\n    return 0;\n  }\n\n  /**\n   * Modifies the active camera section to include a specified starting bitrate\n   * for video sending by adding a 'x-google-start-bitrate' fmtp line paramter for\n   * each payload type associated with video.\n   *\n   * If no active camera section is found in the SDP, returns the original SDP object.\n   */\n  withStartingVideoSendBitrate(bitrateKbps: number): SDP {\n    const sections = SDP.splitSections(this.sdp);\n\n    const cameraLineIndex: number = SDP.findActiveCameraSection(sections);\n    if (cameraLineIndex === -1) {\n      return this;\n    }\n\n    const srcLines: string[] = SDP.splitLines(sections[cameraLineIndex]);\n    const dstLines: string[] = [];\n\n    for (const line of srcLines) {\n      if (/^a=fmtp:\\d*/.test(line)) {\n        // `x-google-start-bitrate` is an unofficial flag that has existed in libwebrtc since its release and is unlikely\n        // to be removed without notification.\n        //\n        // libwebrtc constant: https://webrtc.googlesource.com/src/+/b6ef1a736ee94d97cc28f3bd59b826c716a3278f/media/base/media_constants.cc#97\n        // libwebrtc parsing:  https://webrtc.googlesource.com/src/+/61c5e86dca59b0ac8240444e7df5c31da27ee40f/media/engine/webrtc_media_engine.cc#172\n        const newLine = line + `;x-google-start-bitrate=${bitrateKbps}`;\n        dstLines.push(newLine);\n      } else {\n        dstLines.push(line);\n      }\n    }\n    sections[cameraLineIndex] = dstLines.join(SDP.CRLF) + SDP.CRLF;\n\n    const newSdp = sections.join('');\n    return new SDP(newSdp);\n  }\n}\n"]}
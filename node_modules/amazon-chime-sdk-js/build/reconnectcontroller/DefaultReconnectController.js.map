{"version":3,"file":"DefaultReconnectController.js","sourceRoot":"","sources":["../../src/reconnectcontroller/DefaultReconnectController.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport BackoffPolicy from '../backoff/Backoff';\nimport TimeoutScheduler from '../scheduler/TimeoutScheduler';\nimport ReconnectController from './ReconnectController';\n\nexport default class DefaultReconnectController implements ReconnectController {\n  private shouldReconnect: boolean = true;\n  private onlyRestartPeerConnection: boolean = false;\n  private firstConnectionAttempted: boolean = false;\n  private firstConnectionAttemptTimestampMs: number = 0;\n  private lastActiveTimestampMs: number = Infinity;\n  private _isFirstConnection: boolean = true;\n  private backoffTimer: TimeoutScheduler | null = null;\n  private backoffCancel: () => void = null;\n\n  constructor(private reconnectTimeoutMs: number, private backoffPolicy: BackoffPolicy) {\n    this.reset();\n  }\n\n  private timeSpentReconnectingMs(): number {\n    if (!this.firstConnectionAttempted) {\n      return 0;\n    }\n    return Date.now() - this.firstConnectionAttemptTimestampMs;\n  }\n\n  private hasPastReconnectDeadline(): boolean {\n    if (Date.now() - this.lastActiveTimestampMs >= this.reconnectTimeoutMs) {\n      return true;\n    }\n\n    return this.timeSpentReconnectingMs() >= this.reconnectTimeoutMs;\n  }\n\n  reset(): void {\n    this.cancel();\n    this.shouldReconnect = true;\n    this.onlyRestartPeerConnection = false;\n    this.firstConnectionAttempted = false;\n    this.firstConnectionAttemptTimestampMs = 0;\n    this.lastActiveTimestampMs = Infinity;\n    this.backoffPolicy.reset();\n  }\n\n  startedConnectionAttempt(isFirstConnection: boolean): void {\n    this._isFirstConnection = isFirstConnection;\n    if (!this.firstConnectionAttempted) {\n      this.firstConnectionAttempted = true;\n      this.firstConnectionAttemptTimestampMs = Date.now();\n    }\n  }\n\n  hasStartedConnectionAttempt(): boolean {\n    return this.firstConnectionAttempted;\n  }\n\n  isFirstConnection(): boolean {\n    return this._isFirstConnection;\n  }\n\n  disableReconnect(): void {\n    this.shouldReconnect = false;\n  }\n\n  enableRestartPeerConnection(): void {\n    this.onlyRestartPeerConnection = true;\n  }\n\n  cancel(): void {\n    this.disableReconnect();\n    if (this.backoffTimer) {\n      this.backoffTimer.stop();\n      if (this.backoffCancel) {\n        this.backoffCancel();\n        this.backoffCancel = null;\n      }\n    }\n  }\n\n  retryWithBackoff(retryFunc: () => void, cancelFunc: () => void): boolean {\n    const willRetry = this.shouldReconnect && !this.hasPastReconnectDeadline();\n    if (willRetry) {\n      this.backoffCancel = cancelFunc;\n      this.backoffTimer = new TimeoutScheduler(this.backoffPolicy.nextBackoffAmountMs());\n      this.backoffTimer.start(() => {\n        this.backoffCancel = null;\n        retryFunc();\n      });\n    }\n    return willRetry;\n  }\n\n  shouldOnlyRestartPeerConnection(): boolean {\n    return this.onlyRestartPeerConnection;\n  }\n\n  clone(): DefaultReconnectController {\n    return new DefaultReconnectController(this.reconnectTimeoutMs, this.backoffPolicy);\n  }\n\n  setLastActiveTimestampMs(timestampMs: number): void {\n    this.lastActiveTimestampMs = timestampMs;\n  }\n}\n"]}
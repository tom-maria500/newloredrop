"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ContentShareConstants_1 = __importDefault(require("../contentsharecontroller/ContentShareConstants"));
const ServerSideNetworkAdaption_1 = __importDefault(require("../signalingclient/ServerSideNetworkAdaption"));
const VideoPreference_1 = __importDefault(require("./VideoPreference"));
const VideoPreferences_1 = require("./VideoPreferences");
const VideoPriorityBasedPolicy_1 = __importDefault(require("./VideoPriorityBasedPolicy"));
const VideoPriorityBasedPolicyConfig_1 = __importDefault(require("./VideoPriorityBasedPolicyConfig"));
/**
 * [[VideoAdaptiveProbePolicy]] wraps [[VideoPriorityBasedPolicy]] with customized behavior to automatically
 * assign a high preference to content share. This is a legacy policy used by default when simulcast is enabled, but
 * all customers should be using `VideoPriorityBasedPolicy` instead, since this policy does not work with
 * server side network adaptation.
 *
 * You can imitate this classes behavior using the `VideoPriorityBasedPolicy` with the following snippet
 * ```
 *   remoteVideoSourcesDidChange(videoSources: VideoSource[]) {
 *     const videoPreferences = VideoPreferences.prepare();
 *     for(const source of videoSources) {
 *        const isContent = source.attendee.attendeeId.endsWith(ContentShareConstants.Modality);
 *        videoPreferences.add(new VideoPreference(source.attendee.attendeeId, isContent ? 2: 1, TargetDisplaySize.High));
 *     }
 *     this.priorityBasedDownlinkPolicy.chooseRemoteVideoSources(videoPreferences.build());
 *   }
 * ```
 */
class VideoAdaptiveProbePolicy extends VideoPriorityBasedPolicy_1.default {
    constructor(logger) {
        // We use a static function to create config because Typescript requires
        // super(...) calls to be the first line in constructors
        super(logger, VideoAdaptiveProbePolicy.createConfig());
        this.logger = logger;
        super.shouldPauseTiles = false;
        this.videoPreferences = undefined;
    }
    static createConfig() {
        const config = new VideoPriorityBasedPolicyConfig_1.default();
        config.serverSideNetworkAdaption = ServerSideNetworkAdaption_1.default.None;
        return config;
    }
    reset() {
        super.reset();
        super.shouldPauseTiles = false;
        this.videoPreferences = undefined;
    }
    updateIndex(videoIndex) {
        super.updateIndex(videoIndex);
        const newPreferences = VideoPreferences_1.VideoPreferences.prepare();
        let containsContent = false;
        const remoteInfos = videoIndex.remoteStreamDescriptions();
        // If there is active content then set that as high priority, and the rest at lower
        for (const info of remoteInfos) {
            // I don't know why we need to do this duplicate check.
            if (!newPreferences.some(preference => preference.attendeeId === info.attendeeId)) {
                // For now always subscribe to content even if higher bandwidth then target
                if (info.attendeeId.endsWith(ContentShareConstants_1.default.Modality)) {
                    newPreferences.add(new VideoPreference_1.default(info.attendeeId, 1));
                    containsContent = true;
                }
                else {
                    newPreferences.add(new VideoPreference_1.default(info.attendeeId, 2));
                }
            }
        }
        if (containsContent) {
            this.videoPreferences = newPreferences.build();
            this.videoPreferencesUpdated = true;
        }
        else {
            this.videoPreferences = undefined;
        }
    }
    /**
     * [[VideoAdaptiveProbePolicy]] does not allow setting video preferences and this function
     * will be a no-op.  Please use [[VideoPriorityBasedPolicy]] directly if you would like to set
     * preferences.
     */
    chooseRemoteVideoSources(_preferences) {
        this.logger.error('chooseRemoteVideoSources should not be called by VideoAdaptiveProbePolicy');
        return;
    }
}
exports.default = VideoAdaptiveProbePolicy;
//# sourceMappingURL=VideoAdaptiveProbePolicy.js.map
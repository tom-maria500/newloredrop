"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultVideoStreamIdSet_1 = __importDefault(require("../videostreamidset/DefaultVideoStreamIdSet"));
/**
 * [[AllHighestVideoBandwidthPolicy]] implements is a rudimentary policy that simply
 * always subscribes to the highest quality video stream available
 * for all non-self participants.
 */
class AllHighestVideoBandwidthPolicy {
    constructor(selfAttendeeId) {
        this.selfAttendeeId = selfAttendeeId;
        this.reset();
    }
    reset() {
        this.optimalReceiveSet = new DefaultVideoStreamIdSet_1.default();
        this.subscribedReceiveSet = new DefaultVideoStreamIdSet_1.default();
        this.videoSources = undefined;
    }
    updateIndex(videoIndex) {
        this.videoIndex = videoIndex;
        this.optimalReceiveSet = this.calculateOptimalReceiveSet(videoIndex);
    }
    updateMetrics(_clientMetricReport) { }
    wantsResubscribe() {
        return !this.subscribedReceiveSet.equal(this.optimalReceiveSet);
    }
    chooseSubscriptions() {
        this.subscribedReceiveSet = this.optimalReceiveSet.clone();
        return this.subscribedReceiveSet.clone();
    }
    chooseRemoteVideoSources(videoSources) {
        this.videoSources = videoSources;
        this.optimalReceiveSet = this.calculateOptimalReceiveSet(this.videoIndex).clone();
    }
    calculateOptimalReceiveSet(videoIndex) {
        const streamSelectionSet = new DefaultVideoStreamIdSet_1.default();
        if (!this.videoIndex || this.videoIndex.allStreams().empty()) {
            return streamSelectionSet;
        }
        const receiveSet = videoIndex.highestQualityStreamFromEachGroupExcludingSelf(this.selfAttendeeId);
        // If video sources are not chosen, then use all of them.
        const videoSources = !!this.videoSources
            ? this.videoSources
            : this.videoIndex.allVideoSendingSourcesExcludingSelf(this.selfAttendeeId);
        // Get the list of all the remote stream information
        const remoteInfos = this.videoIndex.remoteStreamDescriptions();
        const mapOfAttendeeIdToRemoteDescriptions = new Map();
        for (const info of remoteInfos) {
            if (receiveSet.contain(info.streamId)) {
                mapOfAttendeeIdToRemoteDescriptions.set(info.attendeeId, info);
            }
        }
        let totalBitrateKbps = 0;
        for (const videoSource of videoSources) {
            const attendeeId = videoSource.attendee.attendeeId;
            if (mapOfAttendeeIdToRemoteDescriptions.has(attendeeId)) {
                const info = mapOfAttendeeIdToRemoteDescriptions.get(attendeeId);
                if (totalBitrateKbps + info.maxBitrateKbps <=
                    AllHighestVideoBandwidthPolicy.maxReceiveBitrateKbps) {
                    streamSelectionSet.add(info.streamId);
                    totalBitrateKbps += info.maxBitrateKbps;
                }
                else {
                    console.warn('total bitrate ' +
                        (totalBitrateKbps + info.maxBitrateKbps) +
                        ' exceeds maximum limit (15000). Use chooseRemoteVideoSources to select a subset of participants to avoid this.');
                    // We could continue to check more sources (some of them might still fall under the limit).
                    // But we stop here to limit resubscribes if we're hovering near the cap.
                    break;
                }
            }
        }
        return streamSelectionSet;
    }
}
exports.default = AllHighestVideoBandwidthPolicy;
// Cap total receive bitrate at 15000 kbps to avoid hitting per client connection limits
AllHighestVideoBandwidthPolicy.maxReceiveBitrateKbps = 15000;
//# sourceMappingURL=AllHighestVideoBandwidthPolicy.js.map
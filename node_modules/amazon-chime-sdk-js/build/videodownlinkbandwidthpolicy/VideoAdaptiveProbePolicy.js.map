{"version":3,"file":"VideoAdaptiveProbePolicy.js","sourceRoot":"","sources":["../../src/videodownlinkbandwidthpolicy/VideoAdaptiveProbePolicy.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC;;;;;AAEtC,4GAAoF;AAEpF,6GAAqF;AAGrF,wEAAgD;AAChD,yDAAsD;AACtD,0FAAkE;AAClE,sGAA8E;AAE9E;;;;;;;;;;;;;;;;;GAiBG;AACH,MAAqB,wBAAyB,SAAQ,kCAAwB;IAO5E,YAAsB,MAAc;QAClC,wEAAwE;QACxE,wDAAwD;QACxD,KAAK,CAAC,MAAM,EAAE,wBAAwB,CAAC,YAAY,EAAE,CAAC,CAAC;QAHnC,WAAM,GAAN,MAAM,CAAQ;QAIlC,KAAK,CAAC,gBAAgB,GAAG,KAAK,CAAC;QAC/B,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC;IACpC,CAAC;IAZO,MAAM,CAAC,YAAY;QACzB,MAAM,MAAM,GAAG,IAAI,wCAA8B,EAAE,CAAC;QACpD,MAAM,CAAC,yBAAyB,GAAG,mCAAyB,CAAC,IAAI,CAAC;QAClE,OAAO,MAAM,CAAC;IAChB,CAAC;IAUD,KAAK;QACH,KAAK,CAAC,KAAK,EAAE,CAAC;QACd,KAAK,CAAC,gBAAgB,GAAG,KAAK,CAAC;QAC/B,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC;IACpC,CAAC;IAED,WAAW,CAAC,UAA4B;QACtC,KAAK,CAAC,WAAW,CAAC,UAAU,CAAC,CAAC;QAE9B,MAAM,cAAc,GAAG,mCAAgB,CAAC,OAAO,EAAE,CAAC;QAClD,IAAI,eAAe,GAAG,KAAK,CAAC;QAC5B,MAAM,WAAW,GAA6B,UAAU,CAAC,wBAAwB,EAAE,CAAC;QACpF,mFAAmF;QACnF,KAAK,MAAM,IAAI,IAAI,WAAW,EAAE;YAC9B,uDAAuD;YACvD,IAAI,CAAC,cAAc,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,CAAC,UAAU,CAAC,UAAU,KAAK,IAAI,CAAC,UAAU,CAAC,EAAE;gBACjF,2EAA2E;gBAC3E,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,+BAAqB,CAAC,QAAQ,CAAC,EAAE;oBAC5D,cAAc,CAAC,GAAG,CAAC,IAAI,yBAAe,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;oBAC5D,eAAe,GAAG,IAAI,CAAC;iBACxB;qBAAM;oBACL,cAAc,CAAC,GAAG,CAAC,IAAI,yBAAe,CAAC,IAAI,CAAC,UAAU,EAAE,CAAC,CAAC,CAAC,CAAC;iBAC7D;aACF;SACF;QAED,IAAI,eAAe,EAAE;YACnB,IAAI,CAAC,gBAAgB,GAAG,cAAc,CAAC,KAAK,EAAE,CAAC;YAC/C,IAAI,CAAC,uBAAuB,GAAG,IAAI,CAAC;SACrC;aAAM;YACL,IAAI,CAAC,gBAAgB,GAAG,SAAS,CAAC;SACnC;IACH,CAAC;IAED;;;;OAIG;IACH,wBAAwB,CAAC,YAA8B;QACrD,IAAI,CAAC,MAAM,CAAC,KAAK,CAAC,2EAA2E,CAAC,CAAC;QAC/F,OAAO;IACT,CAAC;CACF;AA1DD,2CA0DC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport ContentShareConstants from '../contentsharecontroller/ContentShareConstants';\nimport Logger from '../logger/Logger';\nimport ServerSideNetworkAdaption from '../signalingclient/ServerSideNetworkAdaption';\nimport VideoStreamDescription from '../videostreamindex/VideoStreamDescription';\nimport VideoStreamIndex from '../videostreamindex/VideoStreamIndex';\nimport VideoPreference from './VideoPreference';\nimport { VideoPreferences } from './VideoPreferences';\nimport VideoPriorityBasedPolicy from './VideoPriorityBasedPolicy';\nimport VideoPriorityBasedPolicyConfig from './VideoPriorityBasedPolicyConfig';\n\n/**\n * [[VideoAdaptiveProbePolicy]] wraps [[VideoPriorityBasedPolicy]] with customized behavior to automatically\n * assign a high preference to content share. This is a legacy policy used by default when simulcast is enabled, but\n * all customers should be using `VideoPriorityBasedPolicy` instead, since this policy does not work with\n * server side network adaptation.\n *\n * You can imitate this classes behavior using the `VideoPriorityBasedPolicy` with the following snippet\n * ```\n *   remoteVideoSourcesDidChange(videoSources: VideoSource[]) {\n *     const videoPreferences = VideoPreferences.prepare();\n *     for(const source of videoSources) {\n *        const isContent = source.attendee.attendeeId.endsWith(ContentShareConstants.Modality);\n *        videoPreferences.add(new VideoPreference(source.attendee.attendeeId, isContent ? 2: 1, TargetDisplaySize.High));\n *     }\n *     this.priorityBasedDownlinkPolicy.chooseRemoteVideoSources(videoPreferences.build());\n *   }\n * ```\n */\nexport default class VideoAdaptiveProbePolicy extends VideoPriorityBasedPolicy {\n  private static createConfig(): VideoPriorityBasedPolicyConfig {\n    const config = new VideoPriorityBasedPolicyConfig();\n    config.serverSideNetworkAdaption = ServerSideNetworkAdaption.None;\n    return config;\n  }\n\n  constructor(protected logger: Logger) {\n    // We use a static function to create config because Typescript requires\n    // super(...) calls to be the first line in constructors\n    super(logger, VideoAdaptiveProbePolicy.createConfig());\n    super.shouldPauseTiles = false;\n    this.videoPreferences = undefined;\n  }\n\n  reset(): void {\n    super.reset();\n    super.shouldPauseTiles = false;\n    this.videoPreferences = undefined;\n  }\n\n  updateIndex(videoIndex: VideoStreamIndex): void {\n    super.updateIndex(videoIndex);\n\n    const newPreferences = VideoPreferences.prepare();\n    let containsContent = false;\n    const remoteInfos: VideoStreamDescription[] = videoIndex.remoteStreamDescriptions();\n    // If there is active content then set that as high priority, and the rest at lower\n    for (const info of remoteInfos) {\n      // I don't know why we need to do this duplicate check.\n      if (!newPreferences.some(preference => preference.attendeeId === info.attendeeId)) {\n        // For now always subscribe to content even if higher bandwidth then target\n        if (info.attendeeId.endsWith(ContentShareConstants.Modality)) {\n          newPreferences.add(new VideoPreference(info.attendeeId, 1));\n          containsContent = true;\n        } else {\n          newPreferences.add(new VideoPreference(info.attendeeId, 2));\n        }\n      }\n    }\n\n    if (containsContent) {\n      this.videoPreferences = newPreferences.build();\n      this.videoPreferencesUpdated = true;\n    } else {\n      this.videoPreferences = undefined;\n    }\n  }\n\n  /**\n   * [[VideoAdaptiveProbePolicy]] does not allow setting video preferences and this function\n   * will be a no-op.  Please use [[VideoPriorityBasedPolicy]] directly if you would like to set\n   * preferences.\n   */\n  chooseRemoteVideoSources(_preferences: VideoPreferences): void {\n    this.logger.error('chooseRemoteVideoSources should not be called by VideoAdaptiveProbePolicy');\n    return;\n  }\n}\n"]}
{"version":3,"file":"VideoPriorityBasedPolicy.js","sourceRoot":"","sources":["../../src/videodownlinkbandwidthpolicy/VideoPriorityBasedPolicy.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport Attendee from '../attendee/Attendee';\nimport ClientMetricReport from '../clientmetricreport/ClientMetricReport';\nimport Direction from '../clientmetricreport/ClientMetricReportDirection';\nimport MediaType from '../clientmetricreport/ClientMetricReportMediaType';\nimport ContentShareConstants from '../contentsharecontroller/ContentShareConstants';\nimport Logger from '../logger/Logger';\nimport { LogLevel } from '../logger/LogLevel';\nimport ServerSideNetworkAdaption, {\n  serverSideNetworkAdaptionIsNoneOrDefault,\n} from '../signalingclient/ServerSideNetworkAdaption';\nimport VideoSource from '../videosource/VideoSource';\nimport DefaultVideoStreamIdSet from '../videostreamidset/DefaultVideoStreamIdSet';\nimport VideoStreamIdSet from '../videostreamidset/VideoStreamIdSet';\nimport VideoStreamDescription from '../videostreamindex/VideoStreamDescription';\nimport VideoStreamIndex from '../videostreamindex/VideoStreamIndex';\nimport DefaultVideoTile from '../videotile/DefaultVideoTile';\nimport VideoTile from '../videotile/VideoTile';\nimport VideoTileController from '../videotilecontroller/VideoTileController';\nimport AllHighestVideoBandwidthPolicy from './AllHighestVideoBandwidthPolicy';\nimport TargetDisplaySize from './TargetDisplaySize';\nimport VideoDownlinkBandwidthPolicy from './VideoDownlinkBandwidthPolicy';\nimport VideoDownlinkObserver from './VideoDownlinkObserver';\nimport VideoPreference from './VideoPreference';\nimport { VideoPreferences } from './VideoPreferences';\nimport VideoPriorityBasedPolicyConfig from './VideoPriorityBasedPolicyConfig';\nimport VideoQualityAdaptationPreference from './VideoQualityAdaptationPreference';\n\n/** @internal */\nclass LinkMediaStats {\n  constructor() {}\n  bandwidthEstimateKbps: number = 0;\n  usedBandwidthKbps: number = 0;\n  packetsLost: number = 0;\n  nackCount: number = 0;\n  rttMs: number = 0;\n}\n\n/** @internal */\ninterface PolicyRates {\n  targetDownlinkBitrate: number;\n  chosenTotalBitrate: number;\n  deltaToNextUpgrade: number;\n}\n\n/** @internal */\nconst enum RateProbeState {\n  NotProbing = 'Not Probing',\n  ProbePending = 'Probe Pending',\n  Probing = 'Probing',\n}\n\n/** @internal */\nconst enum UseReceiveSet {\n  NewOptimal,\n  PreviousOptimal,\n  PreProbe,\n}\n\nexport default class VideoPriorityBasedPolicy implements VideoDownlinkBandwidthPolicy {\n  private static readonly DEFAULT_BANDWIDTH_KBPS = 2800;\n  private static readonly STARTUP_PERIOD_MS = 6000;\n  private static readonly LARGE_RATE_CHANGE_TRIGGER_PERCENT = 20;\n  private static readonly TARGET_RATE_CHANGE_TRIGGER_PERCENT = 15;\n  private static readonly LOW_BITRATE_THRESHOLD_KBPS = 300;\n  private static readonly MIN_TIME_BETWEEN_PROBE_MS = 5000;\n  private static readonly MIN_TIME_BETWEEN_SUBSCRIBE_MS = 2000;\n  // We apply exponentional backoff to probe attempts if they do not\n  // succeed, so we need to set a reasonable maximum.\n  private static readonly MAX_HOLD_BEFORE_PROBE_MS = 30000;\n  private static readonly MAX_ALLOWED_PROBE_TIME_MS = 60000;\n  // Occasionally we see that on unpause or upgrade we see a single packet lost\n  // or two, even in completely unconstrained scenarios. We should look into\n  // why this occurs on the backend, but for now we require a non-trivial\n  // amount of packets lost to fail the probe. These could also be from\n  // other senders given we don't yet use TWCC.\n  private static readonly SPURIOUS_PACKET_LOST_THRESHOLD = 2;\n  // See usage\n  private static readonly USED_BANDWIDTH_OVERRIDE_BUFFER_KBPS = 100;\n\n  protected tileController: VideoTileController | undefined;\n  protected videoPreferences: VideoPreferences | undefined;\n  protected defaultVideoPreferences: VideoPreferences | undefined;\n  protected shouldPauseTiles: boolean = true;\n  protected videoIndex: VideoStreamIndex;\n  protected videoPreferencesUpdated: boolean;\n  protected observerQueue: Set<VideoDownlinkObserver> = new Set<VideoDownlinkObserver>();\n  private logCount: number;\n  private optimalNonPausedReceiveStreams: VideoStreamDescription[];\n  private optimalReceiveStreams: VideoStreamDescription[];\n  private optimalReceiveSet: VideoStreamIdSet;\n  private subscribedReceiveSet: VideoStreamIdSet;\n  private subscribedReceiveStreams: VideoStreamDescription[];\n  private preProbeReceiveStreams: VideoStreamDescription[];\n  private preProbeNonPausedReceiveStreams: VideoStreamDescription[];\n  private pausedStreamIds: VideoStreamIdSet;\n  private pausedBwAttendeeIds: Set<string> = new Set<string>();\n  private downlinkStats: LinkMediaStats;\n  private prevDownlinkStats: LinkMediaStats;\n  // This list only contains the `VideoStreamDescription` for sources\n  // from attendees that we actually have preferences for.\n  private previousStreamsWithPreference: VideoStreamDescription[];\n  private rateProbeState: RateProbeState;\n  private startupPeriod: boolean;\n  private usingPrevTargetRate: boolean;\n  private prevTargetRateKbps: number;\n  // A target rate baseline to use to avoid changing the subscriptions until we see\n  // a `TARGET_RATE_CHANGE_TRIGGER_PERCENT` change between this and the current target rate\n  private targetRateBaselineForDeltaCheckKbps: number;\n  private lastUpgradeRateKbps: number;\n  private firstEstimateTimestamp: number;\n  private lastSubscribeTimestamp: number;\n  private timeBeforeAllowSubscribeMs: number;\n  private probePendingStartTimestamp: number;\n  private timeBeforeAllowProbeMs: number;\n  private lastProbeTimestamp: number;\n  private probeFailed: boolean;\n  // When server side video adaption is enabled, We simply use `AllHighestVideoBandwidthPolicy` to populate stream IDs which\n  // are still needed for the subscribe. It does not imply that we are overriding\n  // the server side logic, as it will immediately be overwritten by the\n  // values provided by `getVideoPreferences`\n  private allHighestPolicy: AllHighestVideoBandwidthPolicy;\n  private serverSideNetworkAdaption: ServerSideNetworkAdaption;\n  // After video preference is updated, track if we acted accordingly (resubscribe or pass perefernce to server).\n  // Required if enabled server side bandwith probing (w/ or w/o quality adaption).\n  private pendingActionAfterUpdatedPreferences: boolean;\n  private wantsResubscribeObserver: (() => void) | undefined = undefined;\n\n  constructor(\n    protected logger: Logger,\n    private videoPriorityBasedPolicyConfig: VideoPriorityBasedPolicyConfig = VideoPriorityBasedPolicyConfig.Default\n  ) {\n    if (\n      this.videoPriorityBasedPolicyConfig.serverSideNetworkAdaption ===\n      ServerSideNetworkAdaption.Default\n    ) {\n      this.videoPriorityBasedPolicyConfig.serverSideNetworkAdaption =\n        ServerSideNetworkAdaption.BandwidthProbingAndRemoteVideoQualityAdaption;\n    }\n    this.reset();\n  }\n\n  reset(): void {\n    // Self-attendee is not actually necessary in 'AllHighestVideoBandwidthPolicy' since it just passes it to\n    // `highestQualityStreamFromEachGroupExcludingSelf` which itself doesn't need it as self attendees are not in the\n    // index\n    this.allHighestPolicy = new AllHighestVideoBandwidthPolicy('');\n    this.optimalReceiveSet = new DefaultVideoStreamIdSet();\n    this.optimalReceiveStreams = [];\n    this.optimalNonPausedReceiveStreams = [];\n    this.subscribedReceiveSet = new DefaultVideoStreamIdSet();\n    this.subscribedReceiveStreams = [];\n    this.videoPreferences = undefined;\n    this.defaultVideoPreferences = undefined;\n    this.shouldPauseTiles = true;\n    this.pausedStreamIds = new DefaultVideoStreamIdSet();\n    this.pausedBwAttendeeIds = new Set<string>();\n    this.videoPreferencesUpdated = false;\n    this.logCount = 0;\n    this.startupPeriod = true;\n    this.usingPrevTargetRate = false;\n    this.rateProbeState = RateProbeState.NotProbing;\n    this.firstEstimateTimestamp = 0;\n    this.lastUpgradeRateKbps = 0;\n    this.timeBeforeAllowSubscribeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS;\n    this.lastProbeTimestamp = Date.now();\n    this.timeBeforeAllowProbeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS;\n    this.downlinkStats = new LinkMediaStats();\n    this.prevDownlinkStats = new LinkMediaStats();\n    this.probeFailed = false;\n    this.serverSideNetworkAdaption = this.videoPriorityBasedPolicyConfig.serverSideNetworkAdaption;\n    this.pendingActionAfterUpdatedPreferences = false;\n  }\n\n  bindToTileController(tileController: VideoTileController): void {\n    this.tileController = tileController;\n    this.logger.info('tileController bound');\n  }\n\n  setWantsResubscribeObserver?(observer: () => void): void {\n    this.wantsResubscribeObserver = observer;\n  }\n\n  // This function allows setting preferences without the need to inherit from this class\n  // which would require not using the internal keyword\n\n  chooseRemoteVideoSources(preferences: VideoPreferences): void {\n    if (this.videoPreferences?.equals(preferences)) {\n      return;\n    }\n    this.videoPreferences = preferences?.clone();\n    if (!serverSideNetworkAdaptionIsNoneOrDefault(this.serverSideNetworkAdaption)) {\n      this.pendingActionAfterUpdatedPreferences = true;\n      if (this.wantsResubscribeObserver !== undefined) {\n        this.wantsResubscribeObserver();\n        this.pendingActionAfterUpdatedPreferences = false;\n      }\n      if (\n        this.serverSideNetworkAdaption ===\n        ServerSideNetworkAdaption.BandwidthProbingAndRemoteVideoQualityAdaption\n      ) {\n        const desiredVideoSources = new Array<VideoSource>();\n        for (const preference of this.videoPreferences) {\n          const source = new VideoSource();\n          source.attendee = new Attendee();\n          source.attendee.attendeeId = preference.attendeeId;\n          desiredVideoSources.push(source);\n        }\n        this.allHighestPolicy.chooseRemoteVideoSources(desiredVideoSources);\n        return;\n      }\n    }\n    this.videoPreferencesUpdated = true;\n    this.logger.info(\n      `bwe: setVideoPreferences bwe: new preferences: ${JSON.stringify(preferences)}`\n    );\n    return;\n  }\n\n  updateIndex(videoIndex: VideoStreamIndex): void {\n    this.videoIndex = videoIndex;\n    if (\n      this.serverSideNetworkAdaption ===\n      ServerSideNetworkAdaption.BandwidthProbingAndRemoteVideoQualityAdaption\n    ) {\n      this.allHighestPolicy.updateIndex(videoIndex);\n    }\n    if (!this.videoPreferences) {\n      this.updateDefaultVideoPreferences();\n    }\n  }\n\n  private updateDefaultVideoPreferences(): void {\n    const attendeeIds = new Set<string>();\n    for (const stream of this.videoIndex.remoteStreamDescriptions()) {\n      attendeeIds.add(stream.attendeeId);\n    }\n\n    const prefs = VideoPreferences.prepare();\n\n    const numAttendees = attendeeIds.size;\n    let targetDisplaySize = TargetDisplaySize.Maximum;\n\n    if (numAttendees > 8) {\n      targetDisplaySize = TargetDisplaySize.Low;\n    } else if (numAttendees > 4) {\n      targetDisplaySize = TargetDisplaySize.Medium;\n    }\n\n    for (const attendeeId of attendeeIds) {\n      prefs.add(new VideoPreference(attendeeId, 1, targetDisplaySize));\n    }\n    this.defaultVideoPreferences = prefs.build();\n  }\n\n  updateMetrics(clientMetricReport: ClientMetricReport): void {\n    if (!this.videoIndex || this.videoIndex.allStreams().empty()) {\n      return;\n    }\n    this.prevDownlinkStats = this.downlinkStats;\n    this.downlinkStats = new LinkMediaStats();\n    const metricReport = clientMetricReport.getObservableMetrics();\n\n    // availableIncomingBitrate is the standard stat but is not available in Firefox yet so only Safari for now.\n    this.downlinkStats.bandwidthEstimateKbps = metricReport.availableIncomingBitrate / 1000;\n\n    for (const ssrcStr in clientMetricReport.streamMetricReports) {\n      const ssrc = Number.parseInt(ssrcStr, 10);\n      const metrics = clientMetricReport.streamMetricReports[ssrc];\n      if (metrics.direction === Direction.DOWNSTREAM && metrics.mediaType === MediaType.VIDEO) {\n        // Only use video stream metrics\n        if (metrics.currentMetrics.hasOwnProperty('nackCount')) {\n          this.downlinkStats.nackCount += clientMetricReport.countPerSecond('nackCount', ssrc);\n        }\n\n        if (metrics.currentMetrics.hasOwnProperty('packetsLost')) {\n          this.downlinkStats.packetsLost += clientMetricReport.countPerSecond('packetsLost', ssrc);\n        }\n\n        if (metrics.currentMetrics.hasOwnProperty('bytesReceived')) {\n          this.downlinkStats.usedBandwidthKbps +=\n            clientMetricReport.bitsPerSecond('bytesReceived', ssrc) / 1000;\n        }\n      }\n    }\n  }\n\n  wantsResubscribe(): boolean {\n    let wants = false;\n    if (!serverSideNetworkAdaptionIsNoneOrDefault(this.serverSideNetworkAdaption)) {\n      wants ||= this.pendingActionAfterUpdatedPreferences;\n      if (\n        this.serverSideNetworkAdaption ===\n        ServerSideNetworkAdaption.BandwidthProbingAndRemoteVideoQualityAdaption\n      ) {\n        return wants || this.allHighestPolicy.wantsResubscribe();\n      }\n    }\n    this.calculateOptimalReceiveSet();\n    wants ||= !this.subscribedReceiveSet.equal(this.optimalReceiveSet);\n    return wants;\n  }\n\n  chooseSubscriptions(): VideoStreamIdSet {\n    if (!serverSideNetworkAdaptionIsNoneOrDefault(this.serverSideNetworkAdaption)) {\n      this.pendingActionAfterUpdatedPreferences = false;\n      if (\n        this.serverSideNetworkAdaption ===\n        ServerSideNetworkAdaption.BandwidthProbingAndRemoteVideoQualityAdaption\n      ) {\n        return this.allHighestPolicy.chooseSubscriptions();\n      }\n    }\n    if (!this.subscribedReceiveSet.equal(this.optimalReceiveSet)) {\n      this.lastSubscribeTimestamp = Date.now();\n    }\n    this.subscribedReceiveSet = this.optimalReceiveSet.clone();\n    this.subscribedReceiveStreams = this.optimalReceiveStreams.slice();\n    return this.subscribedReceiveSet.clone();\n  }\n\n  addObserver(observer: VideoDownlinkObserver): void {\n    this.observerQueue.add(observer);\n  }\n\n  removeObserver(observer: VideoDownlinkObserver): void {\n    this.observerQueue.delete(observer);\n  }\n\n  forEachObserver(observerFunc: (observer: VideoDownlinkObserver) => void): void {\n    for (const observer of this.observerQueue) {\n      observerFunc(observer);\n    }\n  }\n\n  setVideoPriorityBasedPolicyConfigs(config: VideoPriorityBasedPolicyConfig): void {\n    this.videoPriorityBasedPolicyConfig = config;\n  }\n\n  protected calculateOptimalReceiveStreams(): void {\n    const chosenStreams: VideoStreamDescription[] = [];\n    const remoteInfos: VideoStreamDescription[] = this.videoIndex.remoteStreamDescriptions();\n    if (remoteInfos.length === 0 || this.videoPreferences?.isEmpty()) {\n      this.optimalReceiveStreams = [];\n      return;\n    }\n\n    const lastProbeState = this.rateProbeState;\n    this.cleanBwPausedTiles(remoteInfos);\n    this.handleAppPausedStreams(chosenStreams, remoteInfos);\n\n    const attendeeIdToPreference = new Map<string, VideoPreference>();\n    for (const preference of this.getCurrentVideoPreferences()) {\n      attendeeIdToPreference.set(preference.attendeeId, preference);\n    }\n    // We can pre-emptively filter to just remote stream descriptions for remote video sources we already\n    // have configuration for. We do not care about streams we aren't going to subscribe to.\n    const remoteInfosWithPreference = remoteInfos.filter((stream: VideoStreamDescription) => {\n      return attendeeIdToPreference.has(stream.attendeeId);\n    });\n\n    const sameStreamChoices = !this.streamsWithPreferenceDidChange(remoteInfosWithPreference);\n    const noMajorChange = !this.startupPeriod && sameStreamChoices;\n\n    // If no major changes then don't allow subscribes for the allowed amount of time\n    if (\n      noMajorChange &&\n      Date.now() - this.lastSubscribeTimestamp < this.timeBeforeAllowSubscribeMs\n    ) {\n      return;\n    }\n\n    // Sort streams by bitrate ascending.\n    remoteInfosWithPreference.sort((a, b) => {\n      if (a.maxBitrateKbps === b.maxBitrateKbps) {\n        return a.streamId - b.streamId;\n      }\n      return a.maxBitrateKbps - b.maxBitrateKbps;\n    });\n\n    // Convert 0 avg bitrates to max, handle special cases, and remove upgrades that downgrade resolution or framerate\n    for (const info of remoteInfosWithPreference) {\n      if (info.avgBitrateKbps === 0 || info.avgBitrateKbps > info.maxBitrateKbps) {\n        // Content can be a special case\n        if (info.attendeeId.endsWith(ContentShareConstants.Modality) && info.maxBitrateKbps < 100) {\n          info.maxBitrateKbps = info.avgBitrateKbps;\n        } else {\n          info.avgBitrateKbps = info.maxBitrateKbps;\n        }\n      }\n    }\n\n    const streamIdsToRemove = new Set<number>();\n    for (const preference of this.getCurrentVideoPreferences()) {\n      const streamsForAttendees = remoteInfosWithPreference.filter(\n        (description: VideoStreamDescription) => {\n          return description.attendeeId === preference.attendeeId;\n        }\n      );\n      if (streamsForAttendees.length < 3) {\n        // If `streamsForAttendees.length` is 0, they are stale preference for remote video that no longer exists\n        // if 1 or 2, there is nothing to filter out\n        continue;\n      }\n      let maxFrameRate = 15;\n      let maxPixels = 320 * 480;\n      streamsForAttendees.forEach((stream: VideoStreamDescription) => {\n        maxFrameRate = Math.max(maxFrameRate, stream.maxFrameRate);\n        maxPixels = Math.max(maxPixels, stream.totalPixels());\n      });\n      streamsForAttendees.sort((a: VideoStreamDescription, b: VideoStreamDescription) => {\n        if (\n          preference.degradationPreference === VideoQualityAdaptationPreference.MaintainResolution\n        ) {\n          // This may seem counter-intuitive but given we want to upgrade resolution first, and framerate\n          // last, we want to sort by framerate first, and resolution only if framerate is close.\n          //\n          // That way, e.g. the first three streams will all contain increases in resolution. We will skip any down\n          // grades in resolution (i.e. to hop to a higher framerate stream) in the section below\n          if (Math.abs(a.maxFrameRate - b.maxFrameRate) < 2) {\n            return a.totalPixels() - b.totalPixels();\n          }\n          return a.maxFrameRate - b.maxFrameRate;\n        } else if (\n          preference.degradationPreference === VideoQualityAdaptationPreference.MaintainFramerate\n        ) {\n          // See note above, but swap resolution for framerate\n          if (a.totalPixels() === b.totalPixels()) {\n            return a.maxFrameRate - b.maxFrameRate;\n          }\n          return a.totalPixels() - b.totalPixels();\n        } else {\n          // In 'balanced' mode, we want a slight preference towards upgrading resolution first\n          // when moving up the bitrate ladder, so we weigh the bitrate by a framerate\n          // and resolution derived value that is tuned to be reasonable in most cases. This attempts to\n          // mimic the diagrams in the guide.\n          //\n          // A higher constant makes the policy prefer resolution to framerate more at lower values\n          const framerateExponentConstant = 5;\n          // A higher constant here makes the policy prefer framerate to resolution more at higher values\n          const resolutionBaseConstant = 2;\n          const weighByFramerate = (stream: VideoStreamDescription): number => {\n            return (\n              stream.avgBitrateKbps *\n              Math.pow(\n                2,\n                ((framerateExponentConstant * stream.maxFrameRate) / maxFrameRate) *\n                  Math.pow(resolutionBaseConstant * 2, stream.totalPixels() / maxPixels)\n              )\n            );\n          };\n          return weighByFramerate(a) - weighByFramerate(b);\n        }\n      });\n\n      let lastInfo = undefined;\n      // Downgrades during recovery are unusual and jarring. Here we will strip out any (these should result in paths that\n      // match those in the priority downlink policy guide).\n      for (const info of streamsForAttendees) {\n        if (lastInfo !== undefined) {\n          if (\n            (info.maxFrameRate < lastInfo.maxFrameRate &&\n              Math.abs(lastInfo.maxFrameRate - info.maxFrameRate) > 2) ||\n            info.totalPixels() < lastInfo.totalPixels()\n          ) {\n            streamIdsToRemove.add(info.streamId);\n            continue;\n          }\n        }\n        lastInfo = info;\n      }\n    }\n    const filteredRemoteAttendeesWithPreference = remoteInfosWithPreference.filter(\n      (info: VideoStreamDescription) => {\n        return !streamIdsToRemove.has(info.streamId);\n      }\n    );\n    this.logger.info(`Filtered to ${JSON.stringify(filteredRemoteAttendeesWithPreference)}`);\n\n    const rates: PolicyRates = {\n      targetDownlinkBitrate: 0,\n      chosenTotalBitrate: 0,\n      deltaToNextUpgrade: 0,\n    };\n    rates.targetDownlinkBitrate = this.determineTargetRate();\n\n    const numberOfParticipants = this.subscribedReceiveSet.size();\n    const currentEstimated = this.downlinkStats.bandwidthEstimateKbps;\n\n    // Use videoPriorityBasedPolicyConfig to add additional delays based on network conditions\n    const dontAllowSubscribe = !this.videoPriorityBasedPolicyConfig.allowSubscribe(\n      numberOfParticipants,\n      currentEstimated\n    );\n\n    // `priorityPolicy` assumes that we have sorted `filteredRemoteAttendeesWithPreference` in order of quality\n    if (this.probeFailed) {\n      // When probe failed, we set timeBeforeAllowSubscribeMs to 3x longer\n      // Since we have passed the subscribe interval now, we will try to probe again\n      this.probeFailed = false;\n      // For the same reason above, reset time before allow subscribe to default\n      this.timeBeforeAllowSubscribeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS;\n\n      if (noMajorChange && dontAllowSubscribe) return;\n    }\n\n    const upgradeStream: VideoStreamDescription = this.priorityPolicy(\n      rates,\n      filteredRemoteAttendeesWithPreference,\n      chosenStreams\n    );\n\n    const skipProbe = !serverSideNetworkAdaptionIsNoneOrDefault(this.serverSideNetworkAdaption);\n    let subscriptionChoice = UseReceiveSet.NewOptimal;\n    // Look for probing or override opportunities\n    if (!skipProbe && !this.startupPeriod && sameStreamChoices) {\n      if (this.rateProbeState === RateProbeState.Probing) {\n        subscriptionChoice = this.handleProbe(chosenStreams, rates.targetDownlinkBitrate);\n      } else if (rates.deltaToNextUpgrade !== 0) {\n        subscriptionChoice = this.maybeOverrideOrProbe(chosenStreams, rates, upgradeStream);\n      }\n    } else {\n      // If there was a change in streams to choose from, then cancel any probing or upgrades\n      this.setProbeState(RateProbeState.NotProbing);\n      this.lastUpgradeRateKbps = 0;\n    }\n\n    this.previousStreamsWithPreference = remoteInfosWithPreference;\n    this.videoPreferencesUpdated = false;\n\n    if (subscriptionChoice === UseReceiveSet.PreviousOptimal) {\n      this.logger.info(`bwe: keepSameSubscriptions stats:${JSON.stringify(this.downlinkStats)}`);\n      this.prevTargetRateKbps = rates.targetDownlinkBitrate;\n      return;\n    }\n    if (subscriptionChoice === UseReceiveSet.PreProbe) {\n      const subscribedRate = this.calculateSubscribeRate(this.preProbeNonPausedReceiveStreams);\n      this.optimalReceiveStreams = this.preProbeReceiveStreams.slice();\n      this.processBwPausedStreams(remoteInfosWithPreference, this.preProbeNonPausedReceiveStreams);\n      this.logger.info('bwe: Use Pre-Probe subscription subscribedRate:' + subscribedRate);\n      return;\n    }\n\n    this.optimalNonPausedReceiveStreams = chosenStreams.slice();\n    const lastNumberPaused = this.pausedBwAttendeeIds.size;\n    this.processBwPausedStreams(remoteInfosWithPreference, chosenStreams);\n\n    if (\n      this.logger.getLogLevel() <= LogLevel.INFO &&\n      (this.logCount % 15 === 0 ||\n        this.rateProbeState !== lastProbeState ||\n        this.optimalReceiveStreams.length !== chosenStreams.length ||\n        lastNumberPaused !== this.pausedBwAttendeeIds.size)\n    ) {\n      this.logger.info(this.policyStateLogStr(remoteInfos, rates.targetDownlinkBitrate));\n      this.logCount = 0;\n    }\n    this.logCount++;\n\n    this.prevTargetRateKbps = rates.targetDownlinkBitrate;\n    this.optimalReceiveStreams = chosenStreams.slice();\n  }\n\n  protected calculateOptimalReceiveSet(): void {\n    const streamSelectionSet = new DefaultVideoStreamIdSet();\n    this.calculateOptimalReceiveStreams();\n    for (const stream of this.optimalReceiveStreams) {\n      streamSelectionSet.add(stream.streamId);\n    }\n    if (!this.optimalReceiveSet.equal(streamSelectionSet)) {\n      const subscribedRate = this.calculateSubscribeRate(this.optimalReceiveStreams);\n      this.logger.info(\n        `bwe: new streamSelection: ${JSON.stringify(\n          streamSelectionSet\n        )} subscribedRate:${subscribedRate}`\n      );\n    }\n    this.optimalReceiveSet = streamSelectionSet;\n  }\n\n  private determineTargetRate(): number {\n    let targetBitrate = 0;\n\n    const now = Date.now();\n    // Startup phase handling.  During this period the estimate can be 0 or\n    // could still be slowly hunting for a steady state.  This startup ramp up\n    // can cause a series of subscribes which can be distracting. During this\n    // time just use our configured default value\n    if (this.downlinkStats.bandwidthEstimateKbps !== 0) {\n      if (this.firstEstimateTimestamp === 0) {\n        this.firstEstimateTimestamp = now;\n      }\n\n      // handle startup state where estimator is still converging.\n      if (this.startupPeriod) {\n        // Drop out of startup period if\n        // - estimate is above default\n        // - get packet loss and have a valid estimate\n        // - startup period has expired and rate is not still increasing\n        if (\n          this.downlinkStats.bandwidthEstimateKbps >\n            VideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS ||\n          this.downlinkStats.packetsLost > 0 ||\n          (now - this.firstEstimateTimestamp > VideoPriorityBasedPolicy.STARTUP_PERIOD_MS &&\n            this.downlinkStats.bandwidthEstimateKbps <=\n              this.prevDownlinkStats.bandwidthEstimateKbps)\n        ) {\n          this.startupPeriod = false;\n          this.prevTargetRateKbps = this.downlinkStats.bandwidthEstimateKbps;\n        }\n      }\n      // If we are in the startup period and we haven't detected any packet loss, then\n      // keep it at the default to let the estimation get to a steady state\n      if (this.startupPeriod) {\n        targetBitrate = VideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        // We rely on our target bitrate being above what we are receiving to mark a probe as complete,\n        // however in browsers, the estimate can heavily lag behind the actual receive rate, especially when low.\n        //\n        // To mitigate this we override with the actual estimate plus some buffer if we aren't seeing packet loss.\n        if (\n          this.rateProbeState === RateProbeState.Probing &&\n          this.downlinkStats.usedBandwidthKbps > this.downlinkStats.bandwidthEstimateKbps &&\n          this.downlinkStats.packetsLost < VideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD\n        ) {\n          this.logger.info(\n            `bwe: In probe state, overriding estimate ${this.downlinkStats.bandwidthEstimateKbps} with actual receive bitrate ${this.downlinkStats.usedBandwidthKbps}`\n          );\n          targetBitrate =\n            this.downlinkStats.usedBandwidthKbps +\n            VideoPriorityBasedPolicy.USED_BANDWIDTH_OVERRIDE_BUFFER_KBPS;\n        } else {\n          targetBitrate = this.downlinkStats.bandwidthEstimateKbps;\n        }\n      }\n    } else {\n      if (this.firstEstimateTimestamp === 0) {\n        targetBitrate = VideoPriorityBasedPolicy.DEFAULT_BANDWIDTH_KBPS;\n      } else {\n        targetBitrate = this.prevTargetRateKbps;\n      }\n    }\n\n    // Estimated downlink rate can follow actual bandwidth or fall for a short period of time\n    // due to the absolute send time estimator incorrectly thinking that a delay in packets is\n    // a precursor to packet loss.  We have seen too many false positives on this, so we\n    // will ignore largish drops in the estimate if there is no packet loss\n    if (\n      !this.startupPeriod &&\n      ((this.usingPrevTargetRate &&\n        this.downlinkStats.bandwidthEstimateKbps < this.prevTargetRateKbps) ||\n        this.downlinkStats.bandwidthEstimateKbps <\n          (this.prevTargetRateKbps *\n            (100 - VideoPriorityBasedPolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT)) /\n            100 ||\n        this.downlinkStats.bandwidthEstimateKbps <\n          (this.downlinkStats.usedBandwidthKbps *\n            VideoPriorityBasedPolicy.LARGE_RATE_CHANGE_TRIGGER_PERCENT) /\n            100) &&\n      this.downlinkStats.packetsLost === 0\n    ) {\n      // Set target to be the same as last\n      this.logger.debug(() => {\n        return 'bwe: ValidateRate: Using Previous rate ' + this.prevTargetRateKbps;\n      });\n      this.usingPrevTargetRate = true;\n      targetBitrate = this.prevTargetRateKbps;\n    } else {\n      this.usingPrevTargetRate = false;\n    }\n\n    // Cap total receive bitrate at 15000 kbps\n    if (targetBitrate > 15000) {\n      this.logger.warn(\n        'bwe: ' +\n          targetBitrate +\n          ' exceeds maximum limit (15000). Limit TargetDisplaySize with VideoPreferences to avoid this.'\n      );\n    }\n    return Math.min(targetBitrate, 15000);\n  }\n\n  private setProbeState(newState: RateProbeState): boolean {\n    if (this.rateProbeState === newState) {\n      return false;\n    }\n\n    const now = Date.now();\n    switch (newState) {\n      case RateProbeState.NotProbing:\n        this.probePendingStartTimestamp = 0;\n        break;\n\n      case RateProbeState.ProbePending:\n        if (\n          this.lastProbeTimestamp === 0 ||\n          now - this.lastProbeTimestamp > VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS\n        ) {\n          this.probePendingStartTimestamp = now;\n        } else {\n          // Too soon to do a probe again\n          return false;\n        }\n        break;\n\n      case RateProbeState.Probing:\n        if (now - this.probePendingStartTimestamp > this.timeBeforeAllowProbeMs) {\n          this.lastProbeTimestamp = now;\n          this.preProbeReceiveStreams = this.subscribedReceiveStreams.slice();\n          this.preProbeNonPausedReceiveStreams = this.optimalNonPausedReceiveStreams;\n          // Increase the time allowed until the next probe\n          this.timeBeforeAllowProbeMs = Math.min(\n            this.timeBeforeAllowProbeMs * 2,\n            VideoPriorityBasedPolicy.MAX_HOLD_BEFORE_PROBE_MS\n          );\n        } else {\n          // Too soon to do probe\n          return false;\n        }\n        break;\n    }\n\n    this.logger.info('bwe: setProbeState to ' + newState + ' from ' + this.rateProbeState);\n    this.rateProbeState = newState;\n    return true;\n  }\n\n  // Upgrade the stream id from the appropriate group or add it if it wasn't already in the list.\n  // Return the added amount of bandwidth\n  private upgradeToStream(\n    chosenStreams: VideoStreamDescription[],\n    upgradeStream: VideoStreamDescription\n  ): number {\n    for (let i = 0; i < chosenStreams.length; i++) {\n      if (chosenStreams[i].groupId === upgradeStream.groupId) {\n        const diffRate = upgradeStream.avgBitrateKbps - chosenStreams[i].avgBitrateKbps;\n        this.logger.info(\n          'bwe: upgradeStream from ' + JSON.stringify(chosenStreams[i]) + ' to ' + upgradeStream\n        );\n        this.lastUpgradeRateKbps = diffRate;\n        chosenStreams[i] = upgradeStream;\n        return diffRate;\n      }\n    }\n\n    // We are adding a stream and not upgrading.\n    chosenStreams.push(upgradeStream);\n    this.lastUpgradeRateKbps = upgradeStream.avgBitrateKbps;\n    return this.lastUpgradeRateKbps;\n  }\n\n  // Do specific behavior while we are currently in probing state and metrics\n  // indicate environment is still valid to do probing.\n  // Return true if the caller should not change from the previous subscriptions.\n  private handleProbe(\n    chosenStreams: VideoStreamDescription[],\n    targetDownlinkBitrate: number\n  ): UseReceiveSet {\n    // Don't allow probe to happen indefinitely\n    if (Date.now() - this.lastProbeTimestamp > VideoPriorityBasedPolicy.MAX_ALLOWED_PROBE_TIME_MS) {\n      this.logger.info(`bwe: Canceling probe due to timeout`);\n      this.setProbeState(RateProbeState.NotProbing);\n      return UseReceiveSet.NewOptimal;\n    }\n\n    if (this.downlinkStats.packetsLost > 0) {\n      this.logger.info(`bwe: Probe encountering packets lost:${this.downlinkStats.packetsLost}`);\n      // See comment above `VideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD`\n      if (\n        this.downlinkStats.packetsLost > VideoPriorityBasedPolicy.SPURIOUS_PACKET_LOST_THRESHOLD\n      ) {\n        this.setProbeState(RateProbeState.NotProbing);\n        this.logger.info(\n          `bwe: Canceling probe due to packets lost:${this.downlinkStats.packetsLost}`\n        );\n        this.probeFailed = true;\n        this.timeBeforeAllowSubscribeMs =\n          Math.max(\n            VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_SUBSCRIBE_MS,\n            this.timeBeforeAllowSubscribeMs\n          ) * 3;\n        // packet lost indicates bad network and thus slowing down subscribing by extend delay by 3 times\n        return UseReceiveSet.PreProbe;\n      }\n    }\n    const subscribedRate = this.calculateSubscribeRate(this.optimalReceiveStreams);\n    if (this.chosenStreamsSameAsLast(chosenStreams) || targetDownlinkBitrate > subscribedRate) {\n      this.logger.info(`bwe: Probe successful`);\n      // If target bitrate can sustain probe rate, then probe was successful.\n      this.setProbeState(RateProbeState.NotProbing);\n      // Reset the time allowed between probes since this was successful\n      this.timeBeforeAllowProbeMs = VideoPriorityBasedPolicy.MIN_TIME_BETWEEN_PROBE_MS;\n      return UseReceiveSet.NewOptimal;\n    }\n\n    return UseReceiveSet.PreviousOptimal;\n  }\n\n  private maybeOverrideOrProbe(\n    chosenStreams: VideoStreamDescription[],\n    rates: PolicyRates,\n    upgradeStream: VideoStreamDescription\n  ): UseReceiveSet {\n    const sameSubscriptions = this.chosenStreamsSameAsLast(chosenStreams);\n    let useLastSubscriptions = UseReceiveSet.NewOptimal;\n\n    // We want to minimize thrashing between between low res and high res of different\n    // participants due to avg bitrate fluctuations. If there hasn't been much of a change in estimated bandwidth\n    // and the number of streams and their max rates are the same, then reuse the previous subscription\n    const triggerPercent =\n      rates.targetDownlinkBitrate > VideoPriorityBasedPolicy.LOW_BITRATE_THRESHOLD_KBPS\n        ? VideoPriorityBasedPolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT\n        : VideoPriorityBasedPolicy.TARGET_RATE_CHANGE_TRIGGER_PERCENT * 2;\n    const minTargetBitrateDelta = (rates.targetDownlinkBitrate * triggerPercent) / 100;\n    this.targetRateBaselineForDeltaCheckKbps =\n      this.targetRateBaselineForDeltaCheckKbps !== undefined\n        ? this.targetRateBaselineForDeltaCheckKbps\n        : this.prevTargetRateKbps;\n    if (\n      !sameSubscriptions &&\n      Math.abs(rates.targetDownlinkBitrate - this.targetRateBaselineForDeltaCheckKbps) <\n        minTargetBitrateDelta\n    ) {\n      this.logger.info(\n        'bwe: MaybeOverrideOrProbe: Reuse last decision based on delta rate. {' +\n          JSON.stringify(this.subscribedReceiveSet) +\n          `}`\n      );\n      useLastSubscriptions = UseReceiveSet.PreviousOptimal;\n    } else {\n      this.targetRateBaselineForDeltaCheckKbps = rates.targetDownlinkBitrate;\n    }\n\n    // If there has been packet loss, then reset to no probing state\n    if (this.downlinkStats.packetsLost > this.prevDownlinkStats.packetsLost) {\n      this.setProbeState(RateProbeState.NotProbing);\n      this.lastUpgradeRateKbps = 0;\n      return useLastSubscriptions;\n    }\n\n    if (sameSubscriptions || useLastSubscriptions === UseReceiveSet.PreviousOptimal) {\n      // If planned subscriptions are same as last, then either move to probe pending state\n      // or move to probing state if enough time has passed.\n      switch (this.rateProbeState) {\n        case RateProbeState.NotProbing:\n          this.setProbeState(RateProbeState.ProbePending);\n          break;\n\n        case RateProbeState.ProbePending:\n          if (this.setProbeState(RateProbeState.Probing)) {\n            this.upgradeToStream(chosenStreams, upgradeStream);\n            useLastSubscriptions = UseReceiveSet.NewOptimal;\n          }\n          break;\n      }\n    } else {\n      this.setProbeState(RateProbeState.NotProbing);\n    }\n\n    return useLastSubscriptions;\n  }\n\n  // Utility function to find max rate of streams in current decision\n  private calculateSubscribeRate(streams: VideoStreamDescription[]): number {\n    let subscribeRate = 0;\n\n    for (const stream of streams) {\n      if (\n        !this.pausedStreamIds.contain(stream.streamId) &&\n        !this.pausedBwAttendeeIds.has(stream.attendeeId)\n      ) {\n        subscribeRate += stream.maxBitrateKbps;\n      }\n    }\n\n    return subscribeRate;\n  }\n\n  private handleAppPausedStreams(\n    chosenStreams: VideoStreamDescription[],\n    remoteInfos: VideoStreamDescription[]\n  ): void {\n    if (!this.tileController) {\n      this.logger.warn('tileController not found!');\n      return;\n    }\n    this.pausedStreamIds = new DefaultVideoStreamIdSet();\n    const remoteTiles = this.tileController.getAllRemoteVideoTiles();\n    for (const tile of remoteTiles) {\n      const state = tile.state();\n      if (state.paused && !this.pausedBwAttendeeIds.has(state.boundAttendeeId)) {\n        let j = remoteInfos.length;\n        while (j--) {\n          if (remoteInfos[j].attendeeId === state.boundAttendeeId) {\n            this.logger.info(\n              'bwe: removed paused attendee ' +\n                state.boundAttendeeId +\n                ' streamId: ' +\n                remoteInfos[j].streamId\n            );\n            this.pausedStreamIds.add(remoteInfos[j].streamId);\n            // Add the stream to the selection set to keep the tile around\n            if (this.subscribedReceiveSet.contain(remoteInfos[j].streamId)) {\n              chosenStreams.push(remoteInfos[j]);\n            }\n            remoteInfos.splice(j, 1);\n          }\n        }\n      }\n    }\n  }\n\n  private processBwPausedStreams(\n    remoteInfos: VideoStreamDescription[],\n    chosenStreams: VideoStreamDescription[]\n  ): void {\n    if (!this.tileController) {\n      this.logger.warn('tileController not found!');\n      return;\n    }\n    const preferences = this.getCurrentVideoPreferences();\n    if (preferences && this.shouldPauseTiles) {\n      const videoTiles = this.tileController.getAllVideoTiles();\n      for (const preference of preferences) {\n        const videoTile = this.getVideoTileForAttendeeId(\n          preference.attendeeId,\n          videoTiles\n        ) as DefaultVideoTile;\n        const paused = videoTile?.state().paused || false;\n        if (!chosenStreams.some(stream => stream.attendeeId === preference.attendeeId)) {\n          // We cannot rely on the existance of video tile to indicate that the source exists in the call\n          // because tiles will not be added or removed until after a full renegotiation (i.e. it will\n          // be behind the state provided by the index)\n          const streamExists = remoteInfos.some(\n            stream => stream.attendeeId === preference.attendeeId\n          );\n          if (videoTile && streamExists) {\n            const info = this.optimalReceiveStreams.find(\n              stream => stream.attendeeId === preference.attendeeId\n            );\n            if (info !== undefined) {\n              if (!paused) {\n                this.logger.info(\n                  `bwe: pausing streamId ${info.streamId} attendee ${preference.attendeeId} due to bandwidth`\n                );\n                this.forEachObserver(observer => {\n                  observer.tileWillBePausedByDownlinkPolicy(videoTile.id());\n                });\n                this.tileController.pauseVideoTile(videoTile.id());\n              }\n              chosenStreams.push(info);\n            }\n            this.pausedBwAttendeeIds.add(preference.attendeeId);\n          } else if (streamExists) {\n            // Create a tile for this participant if one doesn't already exist and mark it as paused\n            // Don't include it in the chosen streams because we don't want to subscribe for it then have to pause it.\n            const newTile = this.tileController.addVideoTile();\n            newTile.bindVideoStream(preference.attendeeId, false, null, 0, 0, 0, null);\n            this.forEachObserver(observer => {\n              observer.tileWillBePausedByDownlinkPolicy(newTile.id());\n            });\n            newTile.pause();\n            this.logger.info(\n              `bwe: Created video tile ${newTile.id()} for bw paused attendee ${\n                preference.attendeeId\n              }`\n            );\n            this.pausedBwAttendeeIds.add(preference.attendeeId);\n          }\n        } else if (paused && this.pausedBwAttendeeIds.has(preference.attendeeId)) {\n          this.logger.info(`bwe: unpausing attendee ${preference.attendeeId} due to bandwidth`);\n          this.forEachObserver(observer => {\n            observer.tileWillBeUnpausedByDownlinkPolicy(videoTile.id());\n          });\n          this.tileController.unpauseVideoTile(videoTile.id());\n          this.pausedBwAttendeeIds.delete(preference.attendeeId);\n        }\n      }\n    }\n  }\n\n  private cleanBwPausedTiles(remoteInfos: VideoStreamDescription[]): void {\n    if (!this.tileController) {\n      this.logger.warn('tileController not found!');\n      return;\n    }\n    const tiles = this.tileController.getAllRemoteVideoTiles();\n    const preferences = this.getCurrentVideoPreferences();\n    for (const tile of tiles) {\n      const state = tile.state();\n      if (!state.boundVideoStream) {\n        if (!remoteInfos.some(stream => stream.attendeeId === state.boundAttendeeId)) {\n          this.tileController.removeVideoTile(state.tileId);\n          this.logger.info(\n            `bwe: Removed video tile ${state.tileId} for bw paused attendee ${state.boundAttendeeId}`\n          );\n        } else if (\n          preferences !== undefined &&\n          !preferences.some(pref => pref.attendeeId === state.boundAttendeeId)\n        ) {\n          this.tileController.removeVideoTile(state.tileId);\n        }\n      }\n    }\n  }\n\n  // `remoteInfos` is assumed to be provided in order of increasing quality\n  private priorityPolicy(\n    rates: PolicyRates,\n    remoteInfos: VideoStreamDescription[],\n    chosenStreams: VideoStreamDescription[]\n  ): VideoStreamDescription {\n    let upgradeStream: VideoStreamDescription;\n    const videoPreferences: VideoPreferences = this.getCurrentVideoPreferences();\n\n    const highestPriority = videoPreferences.highestPriority();\n    let nextPriority;\n    let priority = highestPriority;\n    while (priority !== -1) {\n      nextPriority = -1;\n      for (const preference of videoPreferences) {\n        if (preference.priority === priority) {\n          // First subscribe to at least low rate\n          for (const info of remoteInfos) {\n            if (info.attendeeId === preference.attendeeId) {\n              if (!chosenStreams.some(stream => stream.groupId === info.groupId)) {\n                if (rates.chosenTotalBitrate + info.avgBitrateKbps <= rates.targetDownlinkBitrate) {\n                  chosenStreams.push(info);\n                  rates.chosenTotalBitrate += info.avgBitrateKbps;\n                } else if (rates.deltaToNextUpgrade === 0) {\n                  // Keep track of step to next upgrade\n                  rates.deltaToNextUpgrade = info.avgBitrateKbps;\n                  upgradeStream = info;\n                }\n              }\n            }\n          }\n        } else {\n          if (preference.priority > priority) {\n            nextPriority = preference.priority;\n            break;\n          }\n        }\n      }\n\n      // Now try to upgrade all attendee's with this priority\n      for (const preference of videoPreferences) {\n        if (preference.priority === priority) {\n          for (const info of remoteInfos) {\n            if (info.attendeeId === preference.attendeeId) {\n              const index = chosenStreams.findIndex(\n                stream =>\n                  stream.groupId === info.groupId &&\n                  stream.maxBitrateKbps <= info.maxBitrateKbps &&\n                  stream.avgBitrateKbps < info.avgBitrateKbps\n              );\n              if (index !== -1) {\n                const increaseKbps = info.avgBitrateKbps - chosenStreams[index].avgBitrateKbps;\n                if (\n                  this.hasSimulcastStreams(remoteInfos, info.attendeeId, info.groupId) &&\n                  this.canUpgrade(\n                    info.avgBitrateKbps,\n                    preference.targetSize,\n                    preference.targetSizeToBitrateKbps(preference.targetSize),\n                    info.attendeeId.endsWith(ContentShareConstants.Modality)\n                  )\n                ) {\n                  this.logger.info(\n                    `bwe: attendee: ${info.attendeeId} group: ${\n                      info.groupId\n                    } has simulcast and can upgrade avgBitrate: ${\n                      info.avgBitrateKbps\n                    } target: ${preference.targetSizeToBitrateKbps(\n                      preference.targetSize\n                    )} targetTotalBitrate: ${rates.targetDownlinkBitrate}`\n                  );\n                  if (rates.chosenTotalBitrate + increaseKbps <= rates.targetDownlinkBitrate) {\n                    rates.chosenTotalBitrate += increaseKbps;\n                    chosenStreams[index] = info;\n                  } else if (rates.deltaToNextUpgrade === 0) {\n                    // Keep track of step to next upgrade\n                    rates.deltaToNextUpgrade = increaseKbps;\n                    upgradeStream = info;\n                  }\n                } else {\n                  this.logger.info('bwe: cannot upgrade stream quality beyond target size');\n                }\n              }\n            }\n          }\n        } else {\n          if (preference.priority > priority) {\n            break;\n          }\n        }\n      }\n\n      // If we haven't subscribed to the highest rate of the top priority videos then\n      // do not subscribe to any other sources\n      if (priority === highestPriority && rates.deltaToNextUpgrade !== 0) {\n        break;\n      }\n      priority = nextPriority;\n    }\n    return upgradeStream;\n  }\n\n  private getVideoTileForAttendeeId(attendeeId: string, videoTiles: VideoTile[]): VideoTile {\n    for (const tile of videoTiles) {\n      const state = tile.state();\n      if (state.boundAttendeeId === attendeeId) {\n        return tile;\n      }\n    }\n    return null;\n  }\n\n  private canUpgrade(\n    bitrateKbps: number,\n    targetResolution: TargetDisplaySize,\n    targetBitrateKbps: number,\n    isContent: boolean\n  ): boolean {\n    let canUpgrade = false;\n    // For both video and content, we want to interpret `TargetDisplaySize.High` as a request for the best quality\n    // video, and should ignore the value of the target bitrate.\n    if (targetResolution === TargetDisplaySize.High) {\n      // For both video and content, we want to interpret `TargetDisplaySize.High` as a request for the best quality\n      // video, and should ignore the value of the target bitrate.\n      canUpgrade = true;\n    } else if (!isContent && bitrateKbps <= targetBitrateKbps) {\n      // For content share, even if the higher quality stream has a high max bitrate of 1200 kbps for example\n      // the avg bitrate can be way lower so have to make sure that we do not update to a higher bitrate than the\n      // target value (i.e. if `targetResolution === TargetDisplaySize.Low`).\n      //\n      // This does not apply to video as video uplink bandwidth could change the max bitrate value without resubscribing\n      // so the max bitrate value might not be up-to-date on the downlink side. Also in the case of video, the avg\n      // bitrate is close to the actual max bitrate.\n      canUpgrade = true;\n    } else if (\n      isContent &&\n      targetResolution === TargetDisplaySize.Medium &&\n      bitrateKbps <= targetBitrateKbps\n    ) {\n      // If the target resolution is medium then fall back to use avg bitrate as video.\n      canUpgrade = true;\n    }\n    if (canUpgrade) {\n      this.logger.info(\n        `bwe: canUpgrade: bitrateKbps: ${bitrateKbps} targetBitrateKbps: ${targetBitrateKbps}`\n      );\n      return true;\n    }\n    this.logger.info(\n      `bwe: cannot Upgrade: bitrateKbps: ${bitrateKbps} targetBitrateKbps: ${targetBitrateKbps}`\n    );\n    return false;\n  }\n\n  private hasSimulcastStreams(\n    remoteInfos: VideoStreamDescription[],\n    attendeeId: string,\n    groupId: number\n  ): boolean {\n    let streamCount = 0;\n    for (const info of remoteInfos) {\n      if (info.attendeeId === attendeeId && info.groupId === groupId) {\n        streamCount++;\n      }\n    }\n    this.logger.info(\n      `bwe: attendeeId: ${attendeeId} groupId: ${groupId} hasSimulcastStreams: streamCount: ${streamCount}`\n    );\n    return streamCount > 1;\n  }\n\n  private streamsWithPreferenceDidChange(remoteInfos: VideoStreamDescription[]): boolean {\n    if (\n      this.previousStreamsWithPreference === undefined ||\n      remoteInfos.length !== this.previousStreamsWithPreference.length ||\n      this.videoPreferencesUpdated === true\n    ) {\n      return true;\n    }\n\n    for (const info of remoteInfos) {\n      const infoMatch = this.previousStreamsWithPreference.find(\n        prevInfo =>\n          prevInfo.groupId === info.groupId &&\n          prevInfo.streamId === info.streamId &&\n          prevInfo.maxBitrateKbps === info.maxBitrateKbps\n      );\n      if (infoMatch === undefined) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  private chosenStreamsSameAsLast(chosenStreams: VideoStreamDescription[]): boolean {\n    if (this.optimalNonPausedReceiveStreams.length !== chosenStreams.length) {\n      return false;\n    }\n    for (const lastStream of this.optimalNonPausedReceiveStreams) {\n      if (!chosenStreams.some(stream => stream.streamId === lastStream.streamId)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private policyStateLogStr(\n    remoteInfos: VideoStreamDescription[],\n    targetDownlinkBitrate: number\n  ): string {\n    const subscribedRate = this.calculateSubscribeRate(this.optimalReceiveStreams);\n    const optimalReceiveSet = {\n      targetBitrate: targetDownlinkBitrate,\n      subscribedRate: subscribedRate,\n      probeState: this.rateProbeState,\n      startupPeriod: this.startupPeriod,\n    };\n\n    // Reduced remote info logging:\n    let remoteInfoStr = `remoteInfos: [`;\n    for (const info of remoteInfos) {\n      remoteInfoStr += `{grpId:${info.groupId} strId:${info.streamId} maxBr:${info.maxBitrateKbps} avgBr:${info.avgBitrateKbps}}, `;\n    }\n    remoteInfoStr += `]`;\n\n    let logString =\n      `bwe: optimalReceiveSet ${JSON.stringify(optimalReceiveSet)}\\n` +\n      `bwe:   prev ${JSON.stringify(this.prevDownlinkStats)}\\n` +\n      `bwe:   now  ${JSON.stringify(this.downlinkStats)}\\n` +\n      `bwe:   ${remoteInfoStr}\\n`;\n\n    if (this.pausedStreamIds.size() > 0 || this.pausedBwAttendeeIds.size > 0) {\n      logString += `bwe:   paused: app stream ids ${JSON.stringify(\n        this.pausedStreamIds\n      )}  bw attendees { ${Array.from(this.pausedBwAttendeeIds).join(' ')} }\\n`;\n    }\n\n    if (this.videoPreferences) {\n      logString += `bwe:   preferences: ${JSON.stringify(this.videoPreferences)}`;\n    } else {\n      logString += `bwe:   default preferences: ${JSON.stringify(this.defaultVideoPreferences)}`;\n    }\n    return logString;\n  }\n\n  protected getCurrentVideoPreferences(): VideoPreferences {\n    return this.videoPreferences || this.defaultVideoPreferences;\n  }\n\n  getServerSideNetworkAdaption(): ServerSideNetworkAdaption {\n    return this.serverSideNetworkAdaption;\n  }\n\n  setServerSideNetworkAdaption(adaption: ServerSideNetworkAdaption): void {\n    this.serverSideNetworkAdaption = adaption;\n    this.setProbeState(RateProbeState.NotProbing); // In case we were probing\n  }\n\n  supportedServerSideNetworkAdaptions(): ServerSideNetworkAdaption[] {\n    return [\n      ServerSideNetworkAdaption.None,\n      ServerSideNetworkAdaption.BandwidthProbing,\n      ServerSideNetworkAdaption.BandwidthProbingAndRemoteVideoQualityAdaption,\n    ];\n  }\n\n  getVideoPreferences(): VideoPreferences {\n    let preferences = this.getCurrentVideoPreferences();\n    if (!preferences) {\n      const dummyPreferences = VideoPreferences.prepare();\n      // Can't be undefined, occasionally the audio video controller\n      // will call this function before the first index is received\n      preferences = dummyPreferences.build();\n    }\n    return preferences;\n  }\n\n  wantsAllTemporalLayersInIndex(): boolean {\n    return true;\n  }\n}\n"]}
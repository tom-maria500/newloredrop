{"version":3,"file":"StatsCollector.js","sourceRoot":"","sources":["../../src/statscollector/StatsCollector.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport AudioVideoController from '../audiovideocontroller/AudioVideoController';\nimport ClientMetricReport from '../clientmetricreport/ClientMetricReport';\nimport { CustomStatsReport } from '../clientmetricreport/ClientMetricReport';\nimport Direction from '../clientmetricreport/ClientMetricReportDirection';\nimport MediaType from '../clientmetricreport/ClientMetricReportMediaType';\nimport RedundantAudioRecoveryMetricReport from '../clientmetricreport/RedundantAudioRecoveryMetricReport';\nimport StreamMetricReport from '../clientmetricreport/StreamMetricReport';\nimport Logger from '../logger/Logger';\nimport MeetingSessionLifecycleEvent from '../meetingsession/MeetingSessionLifecycleEvent';\nimport MeetingSessionLifecycleEventCondition from '../meetingsession/MeetingSessionLifecycleEventCondition';\nimport MeetingSessionStatus from '../meetingsession/MeetingSessionStatus';\nimport RedundantAudioRecoveryMetricsObserver from '../redundantaudiorecoverymetricsobserver/RedundantAudioRecoveryMetricsObserver';\nimport IntervalScheduler from '../scheduler/IntervalScheduler';\nimport SignalingClient from '../signalingclient/SignalingClient';\nimport {\n  SdkClientMetricFrame,\n  SdkDimensionValue,\n  SdkMetric,\n  SdkStreamDimension,\n  SdkStreamMetricFrame,\n} from '../signalingprotocol/SignalingProtocol.js';\nimport { Maybe } from '../utils/Types';\nimport VideoStreamIndex from '../videostreamindex/VideoStreamIndex';\nimport AudioLogEvent from './AudioLogEvent';\nimport VideoLogEvent from './VideoLogEvent';\n\n// eslint-disable-next-line\ntype RawMetricReport = any;\n\n// eslint-disable-next-line\ntype StatsReportItem = any;\n\n/**\n * [[StatsCollector]] gathers statistics and sends metrics.\n */\nexport default class StatsCollector implements RedundantAudioRecoveryMetricsObserver {\n  private static readonly INTERVAL_MS = 1000;\n  private static readonly CLIENT_TYPE = 'amazon-chime-sdk-js';\n\n  private intervalScheduler: IntervalScheduler | null = null;\n  private signalingClient: SignalingClient;\n  private videoStreamIndex: VideoStreamIndex;\n  private clientMetricReport: ClientMetricReport;\n  private redRecoveryMetricReport: RedundantAudioRecoveryMetricReport = new RedundantAudioRecoveryMetricReport();\n  private lastRedRecoveryMetricReportConsumedTimestampMs: number = 0;\n  private videoCodecDegradationHighEncodeCpuCount: number = 0;\n  private videoCodecDegradationEncodeFailureCount: number = 0;\n\n  constructor(\n    private audioVideoController: AudioVideoController,\n    private logger: Logger,\n    private readonly interval: number = StatsCollector.INTERVAL_MS\n  ) {}\n\n  // TODO: Update toAttribute() and toSuffix() methods to convert raw data to a required type.\n  /**\n   * Converts string to attribute format.\n   */\n  toAttribute(str: string): string {\n    return this.toSuffix(str).substring(1);\n  }\n\n  /**\n   * Converts string to suffix format.\n   */\n  private toSuffix(str: string): string {\n    if (str.toLowerCase() === str) {\n      // e.g. lower_case -> _lower_case\n      return `_${str}`;\n    } else if (str.toUpperCase() === str) {\n      // e.g. UPPER_CASE -> _upper_case\n      return `_${str.toLowerCase()}`;\n    } else {\n      // e.g. CamelCaseWithCAPS -> _camel_case_with_caps\n      return str\n        .replace(/([A-Z][a-z]+)/g, function ($1) {\n          return `_${$1}`;\n        })\n        .replace(/([A-Z][A-Z]+)/g, function ($1) {\n          return `_${$1}`;\n        })\n        .toLowerCase();\n    }\n  }\n\n  // TODO: Implement metricsAddTime() and metricsLogEvent().\n  metricsAddTime = (\n    _name: string,\n    _duration: number,\n    _attributes?: { [id: string]: string }\n  ): void => {};\n  metricsLogEvent = (_name: string, _attributes: { [id: string]: string }): void => {};\n\n  /**\n   * Logs the latency.\n   */\n  logLatency(eventName: string, timeMs: number, attributes?: { [id: string]: string }): void {\n    const event = this.toSuffix(eventName);\n    this.logEventTime('meeting' + event, timeMs, attributes);\n  }\n\n  /**\n   * Logs the state timeout.\n   */\n  logStateTimeout(stateName: string, attributes?: { [id: string]: string }): void {\n    const state = this.toSuffix(stateName);\n    this.logEvent('meeting_session_state_timeout', {\n      ...attributes,\n      state: `state${state}`,\n    });\n  }\n\n  /**\n   * Logs the audio event.\n   */\n  logAudioEvent(eventName: AudioLogEvent, attributes?: { [id: string]: string }): void {\n    const event = 'audio' + this.toSuffix(AudioLogEvent[eventName]);\n    this.logEvent(event, attributes);\n  }\n\n  /**\n   * Logs the video event.\n   */\n  logVideoEvent(eventName: VideoLogEvent, attributes?: { [id: string]: string }): void {\n    const event = 'video' + this.toSuffix(VideoLogEvent[eventName]);\n    this.logEvent(event, attributes);\n  }\n\n  private logEventTime(\n    eventName: string,\n    timeMs: number,\n    attributes: { [id: string]: string } = {}\n  ): void {\n    const finalAttributes = {\n      ...attributes,\n      call_id: this.audioVideoController.configuration.meetingId,\n      client_type: StatsCollector.CLIENT_TYPE,\n      metric_type: 'latency',\n    };\n    this.logger.debug(() => {\n      return `[StatsCollector] ${eventName}: ${JSON.stringify(finalAttributes)}`;\n    });\n    this.metricsAddTime(eventName, timeMs, finalAttributes);\n  }\n\n  /**\n   * Logs the session status.\n   */\n  logMeetingSessionStatus(status: MeetingSessionStatus): void {\n    // TODO: Generate the status event name given the status code.\n    const statusEventName = `${status.statusCode()}`;\n\n    this.logEvent(statusEventName);\n    const statusAttribute: { [id: string]: string } = {\n      status: statusEventName,\n      status_code: `${status.statusCode()}`,\n    };\n    this.logEvent('meeting_session_status', statusAttribute);\n    if (status.isTerminal()) {\n      this.logEvent('meeting_session_stopped', statusAttribute);\n    }\n    if (status.isAudioConnectionFailure()) {\n      this.logEvent('meeting_session_audio_failed', statusAttribute);\n    }\n    if (status.isFailure()) {\n      this.logEvent('meeting_session_failed', statusAttribute);\n    }\n  }\n\n  /**\n   * Logs the lifecycle event.\n   */\n  logLifecycleEvent(\n    lifecycleEvent: MeetingSessionLifecycleEvent,\n    condition: MeetingSessionLifecycleEventCondition\n  ): void {\n    const attributes: { [id: string]: string } = {\n      lifecycle_event: `lifecycle${this.toSuffix(MeetingSessionLifecycleEvent[lifecycleEvent])}`,\n      lifecycle_event_code: `${lifecycleEvent}`,\n      lifecycle_event_condition: `condition${this.toSuffix(\n        MeetingSessionLifecycleEventCondition[condition]\n      )}`,\n      lifecycle_event_condition_code: `${condition}`,\n    };\n    this.logEvent('meeting_session_lifecycle', attributes);\n  }\n\n  /**\n   * Logs the events.\n   */\n  private logEvent(eventName: string, attributes: { [id: string]: string } = {}): void {\n    const finalAttributes = {\n      ...attributes,\n      call_id: this.audioVideoController.configuration.meetingId,\n      client_type: StatsCollector.CLIENT_TYPE,\n    };\n    this.logger.debug(() => {\n      return `[StatsCollector] ${eventName}: ${JSON.stringify(finalAttributes)}`;\n    });\n    this.metricsLogEvent(eventName, finalAttributes);\n  }\n\n  /**\n   * Starts collecting statistics.\n   */\n  start(signalingClient: SignalingClient, videoStreamIndex: VideoStreamIndex): boolean {\n    if (this.intervalScheduler) {\n      return false;\n    }\n    this.logger.info('Starting StatsCollector');\n    this.signalingClient = signalingClient;\n    this.videoStreamIndex = videoStreamIndex;\n    this.clientMetricReport = new ClientMetricReport(\n      this.logger,\n      this.videoStreamIndex,\n      this.audioVideoController.configuration.credentials.attendeeId\n    );\n    this.intervalScheduler = new IntervalScheduler(this.interval);\n    this.intervalScheduler.start(async () => {\n      await this.getStatsWrapper();\n    });\n    return true;\n  }\n\n  /*\n   * Stops the stats collector.\n   */\n  stop(): void {\n    this.logger.info('Stopping StatsCollector');\n    if (this.intervalScheduler) {\n      this.intervalScheduler.stop();\n    }\n    this.intervalScheduler = null;\n  }\n\n  /**\n   * Convert raw metrics to client metric report.\n   */\n  private updateMetricValues(rawMetricReport: RawMetricReport, isStream: boolean): void {\n    const metricReport = isStream\n      ? this.clientMetricReport.streamMetricReports[Number(rawMetricReport.ssrc)]\n      : this.clientMetricReport.globalMetricReport;\n\n    let metricMap: {\n      [id: string]: {\n        transform?: (metricName?: string, ssrc?: number) => number;\n        type?: SdkMetric.Type;\n        source?: string;\n      };\n    };\n    if (isStream) {\n      metricMap = this.clientMetricReport.getMetricMap(\n        (metricReport as StreamMetricReport).mediaType,\n        (metricReport as StreamMetricReport).direction\n      );\n    } else {\n      metricMap = this.clientMetricReport.getMetricMap();\n    }\n\n    for (const rawMetric in rawMetricReport) {\n      if (rawMetric in metricMap) {\n        if (typeof rawMetricReport[rawMetric] === 'number') {\n          metricReport.previousMetrics[rawMetric] = metricReport.currentMetrics[rawMetric];\n          metricReport.currentMetrics[rawMetric] = rawMetricReport[rawMetric];\n        } else if (typeof rawMetricReport[rawMetric] === 'string') {\n          metricReport.currentStringMetrics[rawMetric] = rawMetricReport[rawMetric];\n        } else if (typeof rawMetricReport[rawMetric] === 'object') {\n          metricReport.previousObjectMetrics[rawMetric] =\n            metricReport.currentObjectMetrics[rawMetric] === undefined\n              ? rawMetricReport[rawMetric]\n              : metricReport.currentObjectMetrics[rawMetric];\n          metricReport.currentObjectMetrics[rawMetric] = rawMetricReport[rawMetric];\n        } else {\n          this.logger.error(\n            `Unknown metric value type ${typeof rawMetricReport[rawMetric]} for metric ${rawMetric}`\n          );\n        }\n      }\n    }\n  }\n\n  /**\n   * Converts RawMetricReport to StreamMetricReport and GlobalMetricReport and stores them as clientMetricReport.\n   */\n  private processRawMetricReports(rawMetricReports: RawMetricReport[]): void {\n    this.clientMetricReport.currentSsrcs = {};\n    const timeStamp = Date.now();\n    for (const rawMetricReport of rawMetricReports) {\n      const isStream = this.isStreamRawMetricReport(rawMetricReport.type);\n      if (isStream) {\n        const existingStreamMetricReport = this.clientMetricReport.streamMetricReports[\n          Number(rawMetricReport.ssrc)\n        ];\n        if (!existingStreamMetricReport) {\n          const streamMetricReport = new StreamMetricReport();\n          streamMetricReport.mediaType = this.getMediaType(rawMetricReport);\n          streamMetricReport.direction = this.getDirectionType(rawMetricReport);\n          if (\n            streamMetricReport.mediaType === MediaType.VIDEO &&\n            streamMetricReport.direction === Direction.UPSTREAM\n          ) {\n            streamMetricReport.streamId = this.videoStreamIndex.sendVideoStreamIdFromRid(\n              rawMetricReport.rid\n            );\n          } else if (!this.videoStreamIndex.allStreams().empty()) {\n            streamMetricReport.streamId = this.videoStreamIndex.streamIdForSSRC(\n              Number(rawMetricReport.ssrc)\n            );\n            /* istanbul ignore else */\n            if (this.videoStreamIndex.groupIdForSSRC !== undefined) {\n              streamMetricReport.groupId = this.videoStreamIndex.groupIdForSSRC(\n                Number(rawMetricReport.ssrc)\n              );\n            }\n          }\n          this.clientMetricReport.streamMetricReports[\n            Number(rawMetricReport.ssrc)\n          ] = streamMetricReport;\n        } else {\n          // Update stream ID in case we have overridden it locally in the case of remote video\n          // updates completed without a negotiation\n          if (\n            existingStreamMetricReport.mediaType === MediaType.VIDEO &&\n            existingStreamMetricReport.direction === Direction.UPSTREAM\n          ) {\n            existingStreamMetricReport.streamId = this.videoStreamIndex.sendVideoStreamIdFromRid(\n              rawMetricReport.rid\n            );\n          } else {\n            existingStreamMetricReport.streamId = this.videoStreamIndex.streamIdForSSRC(\n              Number(rawMetricReport.ssrc)\n            );\n          }\n        }\n        this.clientMetricReport.currentSsrcs[Number(rawMetricReport.ssrc)] = 1;\n      }\n      this.updateMetricValues(rawMetricReport, isStream);\n    }\n    this.clientMetricReport.removeDestroyedSsrcs();\n    this.clientMetricReport.previousTimestampMs = this.clientMetricReport.currentTimestampMs;\n    this.clientMetricReport.currentTimestampMs = timeStamp;\n    this.clientMetricReport.print();\n  }\n\n  /**\n   *  Add stream metric dimension frames derived from metrics\n   */\n  private addStreamMetricDimensionFrames(\n    streamMetricFrame: SdkStreamMetricFrame,\n    streamMetricReport: StreamMetricReport\n  ): void {\n    const streamDimensionMap = this.clientMetricReport.getStreamDimensionMap();\n    for (const metricName in streamMetricReport.currentStringMetrics) {\n      if (metricName in streamDimensionMap) {\n        const dimensionFrame = SdkStreamDimension.create();\n        dimensionFrame.type = streamDimensionMap[metricName];\n        const dimensionValue = SdkDimensionValue.create();\n        dimensionValue.stringValue = streamMetricReport.currentStringMetrics[metricName];\n        dimensionFrame.value = dimensionValue;\n        streamMetricFrame.dimensions.push(dimensionFrame);\n      }\n    }\n  }\n\n  /**\n   * Packages a metric into the MetricFrame.\n   */\n  private addMetricFrame(\n    metricName: string,\n    clientMetricFrame: SdkClientMetricFrame,\n    metricSpec: {\n      transform?: (metricName?: string, ssrc?: number) => number;\n      type?: SdkMetric.Type;\n      source?: string;\n    },\n    ssrc?: number\n  ): void {\n    const type = metricSpec.type;\n    const transform = metricSpec.transform;\n    const sourceMetric = metricSpec.source;\n    const streamMetricFramesLength = clientMetricFrame.streamMetricFrames.length;\n    const latestStreamMetricFrame =\n      clientMetricFrame.streamMetricFrames[streamMetricFramesLength - 1];\n    if (type) {\n      const metricFrame = SdkMetric.create();\n      metricFrame.type = type;\n      metricFrame.value = sourceMetric\n        ? transform(sourceMetric, ssrc)\n        : transform(metricName, ssrc);\n      ssrc\n        ? latestStreamMetricFrame.metrics.push(metricFrame)\n        : clientMetricFrame.globalMetrics.push(metricFrame);\n    }\n  }\n\n  /**\n   * Packages metrics in GlobalMetricReport into the MetricFrame.\n   */\n  private addGlobalMetricsToProtobuf(clientMetricFrame: SdkClientMetricFrame): void {\n    const metricMap = this.clientMetricReport.getMetricMap();\n    for (const metricName in this.clientMetricReport.globalMetricReport.currentMetrics) {\n      this.addMetricFrame(metricName, clientMetricFrame, metricMap[metricName]);\n    }\n  }\n\n  /**\n   * Packages metrics in StreamMetricReport into the MetricFrame.\n   */\n  private addStreamMetricsToProtobuf(clientMetricFrame: SdkClientMetricFrame): void {\n    for (const ssrc in this.clientMetricReport.streamMetricReports) {\n      const streamMetricReport = this.clientMetricReport.streamMetricReports[ssrc];\n      const streamMetricFrame = SdkStreamMetricFrame.create();\n      streamMetricFrame.streamId = streamMetricReport.streamId;\n      streamMetricFrame.metrics = [];\n      this.addStreamMetricDimensionFrames(streamMetricFrame, streamMetricReport);\n      clientMetricFrame.streamMetricFrames.push(streamMetricFrame);\n      const metricMap = this.clientMetricReport.getMetricMap(\n        streamMetricReport.mediaType,\n        streamMetricReport.direction\n      );\n\n      // We loop over 'metricMap' instead of the members of 'streamMetricReport' because\n      // the latter does not include metrics (e.g. audio downstream 'decoderLoss') that are\n      // entirely dependent on other metrics (in this case 'concealedSamples' and 'totalSamplesReceived')\n      // for their calculation\n      for (const metricName in metricMap) {\n        if (this.hasMetricDependenciesInReport(metricName, streamMetricReport)) {\n          this.addMetricFrame(metricName, clientMetricFrame, metricMap[metricName], Number(ssrc));\n        }\n      }\n    }\n  }\n\n  private hasMetricDependenciesInReport(\n    metricName: string,\n    streamMetricReport: StreamMetricReport\n  ): boolean {\n    // Unfortunately the metrics maps do not expose their dependencies so we have to manually\n    // hard code them for metrics we know have them\n    const isSpecialMetricAndHasDependencies =\n      (metricName === 'decoderLoss' &&\n        streamMetricReport.currentMetrics['concealedSamples'] !== undefined &&\n        streamMetricReport.currentMetrics['totalSamplesReceived'] !== undefined) ||\n      (metricName === 'jitterBufferMs' &&\n        streamMetricReport.currentMetrics['jitterBufferDelay'] !== undefined &&\n        streamMetricReport.currentMetrics['jitterBufferEmittedCount'] !== undefined);\n\n    return (\n      isSpecialMetricAndHasDependencies ||\n      metricName in streamMetricReport.currentMetrics ||\n      metricName in streamMetricReport.currentStringMetrics ||\n      metricName in streamMetricReport.currentObjectMetrics\n    );\n  }\n\n  /**\n   * Packages all metrics into the MetricFrame.\n   */\n  private makeClientMetricProtobuf(): SdkClientMetricFrame {\n    const clientMetricFrame = SdkClientMetricFrame.create();\n    clientMetricFrame.globalMetrics = [];\n    clientMetricFrame.streamMetricFrames = [];\n    this.addGlobalMetricsToProtobuf(clientMetricFrame);\n    this.addStreamMetricsToProtobuf(clientMetricFrame);\n    return clientMetricFrame;\n  }\n\n  /**\n   * Sends the MetricFrame to media backend via ProtoBuf.\n   */\n  private sendClientMetricProtobuf(clientMetricFrame: SdkClientMetricFrame): void {\n    this.signalingClient.sendClientMetrics(clientMetricFrame);\n  }\n\n  /**\n   * Checks if the type of RawMetricReport is stream related.\n   */\n  private isStreamRawMetricReport(type: string): boolean {\n    return [\n      'inbound-rtp',\n      'inbound-rtp-red',\n      'outbound-rtp',\n      'remote-inbound-rtp',\n      'remote-outbound-rtp',\n    ].includes(type);\n  }\n\n  /**\n   * Returns the MediaType for a RawMetricReport.\n   */\n  private getMediaType(rawMetricReport: RawMetricReport): MediaType {\n    return rawMetricReport.kind === 'audio' ? MediaType.AUDIO : MediaType.VIDEO;\n  }\n\n  /**\n   * Returns the Direction for a RawMetricReport.\n   */\n  private getDirectionType(rawMetricReport: RawMetricReport): Direction {\n    const { type } = rawMetricReport;\n    return type === 'inbound-rtp' || type === 'remote-outbound-rtp' || type === 'inbound-rtp-red'\n      ? Direction.DOWNSTREAM\n      : Direction.UPSTREAM;\n  }\n\n  /**\n   * Checks if a RawMetricReport belongs to certain types.\n   */\n  isValidStandardRawMetric(rawMetricReport: RawMetricReport): boolean {\n    return (\n      rawMetricReport.type === 'inbound-rtp' ||\n      rawMetricReport.type === 'inbound-rtp-red' ||\n      rawMetricReport.type === 'outbound-rtp' ||\n      rawMetricReport.type === 'remote-inbound-rtp' ||\n      rawMetricReport.type === 'remote-outbound-rtp' ||\n      (rawMetricReport.type === 'candidate-pair' && rawMetricReport.state === 'succeeded') ||\n      (rawMetricReport.type === 'media-source' && rawMetricReport.kind === 'audio')\n    );\n  }\n\n  /**\n   * Checks if a RawMetricReport is stream related.\n   */\n  isValidSsrc(rawMetricReport: RawMetricReport): boolean {\n    let validSsrc = true;\n    if (\n      this.isStreamRawMetricReport(rawMetricReport.type) &&\n      this.getDirectionType(rawMetricReport) === Direction.DOWNSTREAM &&\n      this.getMediaType(rawMetricReport) === MediaType.VIDEO\n    ) {\n      validSsrc = this.videoStreamIndex.streamIdForSSRC(Number(rawMetricReport.ssrc)) > 0;\n    }\n    return validSsrc;\n  }\n\n  /**\n   * Checks if a RawMetricReport is valid.\n   */\n  isValidRawMetricReport(rawMetricReport: RawMetricReport): boolean {\n    return this.isValidStandardRawMetric(rawMetricReport) && this.isValidSsrc(rawMetricReport);\n  }\n\n  /**\n   * Filters RawMetricReports and keeps the required parts.\n   */\n  filterRawMetricReports(rawMetricReports: RawMetricReport[]): RawMetricReport[] {\n    const filteredRawMetricReports = [];\n    for (const rawMetricReport of rawMetricReports) {\n      if (this.isValidRawMetricReport(rawMetricReport)) {\n        filteredRawMetricReports.push(rawMetricReport);\n      }\n    }\n    return filteredRawMetricReports;\n  }\n\n  /**\n   * Performs a series operation on RawMetricReport.\n   */\n  private handleRawMetricReports(rawMetricReports: RawMetricReport[]): void {\n    const filteredRawMetricReports = this.filterRawMetricReports(rawMetricReports);\n    this.logger.debug(() => {\n      return `Filtered raw metrics : ${JSON.stringify(filteredRawMetricReports)}`;\n    });\n\n    // Add custom stats for reporting.\n    const customStatsReports: CustomStatsReport[] = [];\n    this.maybeAddRedRecoveryMetrics(customStatsReports);\n    // We cannot use 'this.clientMetricsReport.getVideoUpstreamSsrc()' because the value\n    // is dependent on the call to 'this.processRawMetricReports()' below, i.e. it depends on\n    // the previous handling of raw metrics reports. This would lead to the addition of custom metrics\n    // for streams that may no longer exist, e.g. after a reconnection, which will then stick around\n    // perpetually\n    const videoUpstreamSsrc = this.getVideoUpstreamSsrcFromRawMetricReports(\n      filteredRawMetricReports\n    );\n    if (videoUpstreamSsrc !== null) {\n      this.addVideoCodecDegradationMetrics(customStatsReports, videoUpstreamSsrc);\n    }\n    this.clientMetricReport.customStatsReports = customStatsReports;\n    filteredRawMetricReports.push(...customStatsReports);\n\n    this.processRawMetricReports(filteredRawMetricReports);\n\n    const clientMetricFrame = this.makeClientMetricProtobuf();\n    this.sendClientMetricProtobuf(clientMetricFrame);\n    this.audioVideoController.forEachObserver(observer => {\n      Maybe.of(observer.metricsDidReceive).map(f =>\n        f.bind(observer)(this.clientMetricReport.clone())\n      );\n    });\n  }\n\n  /**\n   * Gets raw WebRTC metrics.\n   */\n  private async getStatsWrapper(): Promise<void> {\n    if (!this.audioVideoController.rtcPeerConnection) {\n      return;\n    }\n\n    const rawMetricReports: RawMetricReport[] = [];\n\n    // @ts-ignore\n    try {\n      const report = await this.audioVideoController.rtcPeerConnection.getStats();\n      this.clientMetricReport.rtcStatsReport = report;\n      report.forEach((item: StatsReportItem) => {\n        rawMetricReports.push(item);\n      });\n      this.handleRawMetricReports(rawMetricReports);\n    } catch (error) {\n      this.logger.error(error.message);\n    }\n  }\n\n  overrideObservableMetric(name: string, value: number): void {\n    this.clientMetricReport.overrideObservableMetric(name, value);\n  }\n  /**\n   * Receives the red recovery metrics from DefaultTransceiver.\n   */\n  recoveryMetricsDidReceive(metricReport: RedundantAudioRecoveryMetricReport): void {\n    this.redRecoveryMetricReport = metricReport;\n  }\n\n  /**\n   * Adds RED recovery metrics to the raw webrtc stats report.\n   */\n  private maybeAddRedRecoveryMetrics(customStatsReports: CustomStatsReport[]): void {\n    if (\n      this.redRecoveryMetricReport.currentTimestampMs ===\n      this.lastRedRecoveryMetricReportConsumedTimestampMs\n    ) {\n      // We have already sent the latest RED metrics.\n      return;\n    }\n\n    // @ts-ignore\n    customStatsReports.push({\n      kind: 'audio',\n      type: 'inbound-rtp-red',\n      ssrc: this.redRecoveryMetricReport.ssrc,\n      timestamp: this.redRecoveryMetricReport.currentTimestampMs,\n      totalAudioPacketsLost: this.redRecoveryMetricReport.totalAudioPacketsLost,\n      totalAudioPacketsExpected: this.redRecoveryMetricReport.totalAudioPacketsExpected,\n      totalAudioPacketsRecoveredRed: this.redRecoveryMetricReport.totalAudioPacketsRecoveredRed,\n      totalAudioPacketsRecoveredFec: this.redRecoveryMetricReport.totalAudioPacketsRecoveredFec,\n    });\n\n    this.lastRedRecoveryMetricReportConsumedTimestampMs = this.redRecoveryMetricReport.currentTimestampMs;\n  }\n\n  /**\n   * Receive video codec degradation event due to high encode CPU usage\n   * from MonitorTask and increment counter\n   */\n  videoCodecDegradationHighEncodeCpuDidReceive(): void {\n    this.videoCodecDegradationHighEncodeCpuCount += 1;\n  }\n\n  /**\n   * Receive video codec degradation event due to hardware encoder failure\n   * from MonitorTask and increment counter\n   */\n  videoCodecDegradationEncodeFailureDidReceive(): void {\n    this.videoCodecDegradationEncodeFailureCount += 1;\n  }\n\n  private addVideoCodecDegradationMetrics(\n    customStatsReports: CustomStatsReport[],\n    videoUpstreamSsrc: number\n  ): void {\n    customStatsReports.push({\n      kind: 'video',\n      type: 'outbound-rtp',\n      ssrc: videoUpstreamSsrc,\n      timestamp: Date.now(),\n      videoCodecDegradationHighEncodeCpu: this.videoCodecDegradationHighEncodeCpuCount,\n      videoCodecDegradationEncodeFailure: this.videoCodecDegradationEncodeFailureCount,\n    });\n    this.videoCodecDegradationHighEncodeCpuCount = 0;\n    this.videoCodecDegradationEncodeFailureCount = 0;\n  }\n\n  private getVideoUpstreamSsrcFromRawMetricReports(\n    rawMetricReports: RawMetricReport[]\n  ): number | null {\n    for (const rawMetricReport of rawMetricReports) {\n      if (\n        this.isStreamRawMetricReport(rawMetricReport.type) &&\n        this.getMediaType(rawMetricReport) === MediaType.VIDEO &&\n        this.getDirectionType(rawMetricReport) === Direction.UPSTREAM\n      ) {\n        return rawMetricReport.ssrc;\n      }\n    }\n    return null;\n  }\n}\n"]}
{"version":3,"file":"AudioVideoControllerFacade.js","sourceRoot":"","sources":["../../src/audiovideocontroller/AudioVideoControllerFacade.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport AudioProfile from '../audioprofile/AudioProfile';\nimport AudioVideoObserver from '../audiovideoobserver/AudioVideoObserver';\nimport MeetingSessionCredentials from '../meetingsession/MeetingSessionCredentials';\nimport MeetingSessionStatus from '../meetingsession/MeetingSessionStatus';\nimport VideoCodecCapability from '../sdp/VideoCodecCapability';\nimport VideoSource from '../videosource/VideoSource';\n\nexport default interface AudioVideoControllerFacade {\n  addObserver(observer: AudioVideoObserver): void;\n  removeObserver(observer: AudioVideoObserver): void;\n\n  /**\n   * Start the meeting session. By default this will connect and begin sending\n   * and receiving audio, depending on the implementation.\n   *\n   * This method also allows you to provide options for how connection occurs.\n   *\n   * The only supported option is `signalingOnly`. Specifying this option will\n   * cause the controller to only connect the meeting signaling channel. This\n   * can be performed relatively early in the join lifecycle (_e.g._, prior to\n   * choosing audio devices), which can improve join latency.\n   *\n   * Your code is responsible for calling `start` again without `signalingOnly`\n   * to complete connection.\n   *\n   * @param options Passing `signalingOnly: true` will cause only the initial signaling connection to occur.\n   */\n  start(options?: { signalingOnly?: boolean }): void;\n  stop(): void;\n  /**\n   * This API will be deprecated in favor of `ClientMetricReport.getRTCStatsReport()`.\n   *\n   * It makes an additional call to the `getStats` API and therefore may cause slight performance degradation.\n   *\n   * Please subscribe to `metricsDidReceive(clientMetricReport: ClientMetricReport)` callback,\n   * and get the raw `RTCStatsReport` via `clientMetricReport.getRTCStatsReport()`.\n   */\n  getRTCPeerConnectionStats(selector?: MediaStreamTrack): Promise<RTCStatsReport>;\n  /**\n   * Get all the remote video sending sources.\n   */\n  getRemoteVideoSources(): VideoSource[];\n\n  /**\n   * Sets the audio profile to use for audio. The new audio profile takes effect\n   * on the next call to `start` or if already started, upon the next reconnect.\n   */\n  setAudioProfile(audioProfile: AudioProfile): void;\n\n  /**\n   * Allows an attendee in a Replica meeting to immediately transition to a Primary meeting attendee\n   * without need for reconnection. The promise should always return a session status\n   * even upon failure (i.e. it should never reject). See the guide for more information.\n   *\n   * The resolved `MeetingSessionStatus` will contain a `MeetingSessionStatusCode` of the following:\n   *\n   * * `MeetingSessionStatusCode.OK`: The promotion was successful (i.e. session token was valid,\n   *   there was room in the Primary meeting, etc.), audio will begin flowing\n   *   and the attendee can begin to send data messages, and content/video if the call is not already at limit.\n   * * `MeetingSessionStatusCode.AudioAuthenticationRejected`: Credentials provided\n   *   were invalid when connection attempted to Primary meeting. There may be an issue\n   *   with your mechanism which allocates the Primary meeting attendee for the Replica\n   *   meeting proxied promotion.  This also may indicate that this API was called in a\n   *   non-Replica meeting.\n   * * `MeetingSessionStatusCode.AudioCallAtCapacity`: Credentials provided were correct\n   *   but there was no room in the Primary meeting.  Promotions to Primary meeting attendee take up a slot, just like\n   *   regular Primary meeting attendee connections and are limited by the same mechanisms.\n   * * `MeetingSessionStatusCode.SignalingBadRequest` or `MeetingSessionStatusCode.SignalingInternalServerError`:\n   *   Other failure, possibly due to disconnect or timeout. These failures are likely retryable.\n   *\n   * Application code may also receive a callback on `AudioVideoObserver.videoAvailabilityDidChange` to indicate they\n   * can begin to share video.\n   *\n   * `chime::DeleteAttendee` on the Primary meeting attendee will result in `AudioVideoObserver.audioVideoWasDemotedFromPrimaryMeeting`\n   * to indicate the attendee is no longer able to share.\n   *\n   * Any disconnection will trigger an automatic demotion to avoid unexpected or unwanted promotion state on reconnection.\n   * If the attendee still needs to be an interactive participant in the Primary meeting, `promoteToPrimaryMeeting`\n   * should be called again with the same credentials.\n   *\n   * This function should not be called until the first one resolves.\n   *\n   * @param credentials The credentials for the Primary meeting.  This needs to be obtained out of band.\n   * @returns Promise which resolves to a session status for the request. See possible options above.\n   */\n  promoteToPrimaryMeeting(credentials: MeetingSessionCredentials): Promise<MeetingSessionStatus>;\n\n  /**\n   * Remove the promoted attendee from the Primary meeting. This client will stop sharing audio, video, and data messages.\n   * This will revert the end-user to precisely the state they were before a call to `promoteToPrimaryMeeting`\n   *\n   * This will have no effect if there was no previous successful call to `promoteToPrimaryMeeting`. This\n   * may result in `AudioVideoObserver.audioVideoWasDemotedFromPrimaryMeeting` but there is no need to wait for that callback\n   * to revert UX, etc.\n   */\n  demoteFromPrimaryMeeting(): void;\n\n  /**\n   * Sets the max bandwidth for video publishing\n   */\n  setVideoMaxBandwidthKbps(maxBandwidthKbps: number): void;\n\n  /**\n   * Set codec preferences for this clients send stream in order\n   * of most preferred to least preferred. The controller will\n   * fallback for one of two reasons\n   *  * The codec is not supported by the browser\n   *  * Another client that has joined the conference does not support\n   *    receiving the video. Note that if another client does not support\n   *    any of the codecs provided the sender will not fallback, and that client\n   *    will not be able to receive from this sender.\n   *\n   * If there is no overlap between what is passed in and what is supported by the browser, this function\n   * may not have any effect, and the default set of codecs for this browser will be used.\n   *\n   * @param Array of [[VideoCodecCapability]].\n   */\n  setVideoCodecSendPreferences?(preferences: VideoCodecCapability[]): void;\n}\n"]}
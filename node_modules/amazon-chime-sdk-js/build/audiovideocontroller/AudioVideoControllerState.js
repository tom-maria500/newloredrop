"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
Object.defineProperty(exports, "__esModule", { value: true });
exports.DEFAULT_VIDEO_SUBSCRIPTION_LIMIT = void 0;
exports.DEFAULT_VIDEO_SUBSCRIPTION_LIMIT = 25;
/**
 * [[AudioVideoControllerState]] includes the compute resources shared by [[DefaultAudioVideoController]] and any running [[Task]].
 *
 * **Note**: Any additions to this class need to consider whether they need to be reset in `resetConnectionSpecificState`, `CleanStoppedSessionTask`, or
 * `CleanRestartedSessionTask`, e.g. if it is relies on backend state and will go stale across reconnections.  Failing
 * to reset state may lead to unexpected behavior.
 */
class AudioVideoControllerState {
    constructor() {
        this.logger = null;
        this.browserBehavior = null;
        this.meetingSessionConfiguration = null;
        this.signalingClient = null;
        this.peer = null;
        this.previousSdpOffer = null;
        this.sdpOfferInit = null;
        this.audioVideoController = null;
        this.realtimeController = null;
        this.videoTileController = null;
        this.mediaStreamBroker = null;
        this.activeAudioInput = undefined;
        this.activeVideoInput = undefined;
        this.audioMixController = null;
        this.transceiverController = null;
        this.indexFrame = null;
        this.iceCandidates = [];
        this.iceCandidateHandler = null;
        this.iceGatheringStateEventHandler = null;
        this.sdpAnswer = null;
        this.turnCredentials = null;
        this.reconnectController = null;
        this.removableObservers = [];
        this.audioProfile = null;
        this.videoStreamIndex = null;
        this.videoDownlinkBandwidthPolicy = null;
        this.videoUplinkBandwidthPolicy = null;
        this.lastKnownVideoAvailability = null;
        this.videoCaptureAndEncodeParameter = null;
        // An unordered list of IDs provided by the downlink policy that
        // we will eventually subscribe to.
        this.videosToReceive = null;
        // The last processed set of IDs provided by the policy, so that we can
        // compare what changes were additions, stream switches, or removals.
        this.lastVideosToReceive = null;
        // An ordered list corresponding to `videosToReceive` where the order
        // itself correspond to transceivers; 0 in this list corresponds to an inactive tranceiver.
        this.videoSubscriptions = null;
        // The last calculated list of subscription configuration used to send a remote video
        // update (i.e. not necessarily related to what is in subscribe). This is used to make the remote
        // video update a differential message (i.e. only sending changes)
        //
        // This is stored as a map keyed by group ID for convenience
        this.lastVideoSubscriptionConfiguration = new Map();
        // The video subscription limit is set by the backend and is subject to change in future.
        // This value is set in the `JoinAndReceiveIndexTask` when we process the `SdkJoinAckFrame`
        // and is used in the `ReceiveVideoStreamIndexTask` to limit the total number of streams
        // that we include in the `videosToReceive`.
        this.videoSubscriptionLimit = exports.DEFAULT_VIDEO_SUBSCRIPTION_LIMIT;
        // The previous SDP answer will be used as a dictionary to seed the compression library
        // during decompressing the compressed SDP answer.
        this.previousSdpAnswerAsString = '';
        // This flag indicates if the backend supports compression for the client.
        this.serverSupportsCompression = false;
        // Values set by `setVideoCodecSendPreferences`.
        this.videoSendCodecPreferences = [];
        // Calculated as the highest priority available codec set in the (possibly munged) SDP answer
        // that is provide to the peer connection, which will be what is sent.
        this.currentVideoSendCodec = undefined;
        // Intersection of `videoSendCodecPreferences` and the supported receive codecs of
        // all the other clients in the meeting.
        this.meetingSupportedVideoSendCodecPreferences = undefined;
        // Calculated as the list of available codec set in the (possibly munged) SDP answer
        // that is provided to the peer connection, which will be ordered by priority.
        this.prioritizedSendVideoCodecCapabilities = [];
        // Video codecs that we have detected encoding issues with that we will
        // avoid using even if they are provided in `videoSendCodecPreferences`
        this.degradedVideoSendCodecs = [];
        this.videosPaused = null;
        this.videoDuplexMode = null;
        this.volumeIndicatorAdapter = null;
        this.statsCollector = null;
        this.connectionMonitor = null;
        // This state is deprecated and unused.
        this.videoInputAttachedTimestampMs = 0;
        // This state is deprecated and unused.
        this.audioDeviceInformation = {};
        // This state is deprecated and unused.
        this.videoDeviceInformation = {};
        this.enableSimulcast = false;
        // If set to true, the client will actively try to use Scalable Video Coding (SVC) features
        // if possible. The availability of these features depends dynamically on the video codec used;
        // static browser availability and any competing features (e.g. simulcast) should
        // have already been checked before this is set to true.
        this.enableSVC = false;
        this.eventController = null;
        this.signalingOpenDurationMs = null;
        this.iceGatheringDurationMs = null;
        this.startAudioVideoTimestamp = null;
        this.attendeePresenceDurationMs = null;
        this.meetingStartDurationMs = null;
        this.poorConnectionCount = 0;
        this.maxVideoTileCount = 0;
        this.startTimeMs = null;
    }
    /*
     * Reset state corresponding to state that is dependent on a individual connection
     * and may not be valid for others, e.g. on a reconnection.
     */
    resetConnectionSpecificState() {
        // For auditing reasons, we will comment on the state that we do not touch here. Note that `DefaultAudioVideoController.actionConnect`
        // also resets certain state, some to cached members:
        // Reset to empty/null/new state: `browserBehavior`, `transceiverController`, `volumeIndicatorAdapter`, `enableSimulcast`
        //                                `signalingOpenDurationMs`, `iceGatheringDurationMs`, `startAudioVideoTimestamp`, `attendeePresenceDurationMs`
        //                                `meetingStartDurationMs`, `startTimeMs`, `lastKnownVideoAvailability`, `videoCaptureAndEncodeParameter`, `videosToReceive`
        //                                `videosPaused`, `videoStreamIndex`, `statsCollector`, `connectionMonitor`
        // Reset to existing/cached values: `logger`, `meetingSessionConfiguration`, `realtimeController`, `mediaStreamBroker`,
        //                                  `audioMixController`, `reconnectController, `audioProfile`, `eventController`
        // `signalingClient` can be reused from a failed/disconnected state.
        if (this.peer) {
            this.peer.close();
        }
        this.peer = null;
        this.previousSdpOffer = null;
        this.sdpOfferInit = null;
        // `audioVideoController` members should either be reusable, or moved to `AudioVideoControllerState` and
        // cleaned up here.
        // We don't want to mutate `videoTileController` as most video tiles will still be there on reconnect. We can remove tiles on the
        // first index we receive if they no longer exist
        // `mediaStreamBroker`, `activeAudioInput`, and `activeVideoInput` are cleaned up seperately in `DefaultAudioVideoController.cleanUpMediaStreamsAfterStop`
        // but only on `stop` or non-reconnectable failures. They are also set to cached `DefaultAudioVideoController` members on restart.
        if (this.transceiverController !== undefined) {
            this.transceiverController.reset();
        }
        this.indexFrame = null;
        this.iceCandidates = [];
        this.iceCandidateHandler = null;
        this.sdpAnswer = null;
        this.turnCredentials = null;
        this.videoDownlinkBandwidthPolicy.reset();
        if (this.videoUplinkBandwidthPolicy.reset) {
            this.videoUplinkBandwidthPolicy.reset();
        }
        this.lastVideosToReceive = null;
        this.lastVideoSubscriptionConfiguration = new Map();
        this.videoSubscriptions = null;
        this.videoSubscriptionLimit = exports.DEFAULT_VIDEO_SUBSCRIPTION_LIMIT;
        this.previousSdpAnswerAsString = '';
        this.serverSupportsCompression = false;
        // `videoSendCodecPreferences` is set by builder and needs to stay consistent.
        this.currentVideoSendCodec = undefined;
        this.meetingSupportedVideoSendCodecPreferences = undefined;
        this.videoDuplexMode = null;
        // `poorConnectionCount`and `maxVideoTileCount` is intentionally not set to 0 across reconnections.
    }
}
exports.default = AudioVideoControllerState;
//# sourceMappingURL=AudioVideoControllerState.js.map
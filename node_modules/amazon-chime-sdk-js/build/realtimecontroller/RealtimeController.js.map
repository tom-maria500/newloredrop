{"version":3,"file":"RealtimeController.js","sourceRoot":"","sources":["../../src/realtimecontroller/RealtimeController.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport DataMessage from '../datamessage/DataMessage';\nimport TranscriptionController from '../transcript/TranscriptionController';\nimport RealtimeAttendeePositionInFrame from './RealtimeAttendeePositionInFrame';\nimport type RealtimeSubscribeToAttendeeIdPresenceCallback from './RealtimeSubscribeToAttendeeIdPresenceCallback';\nimport type VolumeIndicatorCallback from './VolumeIndicatorCallback';\n\n/**\n * [[RealtimeController]] controls aspects meetings concerning realtime UX\n * that for performance, privacy, or other reasons should be implemented using\n * the most direct path. Callbacks generated by this interface should be\n * consumed synchronously and without business logic dependent on the UI state\n * where possible. All methods are prefixed with `realtime` to make it easier to\n * perform audits of realtime control paths.\n *\n * For an example involving performance implications, consider that volume\n * indicator state is received for each attendee multiple times a second.\n * The handler that receives WebSocket messages derives which indicators have\n * updated and passes that information synchronously through the\n * RealtimeController, which in turn provides the consumer of the volume\n * indicator callbacks an opportunity to immediately render the information to\n * the UI.\n *\n * For an example involving privacy implications, consider that a mute button\n * must accurately represent the mute state as otherwise a user may think they\n * are muted when they are not. Creating a direct path from the mute button\n * to the place where the underlying media stream is disabled ensures that\n * muting is instantaneous and cannot fail.\n *\n * When you are done using a `RealtimeController`, you should perform some\n * cleanup steps in order to avoid memory leaks:\n *\n * 1. Unsubscribe from listeners; e.g., presence callbacks via\n *    {@link RealtimeController.realtimeUnsubscribeToAttendeeIdPresence}.\n * 2. Drop your reference to the controller to allow it to be garbage collected.\n */\nexport default interface RealtimeController {\n  // Attendee Id\n\n  /**\n   * Sets the attendee id of the current user. This is used to override remote\n   * mute state with local state when there is an active audio input.\n   * @internal\n   */\n  realtimeSetLocalAttendeeId(attendeeId: string, externalUserId: string | null): void;\n\n  /**\n   * Updates the presence of an attendee id.\n   * @internal\n   */\n  realtimeSetAttendeeIdPresence(\n    attendeeId: string,\n    present: boolean,\n    externalUserId: string | null,\n    dropped: boolean | null,\n    posInFrame: RealtimeAttendeePositionInFrame | null\n  ): void;\n\n  /**\n   * Subscribes to changes in attendee ids in order to discover attendee ids to\n   * subscribe and unsubscribe to for volume indicator updates.\n   */\n  realtimeSubscribeToAttendeeIdPresence(\n    callback: RealtimeSubscribeToAttendeeIdPresenceCallback\n  ): void;\n\n  /**\n   * Unsubscribes to changes in attendee ids.\n   */\n  realtimeUnsubscribeToAttendeeIdPresence(\n    callback: RealtimeSubscribeToAttendeeIdPresenceCallback\n  ): void;\n\n  // Muting\n\n  /**\n   * Sets whether the user will be able to mute and then synchronously fires the\n   * callbacks if can-mute state changed.\n   */\n  realtimeSetCanUnmuteLocalAudio(canUnmute: boolean): void;\n\n  /**\n   * Subscribes to the changes to the can unmute local audio state.\n   */\n  realtimeSubscribeToSetCanUnmuteLocalAudio(callback: (canUnmute: boolean) => void): void;\n\n  /**\n   * Unsubscribes to the changes to the can unmute local audio state.\n   */\n  realtimeUnsubscribeToSetCanUnmuteLocalAudio(callback: (canUnmute: boolean) => void): void;\n\n  /**\n   * Returns whether the user can unmute.\n   */\n  realtimeCanUnmuteLocalAudio(): boolean;\n\n  /**\n   * Mutes the audio input. If there is an active audio input, then a volume\n   * indicator update is also sent with the mute status for the current attendee\n   * id. It then synchronously notifies the callbacks if mute state\n   * changed. This mute is local and overrides any remote unmuted state received\n   * for the same attendee id.\n   */\n  realtimeMuteLocalAudio(): void;\n\n  /**\n   * Unmutes the audio input if currently allowed. If there is an active audio\n   * input, then a volume indicator update is also sent with the mute status for\n   * the current attendee id. It then synchronously notifies the callbacks\n   * if mute state changed. This unmute is local and overrides any remote muted\n   * state received for the same attendee id.\n   */\n  realtimeUnmuteLocalAudio(): boolean;\n\n  /**\n   * Subscribes to local audio mutes and unmutes\n   */\n  realtimeSubscribeToMuteAndUnmuteLocalAudio(callback: (muted: boolean) => void): void;\n\n  /**\n   * Unsubscribes to local audio mutes and unmutes\n   */\n  realtimeUnsubscribeToMuteAndUnmuteLocalAudio(callback: (muted: boolean) => void): void;\n\n  /**\n   * Returns whether the current user is muted.\n   */\n  realtimeIsLocalAudioMuted(): boolean;\n\n  // Volume Indicators\n\n  /**\n   * Subscribes to volume indicator changes for a specific attendee id with a\n   * callback. Volume is between 0.0 (min volume) and 1.0 (max volume).\n   * Signal strength can be 0 (no signal), 0.5 (weak signal), or 1 (good signal).\n   * A null value for any field means that it has not changed.\n   */\n  realtimeSubscribeToVolumeIndicator(attendeeId: string, callback: VolumeIndicatorCallback): void;\n\n  /**\n   * Unsubscribes to volume indicator changes for a specific attendee id.\n   * Optionally, you can pass a callback parameter to unsubscribe from a specific callback.\n   * Otherwise, all callbacks will be unsubscribed (e.g. activeSpeaker).\n   */\n  realtimeUnsubscribeFromVolumeIndicator(\n    attendeeId: string,\n    callback?: VolumeIndicatorCallback\n  ): void;\n\n  /**\n   * Computes the difference to the last state and sends a volume indicator\n   * change for the attendee if necessary. Volume is between 0.0 (min volume)\n   * and 1.0 (max volume). Signal strength can be 0 (no signal),\n   * 0.5 (weak signal), or 1 (good signal). A null value for any field means\n   * that it has not changed. If muted is non-null, then the volume will be\n   * overridden to 0.0.\n   * @internal\n   */\n  realtimeUpdateVolumeIndicator(\n    attendeeId: string,\n    volume: number | null,\n    muted: boolean | null,\n    signalStrength: number | null,\n    externalUserId: string | null\n  ): void;\n\n  /**\n   * Subscribes to changes in local signal strength\n   */\n  realtimeSubscribeToLocalSignalStrengthChange(callback: (signalStrength: number) => void): void;\n\n  /**\n   * Unsubscribes to changes in local signal strength\n   */\n  realtimeUnsubscribeToLocalSignalStrengthChange(callback: (signalStrength: number) => void): void;\n\n  /**\n   * Subscribe to local send message event\n   */\n  realtimeSubscribeToSendDataMessage( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (topic: string, data: Uint8Array | string | any, lifetimeMs?: number) => void\n  ): void;\n\n  /**\n   * Unsubscribe from local send message event\n   */\n  realtimeUnsubscribeFromSendDataMessage( // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    callback: (topic: string, data: Uint8Array | string | any, lifetimeMs?: number) => void\n  ): void;\n\n  /**\n   * Send message via data channel\n   */\n  realtimeSendDataMessage(\n    topic: string,\n    data: Uint8Array | string | any, // eslint-disable-line @typescript-eslint/no-explicit-any\n    lifetimeMs?: number\n  ): void;\n\n  /**\n   * Subscribe to receiving message on a topic\n   */\n  realtimeSubscribeToReceiveDataMessage(\n    topic: string,\n    callback: (dataMessage: DataMessage) => void\n  ): void;\n\n  /**\n   * Unsubscribe from a message topic\n   */\n  realtimeUnsubscribeFromReceiveDataMessage(topic: string): void;\n\n  /**\n   * Trigger callbacks when receiving a message from data channel\n   */\n  realtimeReceiveDataMessage(dataMessage: DataMessage): void;\n\n  // Error Handling\n\n  /**\n   * Subscribes to receive a callback when a fatal error is generated while\n   * processing an action. Receiving this callback potentially means that it was\n   * not possible to successfully mute, and so should be handled by tearing down\n   * the current connection and starting over.\n   */\n  realtimeSubscribeToFatalError(callback: (error: Error) => void): void;\n\n  /**\n   * Unsubscribes from receiving callbacks when fatal errors occur\n   */\n  realtimeUnsubscribeToFatalError(callback: (error: Error) => void): void;\n\n  /**\n   * Returns the [[TranscriptionController]] for this realtime controller.\n   */\n  readonly transcriptionController?: TranscriptionController;\n}\n"]}
{"version":3,"file":"Types.js","sourceRoot":"","sources":["../../src/utils/Types.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC;;;AAqBtC,MAAa,KAAK;IAChB,MAAM,CAAC,EAAE,CAAI,KAAe;QAC1B,OAAO,KAAK,KAAK,SAAS,IAAI,KAAK,KAAK,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,CAAC;IAC5E,CAAC;CACF;AAJD,sBAIC;AAkCD,MAAa,IAAI;IAIf,YAA4B,KAAQ;QAAR,UAAK,GAAL,KAAK,CAAG;QAH3B,WAAM,GAAY,IAAI,CAAC;QACvB,WAAM,GAAY,KAAK,CAAC;IAEM,CAAC;IAExC,GAAG,CAAI,CAAoB;QACzB,OAAO,KAAK,CAAC,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC;IACjC,CAAC;IAED,OAAO,CAAI,CAAqC;QAC9C,OAAO,CAAC,CAAC,IAAI,CAAC,KAAK,CAAC,CAAC;IACvB,CAAC;IAED,GAAG;QACD,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,SAAS,CAAC,MAAS;QACjB,OAAO,IAAI,CAAC,KAAK,CAAC;IACpB,CAAC;IAED,UAAU,CAAC,KAAQ;QACjB,OAAO,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,CAAC,EAAE,CAAI,KAAQ;QACnB,IAAI,KAAK,KAAK,IAAI,IAAI,KAAK,KAAK,SAAS,EAAE;YACzC,MAAM,IAAI,KAAK,CAAC,mBAAmB,CAAC,CAAC;SACtC;QACD,OAAO,IAAI,IAAI,CAAC,KAAK,CAAC,CAAC;IACzB,CAAC;CACF;AAhCD,oBAgCC;AAED,MAAa,IAAI;IAIf;QAHS,WAAM,GAAY,KAAK,CAAC;QACxB,WAAM,GAAY,IAAI,CAAC;IAET,CAAC;IAExB,GAAG;QACD,MAAM,IAAI,KAAK,CAAC,eAAe,CAAC,CAAC;IACnC,CAAC;IAED,SAAS,CAAC,KAAQ;QAChB,OAAO,KAAK,CAAC;IACf,CAAC;IAED,GAAG,CAAI,EAAsB;QAC3B,OAAO,IAAI,IAAI,EAAK,CAAC;IACvB,CAAC;IAED,OAAO,CAAI,EAAuC;QAChD,OAAO,IAAI,IAAI,EAAK,CAAC;IACvB,CAAC;IAED,UAAU,CAAC,KAAQ;QACjB,OAAO,KAAK,CAAC,EAAE,CAAC,IAAI,CAAC,SAAS,CAAC,KAAK,CAAC,CAAC,CAAC;IACzC,CAAC;IAED,MAAM,CAAC,EAAE;QACP,OAAO,IAAI,IAAI,EAAE,CAAC;IACpB,CAAC;CACF;AA7BD,oBA6BC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport interface Eq {\n  /**\n   * Return true if the other value is exactly equal to this value.\n   *\n   * @param other the value against which to compare.\n   */\n  equals(other: this): boolean;\n}\n\nexport interface PartialOrd {\n  /**\n   * Compare this value to another, returning a relative value as documented by\n   * [`Array.sort`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort#description)\n   *\n   * @param other the value against which to compare.\n   */\n  partialCompare(other: this): number;\n}\n\nexport class Maybe {\n  static of<T>(value: T | null): MaybeProvider<T> {\n    return value === undefined || value === null ? None.of() : Some.of(value);\n  }\n}\n\nexport interface MaybeProvider<T> {\n  readonly isSome: boolean;\n  readonly isNone: boolean;\n\n  /**\n   * Transform the mapped element and return a new {@link MaybeProvider} with the result.\n   *\n   * @param f the function to use\n   */\n  map<R>(f: (wrapped: T) => R): MaybeProvider<R>;\n\n  flatMap<R>(f: (unwrapped: T) => MaybeProvider<R>): MaybeProvider<R>;\n\n  get(): T;\n\n  /**\n   * Returns the some value or the provided default value.\n   *\n   * @param value the default value to use if this Maybe is none\n   * @returns the default value or the some value\n   */\n  getOrElse(value: T): T;\n\n  /**\n   * Default value wrapped in MaybeProvider<T>.\n   *\n   * @param value the value to wrap\n   * @returns a new {@link MaybeProvider}\n   */\n  defaulting(value: T): MaybeProvider<T>;\n}\n\nexport class Some<T> implements MaybeProvider<T> {\n  readonly isSome: boolean = true;\n  readonly isNone: boolean = false;\n\n  private constructor(private value: T) {}\n\n  map<R>(f: (wrapped: T) => R): MaybeProvider<R> {\n    return Maybe.of(f(this.value));\n  }\n\n  flatMap<R>(f: (unwrapped: T) => MaybeProvider<R>): MaybeProvider<R> {\n    return f(this.value);\n  }\n\n  get(): T {\n    return this.value;\n  }\n\n  getOrElse(_value: T): T {\n    return this.value;\n  }\n\n  defaulting(value: T): MaybeProvider<T> {\n    return Maybe.of(this.getOrElse(value));\n  }\n\n  static of<T>(value: T): MaybeProvider<T> {\n    if (value === null || value === undefined) {\n      throw new Error('value is ${value}');\n    }\n    return new Some(value);\n  }\n}\n\nexport class None<T> implements MaybeProvider<T> {\n  readonly isSome: boolean = false;\n  readonly isNone: boolean = true;\n\n  private constructor() {}\n\n  get(): T {\n    throw new Error('value is null');\n  }\n\n  getOrElse(value: T): T {\n    return value;\n  }\n\n  map<R>(_f: (_wrapped: T) => R): MaybeProvider<R> {\n    return new None<R>();\n  }\n\n  flatMap<R>(_f: (_unwrapped: T) => MaybeProvider<R>): MaybeProvider<R> {\n    return new None<R>();\n  }\n\n  defaulting(value: T): MaybeProvider<T> {\n    return Maybe.of(this.getOrElse(value));\n  }\n\n  static of<T>(): MaybeProvider<T> {\n    return new None();\n  }\n}\n"]}
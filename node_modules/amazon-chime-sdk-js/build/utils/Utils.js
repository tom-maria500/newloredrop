"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.iterateEvery = exports.SuppressedError = exports.getRandomValues = exports.getFormattedOffset = exports.getDefaultAssetSpec = exports.toLowerCasePropertyNames = exports.isIFramed = exports.wait = void 0;
const Versioning_1 = __importDefault(require("../versioning/Versioning"));
function wait(waitTimeMs) {
    return new Promise(resolve => setTimeout(resolve, waitTimeMs));
}
exports.wait = wait;
// This is impossible to adequately test in Node, so Istanbul ignore.
/* istanbul ignore next */
function isIFramed() {
    var _a;
    // Same-origin iframes can check `nodeName`.
    // We can also check whether the parent window and the top window are the same.
    // Cross-origin iframes will throw on the `parent` check, so catch here.
    try {
        return ((_a = window.frameElement) === null || _a === void 0 ? void 0 : _a.nodeName) === 'IFRAME' || parent !== top;
    }
    catch (e) {
        // Very likely to be a cross-origin iframe.
        return true;
    }
}
exports.isIFramed = isIFramed;
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function toLowerCasePropertyNames(input) {
    if (input === null) {
        return null;
    }
    else if (typeof input !== 'object') {
        return input;
    }
    else if (Array.isArray(input)) {
        return input.map(toLowerCasePropertyNames);
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return Object.keys(input).reduce((result, key) => {
        const value = input[key];
        const newValue = typeof value === 'object' ? toLowerCasePropertyNames(value) : value;
        result[key.toLowerCase()] = newValue;
        return result;
    }, {});
}
exports.toLowerCasePropertyNames = toLowerCasePropertyNames;
/**
 * Based on the SDK version, return an asset group.
 *
 * @returns the default asset spec, based on the SDK version.
 */
function getDefaultAssetSpec() {
    const version = Versioning_1.default.sdkVersionSemVer;
    return {
        assetGroup: `sdk-${version.major}.${version.minor}`,
    };
}
exports.getDefaultAssetSpec = getDefaultAssetSpec;
/**
 * Get UTC offset in (+|-)HH:mm format
 * E.g. For Asia/Calcutta timezone, +05:30 UTC offset value is returned
 */
function getFormattedOffset(utcOffset) {
    const offset = Math.abs(utcOffset);
    const offsetOperator = utcOffset <= 0 ? '+' : '-';
    const offsetHours = Math.floor(offset / 60)
        .toString()
        .padStart(2, '0');
    const offsetMinutes = Math.floor(offset % 60)
        .toString()
        .padStart(2, '0');
    return `${offsetOperator}${offsetHours}:${offsetMinutes}`;
}
exports.getFormattedOffset = getFormattedOffset;
function getRandomValues(buffer) {
    try {
        // Browser environment
        window.crypto.getRandomValues(buffer);
    }
    catch (error) {
        // Node environment for unit test
        const view = new DataView(buffer.buffer);
        view.setUint32(0, Math.trunc(Math.random() * Math.pow(2, 32)), true);
    }
}
exports.getRandomValues = getRandomValues;
/**
 * Shim for SuppressedError
 * https://github.com/tc39/proposal-explicit-resource-management?tab=readme-ov-file#the-suppressederror-error
 */
class SuppressedError extends Error {
    constructor(
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    error, suppressed, message) {
        var _a;
        /* istanbul ignore next -- because coverage can't detect all the branches */
        super(message !== null && message !== void 0 ? message : `${(_a = error === null || error === void 0 ? void 0 : error.message) !== null && _a !== void 0 ? _a : error}`);
        this.error = error;
        this.suppressed = suppressed;
    }
}
exports.SuppressedError = SuppressedError;
/**
 * Run a callback over the set of all values, suppress any errors, and only throw after iteration completes.
 * @param iterable - The iterable to iterate over
 * @param callback - The callback to run on each iteration
 * @throws If any of the callbacks throw an error
 */
function iterateEvery(iterable, callback) {
    if (!iterable)
        return;
    let suppressedError;
    for (const value of iterable) {
        try {
            callback(value);
        }
        catch (err) {
            suppressedError = new SuppressedError(err, suppressedError);
        }
    }
    if (suppressedError) {
        throw suppressedError;
    }
}
exports.iterateEvery = iterateEvery;
//# sourceMappingURL=Utils.js.map
{"version":3,"file":"DefaultVideoTransformDevice.js","sourceRoot":"","sources":["../../src/videoframeprocessor/DefaultVideoTransformDevice.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC;;;;;;;;;;;;;;AAGtC,uGAA+E;AAK/E,8GAAsF;AAMtF;;;GAGG;AACH,MAAqB,2BAA2B;IAQ9C,YACU,MAAc,EACd,MAAc,EACd,UAAiC,EACjC,kBAAmC,IAAI,gCAAsB,EAAE;QAH/D,WAAM,GAAN,MAAM,CAAQ;QACd,WAAM,GAAN,MAAM,CAAQ;QACd,eAAU,GAAV,UAAU,CAAuB;QACjC,oBAAe,GAAf,eAAe,CAAgD;QARjE,cAAS,GAA6C,IAAI,GAAG,EAElE,CAAC;QAQF,IAAI,CAAC,IAAI,GAAG,IAAI,4CAAkC,CAAC,IAAI,CAAC,MAAM,EAAE,IAAI,CAAC,UAAU,CAAC,CAAC;QACjF,IAAI,CAAC,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,CAAC;IAC9B,CAAC;IAED;;;;OAIG;IACH,IAAI,iBAAiB;QACnB,OAAO,IAAI,CAAC,IAAI,CAAC,iBAAiB,CAAC;IACrC,CAAC;IAED,gBAAgB;IAChB,+BAA+B,CAAC,eAAgC;QAC9D,0BAA0B;QAC1B,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;YACxB,KAAK,MAAM,SAAS,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE;gBAC5C,qEAAqE;gBACrE,2EAA2E;gBAC3E,IAAI,OAAO,SAAS,CAAC,kBAAkB,KAAK,UAAU,EAAE;oBACtD,SAAS,CAAC,kBAAkB,CAAC,eAAe,CAAC,CAAC;iBAC/C;aACF;SACF;IACH,CAAC;IAED;;;;OAIG;IACH,oBAAoB,CAAC,SAAiB;QACpC,MAAM,kBAAkB,GAAG,IAAI,2BAA2B,CACxD,IAAI,CAAC,MAAM,EACX,SAAS,EACT,IAAI,CAAC,UAAU,EACf,IAAI,CAAC,eAAe,CACrB,CAAC;QACF,kBAAkB,CAAC,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;QACpC,OAAO,kBAAkB,CAAC;IAC5B,CAAC;IAED;;OAEG;IACH,cAAc;QACZ,OAAO,IAAI,CAAC,MAAM,CAAC;IACrB,CAAC;IAEK,eAAe;;YACnB,OAAO,IAAI,CAAC,MAAM,CAAC;QACrB,CAAC;KAAA;IAED;;;OAGG;IACG,eAAe,CAAC,WAAyB;;YAC7C,MAAM,IAAI,CAAC,IAAI,CAAC,mBAAmB,CAAC,WAAW,CAAC,CAAC;YACjD,IAAI,CAAC,gBAAgB,GAAG,WAAW,CAAC;YACpC,OAAO,IAAI,CAAC,IAAI,CAAC,0BAA0B,EAAE,CAAC;QAChD,CAAC;KAAA;IAED;;;;;OAKG;IACH,wBAAwB;QACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,iEAAiE,CAAC,CAAC;QAEpF,MAAM,mBAAmB,GAAG,IAAI,CAAC,MAAM,IAAK,IAAI,CAAC,MAAsB,CAAC,EAAE,CAAC;QAE3E,mDAAmD;QACnD,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,CAAC;QAEjB,sDAAsD;QACtD,IAAI,CAAC,mBAAmB,EAAE;YACxB,IAAI,IAAI,CAAC,gBAAgB,EAAE;gBACzB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,EAAE;oBAC1D,KAAK,CAAC,IAAI,EAAE,CAAC;iBACd;aACF;SACF;IACH,CAAC;IAED;;;;OAIG;IACG,IAAI;;YACR,IAAI,IAAI,CAAC,gBAAgB,EAAE;gBACzB,KAAK,MAAM,KAAK,IAAI,IAAI,CAAC,gBAAgB,CAAC,cAAc,EAAE,EAAE;oBAC1D,KAAK,CAAC,IAAI,EAAE,CAAC;iBACd;aACF;YAED,IAAI,CAAC,IAAI,CAAC,OAAO,EAAE,CAAC;YACpB,IAAI,CAAC,gBAAgB,GAAG,IAAI,CAAC;QAC/B,CAAC;KAAA;IAED;;;;OAIG;IACH,WAAW,CAAC,QAA6C;QACvD,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;IAC/B,CAAC;IAED;;OAEG;IACH,cAAc,CAAC,QAA6C;QAC1D,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,QAAQ,CAAC,CAAC;IAClC,CAAC;IAED,kBAAkB;QAChB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,2CAA2C,CAAC,CAAC;QAC9D,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;YAC9B,IAAI,QAAQ,CAAC,kBAAkB,EAAE;gBAC/B,QAAQ,CAAC,kBAAkB,EAAE,CAAC;aAC/B;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,wBAAwB,CAAC,SAAiB;QACxC,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;YAC9B,IAAI,QAAQ,CAAC,wBAAwB,EAAE;gBACrC,QAAQ,CAAC,wBAAwB,CAAC,SAAS,CAAC,CAAC;aAC9C;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,wBAAwB;QACtB,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,mDAAmD,CAAC,CAAC;QACtE,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;YAC9B,IAAI,QAAQ,CAAC,wBAAwB,EAAE;gBACrC,QAAQ,CAAC,wBAAwB,EAAE,CAAC;aACrC;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAED,iBAAiB;QACf,IAAI,CAAC,MAAM,CAAC,IAAI,CAAC,2CAA2C,CAAC,CAAC;QAC9D,IAAI,CAAC,eAAe,CAAC,QAAQ,CAAC,EAAE;YAC9B,IAAI,QAAQ,CAAC,iBAAiB,EAAE;gBAC9B,QAAQ,CAAC,iBAAiB,EAAE,CAAC;aAC9B;QACH,CAAC,CAAC,CAAC;IACL,CAAC;IAEO,eAAe,CACrB,YAAqE;QAErE,KAAK,MAAM,QAAQ,IAAI,IAAI,CAAC,SAAS,EAAE;YACrC,UAAU,CAAC,GAAG,EAAE;gBACd,YAAY,CAAC,QAAQ,CAAC,CAAC;YACzB,CAAC,EAAE,CAAC,CAAC,CAAC;SACP;IACH,CAAC;IAED,IAAI,SAAS;QACX,OAAO,IAAI,CAAC,IAAI,CAAC,SAAS,CAAC;IAC7B,CAAC;IAED,IAAI,SAAS,CAAC,KAAa;QACzB,IAAI,CAAC,IAAI,CAAC,SAAS,GAAG,KAAK,CAAC;IAC9B,CAAC;CACF;AA1LD,8CA0LC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport BrowserBehavior from '../browserbehavior/BrowserBehavior';\nimport DefaultBrowserBehavior from '../browserbehavior/DefaultBrowserBehavior';\nimport Device from '../devicecontroller/Device';\nimport VideoTransformDevice from '../devicecontroller/VideoTransformDevice';\nimport EventController from '../eventcontroller/EventController';\nimport Logger from '../logger/Logger';\nimport DefaultVideoFrameProcessorPipeline from './DefaultVideoFrameProcessorPipeline';\nimport DefaultVideoTransformDeviceObserver from './DefaultVideoTransformDeviceObserver';\nimport VideoFrameProcessor from './VideoFrameProcessor';\nimport VideoFrameProcessorPipeline from './VideoFrameProcessorPipeline';\nimport VideoFrameProcessorPipelineObserver from './VideoFrameProcessorPipelineObserver';\n\n/**\n * [[DefaultVideoTransformDevice]] is an augmented [[VideoInputDevice]].\n * It transform the input {@link Device} with an array of {@link VideoFrameProcessor} to produce a `MediaStream`.\n */\nexport default class DefaultVideoTransformDevice\n  implements VideoTransformDevice, VideoFrameProcessorPipelineObserver {\n  private pipe: VideoFrameProcessorPipeline;\n  private inputMediaStream: MediaStream;\n  private observers: Set<DefaultVideoTransformDeviceObserver> = new Set<\n    DefaultVideoTransformDeviceObserver\n  >();\n\n  constructor(\n    private logger: Logger,\n    private device: Device,\n    private processors: VideoFrameProcessor[],\n    private browserBehavior: BrowserBehavior = new DefaultBrowserBehavior()\n  ) {\n    this.pipe = new DefaultVideoFrameProcessorPipeline(this.logger, this.processors);\n    this.pipe.addObserver(this);\n  }\n\n  /**\n   * getter for `outputMediaStream`.\n   * `outputMediaStream` is returned by internal {@link VideoFrameProcessorPipeline}.\n   * It is possible, but unlikely, that this accessor will throw.\n   */\n  get outputMediaStream(): MediaStream {\n    return this.pipe.outputMediaStream;\n  }\n\n  /** @internal */\n  passEventControllerToProcessors(eventController: EventController): void {\n    /* istanbul ignore else */\n    if (this.pipe.processors) {\n      for (const processor of this.pipe.processors) {\n        // Only certain processors are configured to provide event reporting,\n        // so here will confirm that the processor has event controller capablility\n        if (typeof processor.setEventController === 'function') {\n          processor.setEventController(eventController);\n        }\n      }\n    }\n  }\n\n  /**\n   * `chooseNewInnerDevice` preserves the inner pipeline and processing state and switches\n   * the inner device. Since the pipeline and processors are shared with the new transform device\n   * only one transform device can be used.\n   */\n  chooseNewInnerDevice(newDevice: Device): DefaultVideoTransformDevice {\n    const newTransformDevice = new DefaultVideoTransformDevice(\n      this.logger,\n      newDevice,\n      this.processors,\n      this.browserBehavior\n    );\n    newTransformDevice.pipe = this.pipe;\n    return newTransformDevice;\n  }\n\n  /**\n   * Return the inner device as provided during construction.\n   */\n  getInnerDevice(): Device {\n    return this.device;\n  }\n\n  async intrinsicDevice(): Promise<Device> {\n    return this.device;\n  }\n\n  /**\n   * Create {@link VideoFrameProcessorPipeline} if there is not a existing one and start video processors.\n   * Returns output `MediaStream` produced by {@link VideoFrameProcessorPipeline}.\n   */\n  async transformStream(mediaStream?: MediaStream): Promise<MediaStream> {\n    await this.pipe.setInputMediaStream(mediaStream);\n    this.inputMediaStream = mediaStream;\n    return this.pipe.getActiveOutputMediaStream();\n  }\n\n  /**\n   * onOutputStreamDisconnect is called when device controller wants to detach\n   * the transform device. The default behavior is to stop the output\n   * media stream and release the input the media stream. If the input media stream\n   * is the provided device, it will not be released.\n   */\n  onOutputStreamDisconnect(): void {\n    this.logger.info('DefaultVideoTransformDevice: detach stopping input media stream');\n\n    const deviceIsMediaStream = this.device && (this.device as MediaStream).id;\n\n    // Stop processing but keep the pipe and processors\n    this.pipe.stop();\n\n    // Turn off the camera, unless device is a MediaStream\n    if (!deviceIsMediaStream) {\n      if (this.inputMediaStream) {\n        for (const track of this.inputMediaStream.getVideoTracks()) {\n          track.stop();\n        }\n      }\n    }\n  }\n\n  /**\n   * Dispose of the inner workings of the transform device, including pipeline and processors.\n   * `stop` can only be called when the transform device is not used by device controller anymore.\n   * After `stop` is called, all transform devices which share the pipeline must be discarded.\n   */\n  async stop(): Promise<void> {\n    if (this.inputMediaStream) {\n      for (const track of this.inputMediaStream.getVideoTracks()) {\n        track.stop();\n      }\n    }\n\n    this.pipe.destroy();\n    this.inputMediaStream = null;\n  }\n\n  /**\n   * Add an observer to receive notifications about lifecycle events.\n   * See {@link DefaultVideoTransformDeviceObserver} for details.\n   * If the observer has already been added, this method call has no effect.\n   */\n  addObserver(observer: DefaultVideoTransformDeviceObserver): void {\n    this.observers.add(observer);\n  }\n\n  /**\n   * Remove an existing observer. If the observer has not been previously. this method call has no effect.\n   */\n  removeObserver(observer: DefaultVideoTransformDeviceObserver): void {\n    this.observers.delete(observer);\n  }\n\n  processingDidStart(): void {\n    this.logger.info('video transform device processing started');\n    this.forEachObserver(observer => {\n      if (observer.processingDidStart) {\n        observer.processingDidStart();\n      }\n    });\n  }\n\n  processingLatencyTooHigh(latencyMs: number): void {\n    this.forEachObserver(observer => {\n      if (observer.processingLatencyTooHigh) {\n        observer.processingLatencyTooHigh(latencyMs);\n      }\n    });\n  }\n\n  processingDidFailToStart(): void {\n    this.logger.info('video transform device processing failed to start');\n    this.forEachObserver(observer => {\n      if (observer.processingDidFailToStart) {\n        observer.processingDidFailToStart();\n      }\n    });\n  }\n\n  processingDidStop(): void {\n    this.logger.info('video transform device processing stopped');\n    this.forEachObserver(observer => {\n      if (observer.processingDidStop) {\n        observer.processingDidStop();\n      }\n    });\n  }\n\n  private forEachObserver(\n    observerFunc: (observer: VideoFrameProcessorPipelineObserver) => void\n  ): void {\n    for (const observer of this.observers) {\n      setTimeout(() => {\n        observerFunc(observer);\n      }, 0);\n    }\n  }\n\n  get framerate(): number {\n    return this.pipe.framerate;\n  }\n\n  set framerate(value: number) {\n    this.pipe.framerate = value;\n  }\n}\n"]}
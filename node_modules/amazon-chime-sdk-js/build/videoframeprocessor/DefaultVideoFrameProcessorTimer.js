"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
class DefaultVideoFrameProcessorTimer {
    constructor() {
        this.workerTimer = undefined;
        this.callback = undefined;
        this.workerTimer = this.createWorkerTimer();
    }
    // Create a timer that exists within a web worker. This timer will be used to
    // retrigger the process call whenever time expires.
    createWorkerTimer() {
        try {
            // Blob representing a script that will start a timer for the length
            // of the message posted to it. After timer expiration, it will post
            // a message back to the main thread holding the timerID
            const timerBlob = new Blob([
                `self.onmessage = async function(e){ 
            var timerID = null;
            const awaitTimeout = delay => new Promise( resolve => {
              timerID = setTimeout(resolve, delay);
            })
            await awaitTimeout(e.data);
            postMessage(timerID);
          }`,
            ], { type: 'application/javascript' });
            // Create the worker and link our process call to execute on
            // every message it posts
            const worker = new Worker(window.URL.createObjectURL(timerBlob));
            return worker;
        }
        catch (error) {
            // If blob: is not passed as a worker-src to csp, then the
            // worker timer will fail... therefore no support
        }
    }
    start(delay, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            this.callback = callback;
            if (this.workerTimer) {
                this.workerTimer.onmessage = event => {
                    this.lastTimeout = event.data;
                    this.callback();
                };
                this.workerTimer.postMessage(delay);
            }
            else {
                this.lastTimeout = setTimeout(() => {
                    this.callback();
                }, delay);
            }
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            this.callback = undefined;
            if (this.lastTimeout) {
                clearTimeout(this.lastTimeout);
                this.lastTimeout = undefined;
            }
            if (this.workerTimer) {
                this.workerTimer.terminate();
                this.workerTimer = undefined;
            }
        });
    }
}
exports.default = DefaultVideoFrameProcessorTimer;
//# sourceMappingURL=DefaultVideoFrameProcessorTimer.js.map
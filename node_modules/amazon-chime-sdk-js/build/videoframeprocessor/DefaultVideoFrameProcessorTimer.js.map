{"version":3,"file":"DefaultVideoFrameProcessorTimer.js","sourceRoot":"","sources":["../../src/videoframeprocessor/DefaultVideoFrameProcessorTimer.ts"],"names":[],"mappings":";AAAA,qEAAqE;AACrE,sCAAsC;;;;;;;;;;;AAItC,MAAqB,+BAA+B;IAKlD;QAJQ,gBAAW,GAAuB,SAAS,CAAC;QAE5C,aAAQ,GAA6B,SAAS,CAAC;QAGrD,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,iBAAiB,EAAE,CAAC;IAC9C,CAAC;IAED,6EAA6E;IAC7E,oDAAoD;IAC5C,iBAAiB;QACvB,IAAI;YACF,oEAAoE;YACpE,oEAAoE;YACpE,wDAAwD;YACxD,MAAM,SAAS,GAAG,IAAI,IAAI,CACxB;gBACE;;;;;;;YAOE;aACH,EACD,EAAE,IAAI,EAAE,wBAAwB,EAAE,CACnC,CAAC;YACF,4DAA4D;YAC5D,yBAAyB;YACzB,MAAM,MAAM,GAAG,IAAI,MAAM,CAAC,MAAM,CAAC,GAAG,CAAC,eAAe,CAAC,SAAS,CAAC,CAAC,CAAC;YACjE,OAAO,MAAM,CAAC;SACf;QAAC,OAAO,KAAK,EAAE;YACd,0DAA0D;YAC1D,iDAAiD;SAClD;IACH,CAAC;IAEK,KAAK,CAAC,KAAa,EAAE,QAAoB;;YAC7C,IAAI,CAAC,QAAQ,GAAG,QAAQ,CAAC;YAEzB,IAAI,IAAI,CAAC,WAAW,EAAE;gBACpB,IAAI,CAAC,WAAW,CAAC,SAAS,GAAG,KAAK,CAAC,EAAE;oBACnC,IAAI,CAAC,WAAW,GAAG,KAAK,CAAC,IAAI,CAAC;oBAC9B,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClB,CAAC,CAAC;gBACF,IAAI,CAAC,WAAW,CAAC,WAAW,CAAC,KAAK,CAAC,CAAC;aACrC;iBAAM;gBACL,IAAI,CAAC,WAAW,GAAG,UAAU,CAAC,GAAG,EAAE;oBACjC,IAAI,CAAC,QAAQ,EAAE,CAAC;gBAClB,CAAC,EAAE,KAAK,CAAC,CAAC;aACX;QACH,CAAC;KAAA;IAEK,OAAO;;YACX,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;YAC1B,IAAI,IAAI,CAAC,WAAW,EAAE;gBACpB,YAAY,CAAC,IAAI,CAAC,WAAW,CAAC,CAAC;gBAC/B,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;aAC9B;YACD,IAAI,IAAI,CAAC,WAAW,EAAE;gBACpB,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,CAAC;gBAC7B,IAAI,CAAC,WAAW,GAAG,SAAS,CAAC;aAC9B;QACH,CAAC;KAAA;CACF;AAlED,kDAkEC","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nimport VideoFrameProcessorTimer from './VideoFrameProcessorTimer';\n\nexport default class DefaultVideoFrameProcessorTimer implements VideoFrameProcessorTimer {\n  private workerTimer: Worker | undefined = undefined;\n  private lastTimeout: ReturnType<typeof setTimeout> | undefined;\n  private callback: (() => void) | undefined = undefined;\n\n  constructor() {\n    this.workerTimer = this.createWorkerTimer();\n  }\n\n  // Create a timer that exists within a web worker. This timer will be used to\n  // retrigger the process call whenever time expires.\n  private createWorkerTimer(): Worker {\n    try {\n      // Blob representing a script that will start a timer for the length\n      // of the message posted to it. After timer expiration, it will post\n      // a message back to the main thread holding the timerID\n      const timerBlob = new Blob(\n        [\n          `self.onmessage = async function(e){ \n            var timerID = null;\n            const awaitTimeout = delay => new Promise( resolve => {\n              timerID = setTimeout(resolve, delay);\n            })\n            await awaitTimeout(e.data);\n            postMessage(timerID);\n          }`,\n        ],\n        { type: 'application/javascript' }\n      );\n      // Create the worker and link our process call to execute on\n      // every message it posts\n      const worker = new Worker(window.URL.createObjectURL(timerBlob));\n      return worker;\n    } catch (error) {\n      // If blob: is not passed as a worker-src to csp, then the\n      // worker timer will fail... therefore no support\n    }\n  }\n\n  async start(delay: number, callback: () => void): Promise<void> {\n    this.callback = callback;\n\n    if (this.workerTimer) {\n      this.workerTimer.onmessage = event => {\n        this.lastTimeout = event.data;\n        this.callback();\n      };\n      this.workerTimer.postMessage(delay);\n    } else {\n      this.lastTimeout = setTimeout(() => {\n        this.callback();\n      }, delay);\n    }\n  }\n\n  async destroy(): Promise<void> {\n    this.callback = undefined;\n    if (this.lastTimeout) {\n      clearTimeout(this.lastTimeout);\n      this.lastTimeout = undefined;\n    }\n    if (this.workerTimer) {\n      this.workerTimer.terminate();\n      this.workerTimer = undefined;\n    }\n  }\n}\n"]}
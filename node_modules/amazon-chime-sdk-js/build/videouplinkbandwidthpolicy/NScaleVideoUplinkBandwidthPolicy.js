"use strict";
// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
// SPDX-License-Identifier: Apache-2.0
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const DefaultVideoCaptureAndEncodeParameter_1 = __importDefault(require("../videocaptureandencodeparameter/DefaultVideoCaptureAndEncodeParameter"));
/** NScaleVideoUplinkBandwidthPolicy implements capture and encode
 *  parameters that are nearly equivalent to those chosen by the
 *  traditional native clients, except for a modification to
 *  maxBandwidthKbps and scaleResolutionDownBy described below. */
class NScaleVideoUplinkBandwidthPolicy {
    constructor(selfAttendeeId, scaleResolution = true, logger = undefined, browserBehavior = undefined) {
        this.selfAttendeeId = selfAttendeeId;
        this.scaleResolution = scaleResolution;
        this.logger = logger;
        this.browserBehavior = browserBehavior;
        this.numberOfPublishedVideoSources = undefined;
        this.idealMaxBandwidthKbps = 1500;
        this.hasBandwidthPriority = false;
        this.encodingParamMap = new Map();
        this.enableHighResolutionFeature = false;
        this.enableSVC = false;
        this.isUsingSVCCodec = true;
        this.numParticipants = 0;
        this.reset();
    }
    reset() {
        // Don't reset `idealMaxBandwidthKbps` or `hasBandwidthPriority` which are set via builder API paths
        this.numberOfPublishedVideoSources = undefined;
        this.optimalParameters = new DefaultVideoCaptureAndEncodeParameter_1.default(0, 0, 0, 0, false);
        this.parametersInEffect = new DefaultVideoCaptureAndEncodeParameter_1.default(0, 0, 0, 0, false);
        this.encodingParamMap.set(NScaleVideoUplinkBandwidthPolicy.encodingMapKey, {
            maxBitrate: 0,
        });
    }
    updateConnectionMetric(_metrics) {
        return;
    }
    chooseMediaTrackConstraints() {
        return {};
    }
    chooseEncodingParameters() {
        return new Map();
    }
    updateIndex(videoIndex) {
        var _a;
        let hasLocalVideo = true;
        if (this.transceiverController) {
            hasLocalVideo = this.transceiverController.hasVideoInput();
        }
        // the +1 for self is assuming that we intend to send video, since
        // the context here is VideoUplinkBandwidthPolicy
        const numberOfPublishedVideoSources = videoIndex.numberOfVideoPublishingParticipantsExcludingSelf(this.selfAttendeeId) +
            (hasLocalVideo ? 1 : 0);
        const numParticipants = videoIndex.numberOfParticipants();
        if (this.numParticipants === numParticipants &&
            this.numberOfPublishedVideoSources === numberOfPublishedVideoSources) {
            (_a = this.logger) === null || _a === void 0 ? void 0 : _a.debug('Skipping update index; Number of participants has not changed');
            return;
        }
        this.numberOfPublishedVideoSources = numberOfPublishedVideoSources;
        this.numParticipants = numParticipants;
        this.updateOptimalParameters();
    }
    wantsResubscribe() {
        return !this.parametersInEffect.equal(this.optimalParameters);
    }
    chooseCaptureAndEncodeParameters() {
        this.parametersInEffect = this.optimalParameters.clone();
        return this.parametersInEffect.clone();
    }
    updateOptimalParameters() {
        let scale = 1;
        if (this.transceiverController) {
            const settings = this.getStreamCaptureSetting();
            if (settings) {
                const encodingParams = this.calculateEncodingParameters(settings);
                scale = encodingParams.scaleResolutionDownBy;
            }
        }
        this.optimalParameters = new DefaultVideoCaptureAndEncodeParameter_1.default(this.captureWidth(), this.captureHeight(), this.captureFrameRate(), this.maxBandwidthKbps(), false, scale, this.enableSVC && this.numParticipants > 2 && this.isUsingSVCCodec);
    }
    captureWidth() {
        let width = 640;
        if (this.getNumberOfPublishedVideoSources() > 4) {
            width = 320;
        }
        return width;
    }
    captureHeight() {
        let height = 384;
        if (this.getNumberOfPublishedVideoSources() > 4) {
            height = 192;
        }
        return height;
    }
    captureFrameRate() {
        return 15;
    }
    maxBandwidthKbps() {
        if (this.hasBandwidthPriority) {
            return Math.trunc(this.idealMaxBandwidthKbps);
        }
        let rate = 0;
        if (this.getNumberOfPublishedVideoSources() <= 2) {
            rate = this.idealMaxBandwidthKbps;
        }
        else if (this.getNumberOfPublishedVideoSources() <= 4) {
            rate = (this.idealMaxBandwidthKbps * 2) / 3;
        }
        else {
            rate =
                ((544 / 11 + 14880 / (11 * this.getNumberOfPublishedVideoSources())) / 600) *
                    this.idealMaxBandwidthKbps;
        }
        return Math.trunc(rate);
    }
    setIdealMaxBandwidthKbps(idealMaxBandwidthKbps) {
        this.idealMaxBandwidthKbps = idealMaxBandwidthKbps;
    }
    setHasBandwidthPriority(hasBandwidthPriority) {
        this.hasBandwidthPriority = hasBandwidthPriority;
    }
    setTransceiverController(transceiverController) {
        this.transceiverController = transceiverController;
    }
    setSVCEnabled(enable) {
        var _a;
        this.enableSVC = enable;
        (_a = this.logger) === null || _a === void 0 ? void 0 : _a.info(`setSVCEnabled, enable: ${enable}}`);
    }
    setHighResolutionFeatureEnabled(enabled) {
        this.enableHighResolutionFeature = enabled;
    }
    updateTransceiverController() {
        return __awaiter(this, void 0, void 0, function* () {
            const settings = this.getStreamCaptureSetting();
            if (!settings) {
                return;
            }
            const encodingParams = this.calculateEncodingParameters(settings);
            if (this.shouldUpdateEndcodingParameters(encodingParams)) {
                this.encodingParamMap.set(NScaleVideoUplinkBandwidthPolicy.encodingMapKey, encodingParams);
                this.transceiverController.setEncodingParameters(this.encodingParamMap);
            }
        });
    }
    shouldUpdateEndcodingParameters(encoding) {
        var _a, _b;
        const transceiverEncoding = (_b = (_a = this.transceiverController
            .localVideoTransceiver()
            .sender.getParameters()) === null || _a === void 0 ? void 0 : _a.encodings) === null || _b === void 0 ? void 0 : _b[0];
        /* istanbul ignore next: transceiverEncoding?.scaleResolutionDownBy cannot be covered */
        return (encoding.maxBitrate !== (transceiverEncoding === null || transceiverEncoding === void 0 ? void 0 : transceiverEncoding.maxBitrate) ||
            encoding.scaleResolutionDownBy !== (transceiverEncoding === null || transceiverEncoding === void 0 ? void 0 : transceiverEncoding.scaleResolutionDownBy) ||
            // @ts-ignore
            (encoding === null || encoding === void 0 ? void 0 : encoding.scalabilityMode) !== (transceiverEncoding === null || transceiverEncoding === void 0 ? void 0 : transceiverEncoding.scalabilityMode));
    }
    calculateEncodingParameters(setting) {
        var _a, _b, _c;
        const maxBitrate = this.maxBandwidthKbps() * 1000;
        let scale = 1;
        let targetHeight = 720;
        if (setting.height !== undefined &&
            setting.width !== undefined &&
            this.scaleResolution &&
            !this.hasBandwidthPriority &&
            this.getNumberOfPublishedVideoSources() > 2) {
            targetHeight =
                NScaleVideoUplinkBandwidthPolicy.targetHeightArray[Math.min(this.getNumberOfPublishedVideoSources(), NScaleVideoUplinkBandwidthPolicy.targetHeightArray.length - 1)][this.enableHighResolutionFeature ? 1 : 0];
            //Workaround for issue https://github.com/aws/amazon-chime-sdk-js/issues/2002
            if (targetHeight === 480 && ((_a = this.browserBehavior) === null || _a === void 0 ? void 0 : _a.disable480pResolutionScaleDown())) {
                targetHeight = 360;
            }
            scale = Math.max(Math.min(setting.height, setting.width) / targetHeight, 1);
            (_b = this.logger) === null || _b === void 0 ? void 0 : _b.info(`Resolution scale factor is ${scale} for capture resolution ${setting.width}x${setting.height}. New dimension is ${setting.width / scale}x${setting.height / scale}`);
        }
        if (this.enableSVC) {
            let scalabilityMode;
            if ((this.numParticipants >= 0 && this.numParticipants < 3) || !this.isUsingSVCCodec) {
                scalabilityMode = 'L1T1';
            }
            else {
                // We do not limit the number of layers depending on input resolution, however Chrome will drop anything below around 135p.
                scalabilityMode = 'L3T3';
            }
            (_c = this.logger) === null || _c === void 0 ? void 0 : _c.info(`calculateEncodingParameters: SVC: ${this.enableSVC}    participants: ${this.numParticipants}     publishers: ${this.getNumberOfPublishedVideoSources()}     bitrate: ${maxBitrate}  targetHeight: ${targetHeight}  scalabilityMode: ${scalabilityMode}   isUsingSVCCodec: ${this.isUsingSVCCodec}`);
            return {
                scaleResolutionDownBy: scale,
                maxBitrate: maxBitrate,
                // @ts-ignore
                scalabilityMode: scalabilityMode,
            };
        }
        else {
            return {
                scaleResolutionDownBy: scale,
                maxBitrate: maxBitrate,
            };
        }
    }
    getStreamCaptureSetting() {
        var _a, _b, _c, _d;
        return (_d = (_c = (_b = (_a = this.transceiverController) === null || _a === void 0 ? void 0 : _a.localVideoTransceiver()) === null || _b === void 0 ? void 0 : _b.sender) === null || _c === void 0 ? void 0 : _c.track) === null || _d === void 0 ? void 0 : _d.getSettings();
    }
    getNumberOfPublishedVideoSources() {
        var _a;
        /* istanbul ignore next: policy calculation is dependent on index so this is never undefined at time of use */
        return (_a = this.numberOfPublishedVideoSources) !== null && _a !== void 0 ? _a : 0;
    }
    wantsVideoDependencyDescriptorRtpHeaderExtension() {
        return this.enableSVC;
    }
    setMeetingSupportedVideoSendCodecs(meetingSupportedVideoSendCodecPreferences, videoSendCodecPreferences) {
        const codecs = meetingSupportedVideoSendCodecPreferences !== null && meetingSupportedVideoSendCodecPreferences !== void 0 ? meetingSupportedVideoSendCodecPreferences : videoSendCodecPreferences;
        const isUsingSVCCodec = codecs.length > 0 &&
            NScaleVideoUplinkBandwidthPolicy.SVCCodecNames.includes(codecs[0].codecName);
        if (isUsingSVCCodec !== this.isUsingSVCCodec) {
            this.isUsingSVCCodec = isUsingSVCCodec;
            this.updateOptimalParameters();
        }
    }
}
exports.default = NScaleVideoUplinkBandwidthPolicy;
NScaleVideoUplinkBandwidthPolicy.encodingMapKey = 'video';
// 0, 1, 2 have dummy value as we keep the original resolution if we have less than 2 videos.
// For each video cource, we define a target height for low resoultion and high resolution,
// respectively. This is corresponding to the meeting feature specified for the meeting.
NScaleVideoUplinkBandwidthPolicy.targetHeightArray = [
    [0, 0],
    [0, 0],
    [0, 0],
    [540, 720],
    [540, 720],
    [480, 540],
    [480, 540],
    [480, 540],
    [480, 540],
    [360, 480],
    [360, 480],
    [360, 480],
    [360, 480],
    [270, 360],
    [270, 360],
    [270, 360],
    [270, 360],
    [180, 270],
    [180, 270],
    [180, 270],
    [180, 270],
    [180, 270],
    [180, 270],
    [180, 270],
    [180, 270],
    [180, 270], // 25
];
NScaleVideoUplinkBandwidthPolicy.SVCCodecNames = ['VP9'];
//# sourceMappingURL=NScaleVideoUplinkBandwidthPolicy.js.map
import Logger from '../logger/Logger';
import SimulcastLayers from '../simulcastlayers/SimulcastLayers';
import DefaultVideoAndEncodeParameter from '../videocaptureandencodeparameter/DefaultVideoCaptureAndEncodeParameter';
import VideoStreamIndex from '../videostreamindex/VideoStreamIndex';
import ConnectionMetrics from './ConnectionMetrics';
import SimulcastUplinkObserver from './SimulcastUplinkObserver';
import SimulcastUplinkPolicy from './SimulcastUplinkPolicy';
declare const enum ActiveStreams {
    kHi = 0,
    kHiAndLow = 1,
    kMidAndLow = 2
}
/**
 * [[DefaultSimulcastUplinkPolicy]] determines capture and encode
 *  parameters that reacts to estimated uplink bandwidth
 */
export default class DefaultSimulcastUplinkPolicy implements SimulcastUplinkPolicy {
    private selfAttendeeId;
    private logger;
    static readonly kHiTargetBitrateKbpsHd = 1200;
    static readonly kMidTargetBitrateKbpsHd = 600;
    static readonly kLowTargetBitrateKbpsHd = 300;
    static readonly kHiTargetBitrateKbpsFhd = 2000;
    static readonly kMidTargetBitrateKbpsFhd = 1000;
    static readonly kLowTargetBitrateKbpsFhd = 500;
    private numSenders;
    private shouldDisableSimulcast;
    private optimalParameters;
    private parametersInEffect;
    private newQualityMap;
    private currentQualityMap;
    private newActiveStreams;
    private videoIndex;
    private activeStreamsToPublish;
    private observerQueue;
    private hiTargetBitrateKbps;
    private midTargetBitrateKbps;
    private lowTargetBitrateKbps;
    private enableFhdVideo;
    constructor(selfAttendeeId: string, logger: Logger);
    updateConnectionMetric(_metrics: ConnectionMetrics): void;
    private calculateEncodingParameters;
    chooseMediaTrackConstraints(): MediaTrackConstraints;
    chooseEncodingParameters(): Map<string, RTCRtpEncodingParameters>;
    updateIndex(videoIndex: VideoStreamIndex): void;
    wantsResubscribe(): boolean;
    private compareEncodingParameter;
    private encodingParametersEqual;
    chooseCaptureAndEncodeParameters(): DefaultVideoAndEncodeParameter;
    private captureWidth;
    private captureHeight;
    private captureFrameRate;
    maxBandwidthKbps(): number;
    setIdealMaxBandwidthKbps(_idealMaxBandwidthKbps: number): void;
    setHasBandwidthPriority(_hasBandwidthPriority: boolean): void;
    setHighResolutionFeatureEnabled(enabled: boolean): void;
    wantsVideoDependencyDescriptorRtpHeaderExtension(): boolean;
    private fillEncodingParamWithBitrates;
    private getQualityMapString;
    getEncodingSimulcastLayer(activeStreams: ActiveStreams): SimulcastLayers;
    private publishEncodingSimulcastLayer;
    addObserver(observer: SimulcastUplinkObserver): void;
    removeObserver(observer: SimulcastUplinkObserver): void;
    forEachObserver(observerFunc: (observer: SimulcastUplinkObserver) => void): void;
}
export {};

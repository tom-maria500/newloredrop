{"version":3,"file":"RedundantAudioEncoder.js","sourceRoot":"","sources":["../../src/redundantaudioencoder/RedundantAudioEncoder.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\n\nexport default class RedundantAudioEncoder {\n  // Each payload must be less than 1024 bytes to fit the 10 bit block length\n  private readonly maxRedPacketSizeBytes = 1 << 10;\n\n  // Limit payload to 1000 bytes to handle small MTU. 1000 is chosen because in Chromium-based browsers, writing audio\n  // payloads larger than 1000 bytes using the WebRTC Insertable Streams API (which is used to enable dynamic audio\n  // redundancy) will cause an error to be thrown and cause audio flow to permanently stop. See\n  // https://crbug.com/1248479.\n  private readonly maxAudioPayloadSizeBytes = 1000;\n\n  // Each payload can encode a timestamp delta of 14 bits\n  private readonly maxRedTimestampOffset = 1 << 14;\n\n  // 4 byte RED header\n  private readonly redHeaderSizeBytes = 4;\n\n  // reduced size for last RED header\n  private readonly redLastHeaderSizeBytes = 1;\n\n  // P-Time for Opus 20 msec packets\n  // We do not support other p-times or clock rates\n  private readonly redPacketizationTime = 960;\n\n  // distance between redundant payloads, Opus FEC handles a distance of 1\n  // TODO(https://issues.amazon.com/issues/ChimeSDKAudio-55):\n  // Consider making this dynamic\n  private readonly redPacketDistance = 2;\n\n  // maximum number of redundant payloads per RTP packet\n  private readonly maxRedEncodings = 2;\n\n  // Maximum number of encodings that can be recovered with a single RED packet, assuming the primary and redundant\n  // payloads have FEC.\n  private readonly redMaxRecoveryDistance = this.redPacketDistance * this.maxRedEncodings + 1;\n\n  // maximum history of prior payloads to keep\n  // generally we will expire old entries based on timestamp\n  // this limit is in place just to make sure the history does not\n  // grow too large in the case of erroneous timestamp inputs\n  private readonly maxEncodingHistorySize = 10;\n\n  // Holds the RED payload type obtained from the local SDP\n  // This is updated when the transceiver controller sends\n  // a message of type RedPayloadType\n  private redPayloadType: number;\n\n  // Holds the RED payload type obtained from the local SDP\n  // This is updated when the transceiver controller sends\n  // a message of type RedPayloadType\n  private opusPayloadType: number;\n\n  // Current number of encodings we want to send\n  // to the remote end. This will be dynamically\n  // updated through the setNumEncodingsFromPacketloss API\n  private numRedundantEncodings: number = 0;\n\n  // Holds a history of primary payloads in order\n  // oldest to newest\n  private encodingHistory: Array<RedundantAudioEncoder.Encoding>;\n\n  // Used to enable or disable redundancy\n  // in response to very high packet loss events\n  private redundancyEnabled: boolean = true;\n\n  // This is a workaround for unit testing due to issues with mocking `self`\n  // which is a part of DedicatedWorker scope and is currently used to post\n  // messages to the main thread\n  static shouldLog: boolean = false;\n\n  // This is a workaround for unit testing due to issues with mocking `self`\n  // which is a part of DedicatedWorker scope and is currently used to post\n  // messages to the main thread\n  static shouldReportStats: boolean = false;\n\n  constructor() {\n    this.encodingHistory = new Array<RedundantAudioEncoder.Encoding>();\n    this.opusPayloadType = 0;\n    this.redPayloadType = 0;\n    this.initializePacketLogs();\n  }\n\n  /**\n   * Creates an instance of RedundantAudioEncoder and sets up callbacks.\n   */\n  static initializeWorker(): void {\n    RedundantAudioEncoder.log('Initializing RedundantAudioEncoder');\n    const encoder = new RedundantAudioEncoder();\n\n    // RED encoding is done using WebRTC Encoded Transform\n    // https://github.com/w3c/webrtc-encoded-transform/blob/main/explainer.md\n\n    // Check the DedicatedWorkerGlobalScope for existence of\n    // RTCRtpScriptTransformer interface. If exists, then\n    // RTCRtpScriptTransform is supported by this browser.\n    // @ts-ignore\n    if (self.RTCRtpScriptTransformer) {\n      // @ts-ignore\n      self.onrtctransform = (event: RTCTransformEvent) => {\n        if (event.transformer.options.type === 'SenderTransform') {\n          encoder.setupSenderTransform(event.transformer.readable, event.transformer.writable);\n        } else if (event.transformer.options.type === 'ReceiverTransform') {\n          encoder.setupReceiverTransform(event.transformer.readable, event.transformer.writable);\n        } else if (event.transformer.options.type === 'PassthroughTransform') {\n          encoder.setupPassthroughTransform(event.transformer.readable, event.transformer.writable);\n        }\n      };\n    }\n\n    self.onmessage = (event: MessageEvent) => {\n      if (event.data.msgType === 'StartRedWorker') {\n        encoder.setupSenderTransform(event.data.send.readable, event.data.send.writable);\n        encoder.setupReceiverTransform(event.data.receive.readable, event.data.receive.writable);\n      } else if (event.data.msgType === 'PassthroughTransform') {\n        encoder.setupPassthroughTransform(event.data.send.readable, event.data.send.writable);\n        encoder.setupPassthroughTransform(event.data.receive.readable, event.data.receive.writable);\n      } else if (event.data.msgType === 'RedPayloadType') {\n        encoder.setRedPayloadType(event.data.payloadType);\n      } else if (event.data.msgType === 'OpusPayloadType') {\n        encoder.setOpusPayloadType(event.data.payloadType);\n      } else if (event.data.msgType === 'UpdateNumRedundantEncodings') {\n        encoder.setNumRedundantEncodings(event.data.numRedundantEncodings);\n      } else if (event.data.msgType === 'Enable') {\n        encoder.setRedundancyEnabled(true);\n      } else if (event.data.msgType === 'Disable') {\n        encoder.setRedundancyEnabled(false);\n      }\n    };\n  }\n\n  /**\n   * Post logs to the main thread\n   */\n  static log(msg: string): void {\n    if (RedundantAudioEncoder.shouldLog) {\n      // @ts-ignore\n      self.postMessage({\n        type: 'REDWorkerLog',\n        log: `[AudioRed] ${msg}`,\n      });\n    }\n  }\n\n  /**\n   * Returns the number of encodings based on packetLoss value. This is used by `DefaultTransceiverController` to\n   * determine when to alert the encoder to update the number of encodings. It also determines if we need to\n   * turn off red in cases of very high packet loss to avoid congestion collapse.\n   */\n  static getNumRedundantEncodingsForPacketLoss(packetLoss: number): [number, boolean] {\n    let recommendedRedundantEncodings = 0;\n    let shouldTurnOffRed = false;\n    if (packetLoss <= 8) {\n      recommendedRedundantEncodings = 0;\n    } else if (packetLoss <= 18) {\n      recommendedRedundantEncodings = 1;\n    } else if (packetLoss <= 75) {\n      recommendedRedundantEncodings = 2;\n    } else {\n      recommendedRedundantEncodings = 0;\n      shouldTurnOffRed = true;\n    }\n    return [recommendedRedundantEncodings, shouldTurnOffRed];\n  }\n\n  /**\n   * Sets up a passthrough (no-op) transform for the given streams.\n   */\n  setupPassthroughTransform(readable: ReadableStream, writable: WritableStream): void {\n    RedundantAudioEncoder.log('Setting up passthrough transform');\n    readable.pipeTo(writable);\n  }\n\n  /**\n   * Sets up the transform stream and pipes the outgoing encoded audio frames through the transform function.\n   */\n  setupSenderTransform(readable: ReadableStream, writable: WritableStream): void {\n    RedundantAudioEncoder.log('Setting up sender RED transform');\n    const transformStream = new TransformStream({\n      transform: this.senderTransform.bind(this),\n    });\n    readable.pipeThrough(transformStream).pipeTo(writable);\n    return;\n  }\n\n  /**\n   * Sets up the transform stream and pipes the received encoded audio frames through the transform function.\n   */\n  setupReceiverTransform(readable: ReadableStream, writable: WritableStream): void {\n    RedundantAudioEncoder.log('Setting up receiver RED transform');\n    const transformStream = new TransformStream({\n      transform: this.receivePacketLogTransform.bind(this),\n    });\n    readable.pipeThrough(transformStream).pipeTo(writable);\n    return;\n  }\n\n  /**\n   * Set the RED payload type ideally obtained from local offer.\n   */\n  setRedPayloadType(payloadType: number): void {\n    this.redPayloadType = payloadType;\n    RedundantAudioEncoder.log(`red payload type set to ${this.redPayloadType}`);\n  }\n\n  /**\n   * Set the opus payload type ideally obtained from local offer.\n   */\n  setOpusPayloadType(payloadType: number): void {\n    this.opusPayloadType = payloadType;\n    RedundantAudioEncoder.log(`opus payload type set to ${this.opusPayloadType}`);\n  }\n\n  /**\n   * Set the number of redundant encodings\n   */\n  setNumRedundantEncodings(numRedundantEncodings: number): void {\n    this.numRedundantEncodings = numRedundantEncodings;\n    if (this.numRedundantEncodings > this.maxRedEncodings) {\n      this.numRedundantEncodings = this.maxRedEncodings;\n    }\n    RedundantAudioEncoder.log(`Updated numRedundantEncodings to ${this.numRedundantEncodings}`);\n  }\n\n  /**\n   * Enable or disable redundancy in response to\n   * high packet loss event.\n   */\n  setRedundancyEnabled(enabled: boolean): void {\n    this.redundancyEnabled = enabled;\n    RedundantAudioEncoder.log(`redundancy ${this.redundancyEnabled ? 'enabled' : 'disabled'}`);\n  }\n\n  /**\n   * Helper function to only enqueue audio frames if they do not exceed the audio payload byte limit imposed by\n   * Chromium-based browsers. Chromium will throw an error (https://crbug.com/1248479) if an audio payload larger than\n   * 1000 bytes is enqueued. Any controller that attempts to enqueue an audio payload larger than 1000 bytes will\n   * encounter this error and will permanently stop sending or receiving audio.\n   */\n  private enqueueAudioFrameIfPayloadSizeIsValid(\n    // @ts-ignore\n    frame: RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController\n  ): void {\n    if (frame.data.byteLength > this.maxAudioPayloadSizeBytes) return;\n    controller.enqueue(frame);\n  }\n\n  /**\n   * Receives encoded frames and modifies as needed before sending to transport.\n   */\n  private senderTransform(\n    // @ts-ignore\n    frame: RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController\n  ): void {\n    const frameMetadata = frame.getMetadata();\n    // @ts-ignore\n    if (frameMetadata.payloadType !== this.redPayloadType) {\n      this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n      return;\n    }\n    const primaryPayloadBuffer = this.getPrimaryPayload(frame.timestamp, frame.data);\n    if (!primaryPayloadBuffer) {\n      this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n      return;\n    }\n    const encodedBuffer = this.encode(frame.timestamp, primaryPayloadBuffer);\n    /* istanbul ignore next */\n    if (!encodedBuffer) {\n      this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n      return;\n    }\n    frame.data = encodedBuffer;\n    this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n    return;\n  }\n\n  /**\n   * Get the primary payload from encoding\n   */\n  private getPrimaryPayload(primaryTimestamp: number, frame: ArrayBuffer): ArrayBuffer | null {\n    const encodings = this.splitEncodings(primaryTimestamp, frame);\n    if (!encodings || encodings.length < 1) return null;\n    return encodings[encodings.length - 1].payload;\n  }\n\n  /**\n   * Split up the encoding received into primary and redundant encodings\n   * These will be ordered oldest to newest which is the same ordering\n   * in the RTP red payload.\n   */\n  private splitEncodings(\n    primaryTimestamp: number,\n    frame: ArrayBuffer,\n    getFecInfo: boolean = false,\n    primarySequenceNumber: number = undefined\n  ): RedundantAudioEncoder.Encoding[] | null {\n    // process RED headers (according to RFC 2198)\n    //   0                   1                   2                   3\n    //   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //  |F|   block PT  |  timestamp offset         |   block length    |\n    //  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    //\n    // last header\n    //   0 1 2 3 4 5 6 7\n    //  +-+-+-+-+-+-+-+-+\n    //  |0|   Block PT  |\n    //  +-+-+-+-+-+-+-+-+\n\n    const payload = new DataView(frame);\n    let payloadSizeBytes = payload.byteLength;\n    let totalPayloadSizeBytes = 0;\n    let totalHeaderSizeBytes = 0;\n    let primaryPayloadSizeBytes = 0;\n    let payloadOffset = 0;\n    let gotLastBlock = false;\n    const encodings = new Array<RedundantAudioEncoder.Encoding>();\n    const redundantEncodingBlockLengths = new Array();\n    const redundantEncodingTimestamps = new Array();\n\n    while (payloadSizeBytes > 0) {\n      gotLastBlock = (payload.getUint8(payloadOffset) & 0x80) === 0;\n      if (gotLastBlock) {\n        // Bits 1 through 7 are payload type\n        const payloadType = payload.getUint8(payloadOffset) & 0x7f;\n\n        // Unexpected payload type. This is a bad packet.\n        if (payloadType !== this.opusPayloadType) {\n          return null;\n        }\n\n        totalPayloadSizeBytes += this.redLastHeaderSizeBytes;\n        totalHeaderSizeBytes += this.redLastHeaderSizeBytes;\n\n        // Accumulated block lengths are equal to or larger than the buffer, which means there is no primary block. This\n        // is a bad packet.\n        if (totalPayloadSizeBytes >= payload.byteLength) {\n          return null;\n        }\n\n        primaryPayloadSizeBytes = payload.byteLength - totalPayloadSizeBytes;\n        break;\n      } else {\n        if (payloadSizeBytes < this.redHeaderSizeBytes) {\n          return null;\n        }\n\n        // Bits 22 through 31 are payload length\n        const blockLength =\n          ((payload.getUint8(payloadOffset + 2) & 0x03) << 8) + payload.getUint8(payloadOffset + 3);\n        redundantEncodingBlockLengths.push(blockLength);\n        const timestampOffset = payload.getUint16(payloadOffset + 1) >> 2;\n        const timestamp = primaryTimestamp - timestampOffset;\n        redundantEncodingTimestamps.push(timestamp);\n        totalPayloadSizeBytes += blockLength + this.redHeaderSizeBytes;\n        totalHeaderSizeBytes += this.redHeaderSizeBytes;\n        payloadOffset += this.redHeaderSizeBytes;\n        payloadSizeBytes -= this.redHeaderSizeBytes;\n      }\n    }\n\n    // The last block was never found. The packet we received\n    // does not have a good RED payload.\n    if (!gotLastBlock) {\n      // Note that sequence numbers only exist for\n      // incoming audio frames.\n      if (primarySequenceNumber !== undefined) {\n        // This could be a possible padding packet used\n        // for BWE with a good sequence number.\n        // Create a dummy encoding to make sure loss values\n        // are calculated correctly by consuming sequence number.\n        // Note that for the receive side, we process packets only\n        // for loss/recovery calculations and forward the original\n        // packet without changing it even in the error case.\n        encodings.push({\n          payload: frame,\n          isRedundant: false,\n          seq: primarySequenceNumber,\n        });\n        return encodings;\n      }\n      // This is a bad packet.\n      return null;\n    }\n\n    let redundantPayloadOffset = totalHeaderSizeBytes;\n    for (let i = 0; i < redundantEncodingTimestamps.length; i++) {\n      const redundantPayloadBuffer = new ArrayBuffer(redundantEncodingBlockLengths[i]);\n      const redundantPayloadArray = new Uint8Array(redundantPayloadBuffer);\n      redundantPayloadArray.set(\n        new Uint8Array(payload.buffer, redundantPayloadOffset, redundantEncodingBlockLengths[i]),\n        0\n      );\n      const encoding: RedundantAudioEncoder.Encoding = {\n        timestamp: redundantEncodingTimestamps[i],\n        payload: redundantPayloadBuffer,\n        isRedundant: true,\n      };\n      if (getFecInfo) {\n        encoding.hasFec = this.opusPacketHasFec(\n          new DataView(redundantPayloadBuffer),\n          redundantPayloadBuffer.byteLength\n        );\n      }\n      encodings.push(encoding);\n      redundantPayloadOffset += redundantEncodingBlockLengths[i];\n    }\n\n    const primaryPayloadOffset = payload.byteLength - primaryPayloadSizeBytes;\n    const primaryPayloadBuffer = new ArrayBuffer(primaryPayloadSizeBytes);\n    const primaryArray = new Uint8Array(primaryPayloadBuffer);\n    primaryArray.set(\n      new Uint8Array(payload.buffer, primaryPayloadOffset, primaryPayloadSizeBytes),\n      0\n    );\n    const encoding: RedundantAudioEncoder.Encoding = {\n      timestamp: primaryTimestamp,\n      payload: primaryPayloadBuffer,\n      isRedundant: false,\n      seq: primarySequenceNumber,\n    };\n    if (getFecInfo) {\n      encoding.hasFec = this.opusPacketHasFec(\n        new DataView(primaryPayloadBuffer),\n        primaryPayloadBuffer.byteLength\n      );\n    }\n    encodings.push(encoding);\n    return encodings;\n  }\n\n  /**\n   * Create a new encoding with current primary payload and the older payloads of choice.\n   */\n  private encode(primaryTimestamp: number, primaryPayload: ArrayBuffer): ArrayBuffer | null {\n    const primaryPayloadSize = primaryPayload.byteLength;\n\n    // Payload size needs to be valid.\n    if (\n      primaryPayloadSize === 0 ||\n      primaryPayloadSize >= this.maxRedPacketSizeBytes ||\n      primaryPayloadSize >= this.maxAudioPayloadSizeBytes\n    ) {\n      return null;\n    }\n\n    const numRedundantEncodings = this.numRedundantEncodings;\n    let headerSizeBytes = this.redLastHeaderSizeBytes;\n    let payloadSizeBytes = primaryPayloadSize;\n    let bytesAvailable = this.maxAudioPayloadSizeBytes - primaryPayloadSize - headerSizeBytes;\n    const redundantEncodingTimestamps: Array<number> = new Array();\n    const redundantEncodingPayloads: Array<ArrayBuffer> = new Array();\n\n    // If redundancy is disabled then only send the primary payload\n    if (this.redundancyEnabled) {\n      // Determine how much redundancy we can fit into our packet\n      let redundantTimestamp = this.uint32WrapAround(\n        primaryTimestamp - this.redPacketizationTime * this.redPacketDistance\n      );\n      for (let i = 0; i < numRedundantEncodings; i++) {\n        // Do not add redundant encodings that are beyond the maximum timestamp offset.\n        if (\n          this.uint32WrapAround(primaryTimestamp - redundantTimestamp) >= this.maxRedTimestampOffset\n        ) {\n          break;\n        }\n\n        let findTimestamp = redundantTimestamp;\n        let encoding = this.encodingHistory.find(e => e.timestamp === findTimestamp);\n\n        if (!encoding) {\n          // If not found or not important then look for the previous packet.\n          // The current packet may have included FEC for the previous, so just\n          // use the previous packet instead provided that it has voice activity.\n          findTimestamp = this.uint32WrapAround(redundantTimestamp - this.redPacketizationTime);\n          encoding = this.encodingHistory.find(e => e.timestamp === findTimestamp);\n        }\n\n        if (encoding) {\n          const redundantEncodingSizeBytes = encoding.payload.byteLength;\n\n          // Only add redundancy if there are enough bytes available.\n          if (bytesAvailable < this.redHeaderSizeBytes + redundantEncodingSizeBytes) break;\n\n          bytesAvailable -= this.redHeaderSizeBytes + redundantEncodingSizeBytes;\n          headerSizeBytes += this.redHeaderSizeBytes;\n          payloadSizeBytes += redundantEncodingSizeBytes;\n          redundantEncodingTimestamps.unshift(encoding.timestamp);\n          redundantEncodingPayloads.unshift(encoding.payload);\n        }\n        redundantTimestamp -= this.redPacketizationTime * this.redPacketDistance;\n        redundantTimestamp = this.uint32WrapAround(redundantTimestamp);\n      }\n    }\n\n    const redPayloadBuffer = new ArrayBuffer(headerSizeBytes + payloadSizeBytes);\n    const redPayloadView = new DataView(redPayloadBuffer);\n\n    // Add redundant encoding header(s) to new buffer\n    let redPayloadOffset = 0;\n    for (let i = 0; i < redundantEncodingTimestamps.length; i++) {\n      const timestampDelta = primaryTimestamp - redundantEncodingTimestamps[i];\n      redPayloadView.setUint8(redPayloadOffset, this.opusPayloadType | 0x80);\n      redPayloadView.setUint16(\n        redPayloadOffset + 1,\n        (timestampDelta << 2) | (redundantEncodingPayloads[i].byteLength >> 8)\n      );\n      redPayloadView.setUint8(redPayloadOffset + 3, redundantEncodingPayloads[i].byteLength & 0xff);\n      redPayloadOffset += this.redHeaderSizeBytes;\n    }\n\n    // Add primary encoding header to new buffer\n    redPayloadView.setUint8(redPayloadOffset, this.opusPayloadType);\n    redPayloadOffset += this.redLastHeaderSizeBytes;\n\n    // Add redundant payload(s) to new buffer\n    const redPayloadArray = new Uint8Array(redPayloadBuffer);\n    for (let i = 0; i < redundantEncodingPayloads.length; i++) {\n      redPayloadArray.set(new Uint8Array(redundantEncodingPayloads[i]), redPayloadOffset);\n      redPayloadOffset += redundantEncodingPayloads[i].byteLength;\n    }\n\n    // Add primary payload to new buffer\n    redPayloadArray.set(new Uint8Array(primaryPayload), redPayloadOffset);\n    redPayloadOffset += primaryPayload.byteLength;\n\n    /* istanbul ignore next */\n    // Sanity check that we got the expected total payload size.\n    if (redPayloadOffset !== headerSizeBytes + payloadSizeBytes) return null;\n\n    this.updateEncodingHistory(primaryTimestamp, primaryPayload);\n\n    return redPayloadBuffer;\n  }\n\n  /**\n   * Update the encoding history with the latest primary encoding\n   */\n  private updateEncodingHistory(primaryTimestamp: number, primaryPayload: ArrayBuffer): void {\n    // Remove encodings from the history if they are too old.\n    for (const encoding of this.encodingHistory) {\n      const maxTimestampDelta = this.redPacketizationTime * this.redMaxRecoveryDistance;\n\n      if (primaryTimestamp - encoding.timestamp >= maxTimestampDelta) {\n        this.encodingHistory.shift();\n      } else {\n        break;\n      }\n    }\n\n    // Only add an encoding to the history if the encoding is deemed to be important. An encoding is important if it is\n    // a CELT-only packet or contains voice activity.\n    const packet = new DataView(primaryPayload);\n    if (\n      this.opusPacketIsCeltOnly(packet) ||\n      this.opusPacketHasVoiceActivity(packet, packet.byteLength) > 0\n    ) {\n      // Check if adding an encoding will cause the length of the encoding history to exceed the maximum history size.\n      // This is not expected to happen but could occur if we get incorrect timestamps. We want to make sure our memory\n      // usage is bounded. In this case, just clear the history and start over from empty.\n      if (this.encodingHistory.length + 1 > this.maxEncodingHistorySize)\n        this.encodingHistory.length = 0;\n\n      this.encodingHistory.push({ timestamp: primaryTimestamp, payload: primaryPayload });\n    }\n  }\n\n  // Keep track of timestamps of primary packets received\n  // from the server\n  private primaryPacketLog: RedundantAudioEncoder.PacketLog;\n\n  // Keeps track of timestamps of payloads we recovered\n  // through redundant payloads.\n  private redRecoveryLog: RedundantAudioEncoder.PacketLog;\n\n  // Keeps track of timestamps of payloads we recovered\n  // through fec payloads.\n  private fecRecoveryLog: RedundantAudioEncoder.PacketLog;\n\n  // Most recent sequence number of a primary packet received\n  // from the server\n  private newestSequenceNumber: number;\n\n  // Total number of packets we expected from the server.\n  private totalAudioPacketsExpected: number;\n\n  // Total number of packets from the server that were lost.\n  private totalAudioPacketsLost: number;\n\n  // Total number of packets we recovered by consuming\n  // redundant payloads.\n  private totalAudioPacketsRecoveredRed: number;\n\n  // Total number of packets we recovered by consuming\n  // payloads with FEC.\n  private totalAudioPacketsRecoveredFec: number;\n\n  // The timestamp at which we last reported loss stats\n  // to the main thread.\n  private lastLossReportTimestamp: number;\n\n  // Loss stats are reported to the main thread every 5 seconds.\n  // Since timestamp differences between 2 consecutive packets\n  // give us the number of samples in each channel, 1 second\n  // is equivalent to 48000 samples:\n  // P-time * (1000ms/1s)\n  // = (960 samples/20ms) * (1000ms/1s)\n  // = 48000 samples/s\n  private readonly lossReportInterval: number = 48000 * 5;\n\n  // Maximum distance of a packet from the most recent packet timestamp\n  // that we will consider for recovery.\n  private readonly maxOutOfOrderPacketDistance = 16;\n\n  /**\n   * Initialize packet logs and metric values.\n   */\n  private initializePacketLogs(): void {\n    // The extra space from the max RED recovery distance is to ensure that we do not incorrectly count recovery for\n    // packets that have already been received but are outside of the max out-of-order distance.\n    const packetLogSize = this.maxOutOfOrderPacketDistance + this.redMaxRecoveryDistance;\n\n    this.primaryPacketLog = {\n      window: new Array<number>(packetLogSize),\n      index: 0,\n      windowSize: packetLogSize,\n    };\n    this.redRecoveryLog = {\n      window: new Array<number>(packetLogSize),\n      index: 0,\n      windowSize: packetLogSize,\n    };\n    this.fecRecoveryLog = {\n      window: new Array<number>(packetLogSize),\n      index: 0,\n      windowSize: packetLogSize,\n    };\n    this.totalAudioPacketsExpected = 0;\n    this.totalAudioPacketsLost = 0;\n    this.totalAudioPacketsRecoveredRed = 0;\n    this.totalAudioPacketsRecoveredFec = 0;\n  }\n\n  /**\n   * Receives encoded frames from the server\n   * and adds the timestamps to a packet log\n   * to calculate an approximate recovery metric.\n   */\n  private receivePacketLogTransform(\n    // @ts-ignore\n    frame: RTCEncodedAudioFrame,\n    controller: TransformStreamDefaultController\n  ): void {\n    const frameMetadata = frame.getMetadata();\n    // @ts-ignore\n    if (frameMetadata.payloadType !== this.redPayloadType) {\n      this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n      return;\n    }\n    // @ts-ignore\n    const encodings = this.splitEncodings(\n      frame.timestamp,\n      frame.data,\n      /*getFecInfo*/ true,\n      frameMetadata.sequenceNumber\n    );\n    if (!encodings) {\n      this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n      return;\n    }\n    for (let i = encodings.length - 1; i >= 0; i--) {\n      if (this.updateLossStats(encodings[i])) {\n        this.updateRedStats(encodings[i]);\n        this.updateFecStats(encodings[i]);\n      }\n    }\n    this.maybeReportLossStats(\n      frameMetadata.synchronizationSource,\n      encodings[encodings.length - 1].timestamp\n    );\n    this.enqueueAudioFrameIfPayloadSizeIsValid(frame, controller);\n  }\n\n  /**\n   * Adds a timestamp to the primary packet log.\n   * This also updates totalAudioPacketsLost and totalAudioPacketsExpected by looking\n   * at the difference between timestamps.\n   *\n   * @param encoding : The encoding to be analyzed\n   * @returns false if sequence number was greater than max out of order distance\n   *          true otherwise\n   */\n  private updateLossStats(encoding: RedundantAudioEncoder.Encoding): boolean {\n    if (encoding.isRedundant) return true;\n\n    const timestamp = encoding.timestamp;\n    const seq = encoding.seq;\n\n    if (this.totalAudioPacketsExpected === 0) {\n      this.totalAudioPacketsExpected = 1;\n      this.newestSequenceNumber = seq;\n      this.addTimestamp(this.primaryPacketLog, timestamp);\n      return true;\n    }\n\n    const diff = this.int16(seq - this.newestSequenceNumber);\n    if (diff < -this.maxOutOfOrderPacketDistance) return false;\n\n    if (diff < 0) {\n      if (!this.hasTimestamp(this.primaryPacketLog, timestamp)) {\n        if (this.totalAudioPacketsLost > 0) this.totalAudioPacketsLost--;\n        this.addTimestamp(this.primaryPacketLog, timestamp);\n        this.removeFromRecoveryWindows(timestamp);\n      }\n    } else if (diff > 1) {\n      this.totalAudioPacketsLost += diff - 1;\n    }\n\n    if (diff > 0) {\n      this.totalAudioPacketsExpected += diff;\n      this.newestSequenceNumber = encoding.seq;\n      this.addTimestamp(this.primaryPacketLog, timestamp);\n    }\n    return true;\n  }\n\n  /**\n   * Adds a timestamp to the red recovery log if it is not present in\n   * the primary packet log and if it's not too old.\n   *\n   * @param encoding : The encoding to be analyzed\n   */\n  private updateRedStats(encoding: RedundantAudioEncoder.Encoding): void {\n    if (!encoding.isRedundant || this.totalAudioPacketsLost === 0) return;\n\n    const timestamp = encoding.timestamp;\n\n    if (!this.hasTimestamp(this.primaryPacketLog, timestamp)) {\n      if (!this.hasTimestamp(this.redRecoveryLog, timestamp)) {\n        this.totalAudioPacketsRecoveredRed++;\n        this.addTimestamp(this.redRecoveryLog, timestamp);\n      }\n      if (this.removeTimestamp(this.fecRecoveryLog, timestamp)) {\n        /* istanbul ignore else */\n        if (this.totalAudioPacketsRecoveredFec > 0) this.totalAudioPacketsRecoveredFec--;\n      }\n    }\n  }\n\n  /**\n   * Adds a timestamp to the fec recovery log if it is not present in\n   * the primary packet log and red recovery log and if it is not too old.\n   *\n   * @param encoding : The encoding to be analyzed\n   */\n  private updateFecStats(encoding: RedundantAudioEncoder.Encoding): void {\n    if (!encoding.hasFec || this.totalAudioPacketsLost === 0) return;\n\n    const fecTimestamp = encoding.timestamp - this.redPacketizationTime;\n\n    if (\n      this.hasTimestamp(this.primaryPacketLog, fecTimestamp) ||\n      this.hasTimestamp(this.redRecoveryLog, fecTimestamp) ||\n      this.hasTimestamp(this.fecRecoveryLog, fecTimestamp)\n    ) {\n      return;\n    }\n\n    this.totalAudioPacketsRecoveredFec++;\n    this.addTimestamp(this.fecRecoveryLog, fecTimestamp);\n  }\n\n  /**\n   * Reports loss metrics to DefaultTransceiverController\n   *\n   * @param timestamp : Timestamp of most recent primary packet\n   */\n  private maybeReportLossStats(ssrc: number, timestamp?: number): void {\n    if (\n      timestamp === undefined ||\n      timestamp - this.lastLossReportTimestamp < this.lossReportInterval\n    )\n      return;\n\n    /* istanbul ignore next */\n    if (RedundantAudioEncoder.shouldReportStats) {\n      // @ts-ignore\n      self.postMessage({\n        type: 'RedundantAudioEncoderStats',\n        ssrc,\n        totalAudioPacketsLost: this.totalAudioPacketsLost,\n        totalAudioPacketsExpected: this.totalAudioPacketsExpected,\n        totalAudioPacketsRecoveredRed: this.totalAudioPacketsRecoveredRed,\n        totalAudioPacketsRecoveredFec: this.totalAudioPacketsRecoveredFec,\n      });\n    }\n\n    this.lastLossReportTimestamp = timestamp;\n  }\n\n  /**\n   * Adds a timestamp to a packet log\n   *\n   * @param packetLog : The packetlog to add the timestamp to\n   * @param timestamp : The timestamp that should be added\n   */\n  private addTimestamp(packetLog: RedundantAudioEncoder.PacketLog, timestamp?: number): void {\n    if (timestamp === undefined) {\n      return;\n    }\n    packetLog.window[packetLog.index] = timestamp;\n    packetLog.index = (packetLog.index + 1) % packetLog.windowSize;\n  }\n\n  /**\n   * Checks if a timestamp is in a packetlog\n   *\n   * @param packetLog : The packetlog to search\n   * @param timestamp : The timestamp to search for\n   * @returns true if timestamp is present, false otherwise\n   */\n  private hasTimestamp(packetLog: RedundantAudioEncoder.PacketLog, timestamp: number): boolean {\n    const element = packetLog.window.find(t => t === timestamp);\n    return !!element;\n  }\n\n  /**\n   * Removes a timestamp from a packet log\n   *\n   * @param packetLog : The packetlog from which the timestamp should be removed\n   * @param timestamp : The timestamp to be removed\n   * @returns true if timestamp was present in the log and removed, false otherwise\n   */\n  private removeTimestamp(packetLog: RedundantAudioEncoder.PacketLog, timestamp: number): boolean {\n    const index = packetLog.window.indexOf(timestamp);\n    if (index >= 0) {\n      packetLog.window[index] = undefined;\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Removes a timestamp from red and fec recovery windows.\n   *\n   * @param timestamp : The timestamp to be removed\n   */\n  private removeFromRecoveryWindows(timestamp: number): void {\n    let removed = this.removeTimestamp(this.redRecoveryLog, timestamp);\n    if (removed) {\n      if (this.totalAudioPacketsRecoveredRed > 0) this.totalAudioPacketsRecoveredRed--;\n    }\n    removed = this.removeTimestamp(this.fecRecoveryLog, timestamp);\n    if (removed) {\n      if (this.totalAudioPacketsRecoveredFec > 0) this.totalAudioPacketsRecoveredFec--;\n    }\n  }\n\n  /**\n   * Converts the supplied argument to 32-bit unsigned integer\n   */\n  private uint32WrapAround(num: number): number {\n    const mod = 4294967296; // 2^32\n    let res: number = num;\n    if (num >= mod) {\n      res = num - mod;\n    } else if (num < 0) {\n      res = mod + num;\n    }\n    return res;\n  }\n\n  /**\n   * Converts the supplied argument to 16-bit signed integer\n   */\n  private int16(num: number): number {\n    return (num << 16) >> 16;\n  }\n\n  /**\n   * Below are Opus helper methods and constants.\n   */\n\n  private readonly OPUS_BAD_ARG = -1;\n  private readonly OPUS_INVALID_PACKET = -4;\n\n  // Max number of Opus frames in an Opus packet is 48 (https://www.rfc-editor.org/rfc/rfc6716#section-3.2.5).\n  private readonly OPUS_MAX_OPUS_FRAMES = 48;\n\n  // Max number of bytes that any individual Opus frame can have.\n  private readonly OPUS_MAX_FRAME_SIZE_BYTES = 1275;\n\n  /**\n   * Determines if an Opus packet is in CELT-only mode.\n   *\n   * @param packet Opus packet.\n   * @returns `true` if the packet is in CELT-only mode.\n   */\n  private opusPacketIsCeltOnly(packet: DataView): boolean {\n    // TOC byte format (https://www.rfc-editor.org/rfc/rfc6716#section-3.1):\n    //  0\n    //  0 1 2 3 4 5 6 7\n    // +-+-+-+-+-+-+-+-+\n    // | config  |s| c |\n    // +-+-+-+-+-+-+-+-+\n\n    // Since CELT-only packets are represented using configurations 16 to 31, the highest 'config' bit will always be 1\n    // for CELT-only packets.\n    return !!(packet.getUint8(0) & 0x80);\n  }\n\n  /**\n   * Gets the number of samples per frame from an Opus packet.\n   *\n   * @param packet Opus packet. This must contain at least one byte of data.\n   * @param sampleRateHz 32-bit integer sampling rate in Hz. This must be a multiple of 400 or inaccurate results will\n   *                     be returned.\n   * @returns Number of samples per frame.\n   */\n  private opusPacketGetSamplesPerFrame(packet: DataView, sampleRateHz: number): number {\n    // Sample rate must be a 32-bit integer.\n    sampleRateHz = Math.round(sampleRateHz);\n    sampleRateHz = Math.min(Math.max(sampleRateHz, -(2 ** 32)), 2 ** 32 - 1);\n\n    // TOC byte format (https://www.rfc-editor.org/rfc/rfc6716#section-3.1):\n    //  0\n    //  0 1 2 3 4 5 6 7\n    // +-+-+-+-+-+-+-+-+\n    // | config  |s| c |\n    // +-+-+-+-+-+-+-+-+\n\n    let numSamples: number;\n    let frameSizeOption: number;\n\n    // Case for CELT-only packet.\n    if (this.opusPacketIsCeltOnly(packet)) {\n      // The lower 3 'config' bits indicate the frame size option.\n      frameSizeOption = (packet.getUint8(0) >> 3) & 0x3;\n\n      // The frame size options 0, 1, 2, 3 correspond to frame sizes of 2.5, 5, 10, 20 ms. Notice that the frame sizes\n      // can be represented as (2.5 * 2^0), (2.5 * 2^1), (2.5 * 2^2), (2.5 * 2^3) ms. So, the number of samples can be\n      // calculated as follows:\n      // (sample/s) * (1s/1000ms) * (2.5ms) * 2^(frameSizeOption)\n      // = (sample/s) * (1s/400) * 2^(frameSizeOption)\n      // = (sample/s) * 2^(frameSizeOption) * (1s/400)\n      numSamples = (sampleRateHz << frameSizeOption) / 400;\n    }\n    // Case for Hybrid packet. Since Hybrid packets are represented using configurations 12 to 15, bits 1 and 2 in the\n    // above TOC byte diagram will both be 1.\n    else if ((packet.getUint8(0) & 0x60) === 0x60) {\n      // In the case of configuration 13 or 15, bit 4 in the above TOC byte diagram will be 1. Configurations 13 and 15\n      // correspond to a 20ms frame size, so the number of samples is calculated as follows:\n      // (sample/s) * (1s/1000ms) * (20ms)\n      // = (sample/s) * (1s/50)\n      //\n      // In the case of configuration 12 or 14, bit 4 in the above TOC byte diagram will be 0. Configurations 12 and 14\n      // correspond to a 10ms frame size, so the number of samples is calculated as follows:\n      // (sample/s) * (1s/1000ms) * (10ms)\n      // = (sample/s) * (1s/100)\n      numSamples = packet.getUint8(0) & 0x08 ? sampleRateHz / 50 : sampleRateHz / 100;\n    }\n    // Case for SILK-only packet.\n    else {\n      // The lower 3 'config' bits indicate the frame size option for SILK-only packets.\n      frameSizeOption = (packet.getUint8(0) >> 3) & 0x3;\n\n      if (frameSizeOption === 3) {\n        // Frame size option 3 corresponds to a frame size of 60ms, so the number of samples is calculated as follows:\n        // (sample/s) * (1s/1000ms) * (60ms)\n        // = (sample/s) * (60ms) * (1s/1000ms)\n        numSamples = (sampleRateHz * 60) / 1000;\n      } else {\n        // The frame size options 0, 1, 2 correspond to frame sizes of 10, 20, 40 ms. Notice that the frame sizes can be\n        // represented as (10 * 2^0), (10 * 2^1), (10 * 2^2) ms. So, the number of samples can be calculated as follows:\n        // (sample/s) * (1s/1000ms) * (10ms) * 2^(frameSizeOption)\n        // = (sample/s) * (1s/100) * 2^(frameSizeOption)\n        // = (sample/s) * 2^(frameSizeOption) * (1s/100)\n        numSamples = (sampleRateHz << frameSizeOption) / 100;\n      }\n    }\n\n    return numSamples;\n  }\n\n  /**\n   * Gets the number of SILK frames per Opus frame.\n   *\n   * @param packet Opus packet.\n   * @returns Number of SILK frames per Opus frame.\n   */\n  private opusNumSilkFrames(packet: DataView): number {\n    // For computing the frame length in ms, the sample rate is not important since it cancels out. We use 48 kHz, but\n    // any valid sample rate would work.\n    //\n    // To calculate the length of a frame (with a 48kHz sample rate) in ms:\n    // (samples/frame) * (1s/48000 samples) * (1000ms/s)\n    // = (samples/frame) * (1000ms/48000 samples)\n    // = (samples/frame) * (1ms/48 samples)\n    let frameLengthMs = this.opusPacketGetSamplesPerFrame(packet, 48000) / 48;\n\n    if (frameLengthMs < 10) frameLengthMs = 10;\n\n    // The number of SILK frames per Opus frame is described in https://www.rfc-editor.org/rfc/rfc6716#section-4.2.2.\n    switch (frameLengthMs) {\n      case 10:\n      case 20:\n        return 1;\n      case 40:\n        return 2;\n      case 60:\n        return 3;\n      // It is not possible to reach the default case since an Opus packet can only encode sizes of 2.5, 5, 10, 20, 40,\n      // or 60 ms, so we ignore the default case for test coverage.\n      /* istanbul ignore next */\n      default:\n        return 0;\n    }\n  }\n\n  /**\n   * Gets the number of channels from an Opus packet.\n   *\n   * @param packet Opus packet.\n   * @returns Number of channels.\n   */\n  private opusPacketGetNumChannels(packet: DataView): number {\n    // TOC byte format (https://www.rfc-editor.org/rfc/rfc6716#section-3.1):\n    //  0\n    //  0 1 2 3 4 5 6 7\n    // +-+-+-+-+-+-+-+-+\n    // | config  |s| c |\n    // +-+-+-+-+-+-+-+-+\n\n    // The 's' bit indicates mono or stereo audio, with 0 indicating mono and 1 indicating stereo.\n    return packet.getUint8(0) & 0x4 ? 2 : 1;\n  }\n\n  /**\n   * Determine the size (in bytes) of an Opus frame.\n   *\n   * @param packet Opus packet.\n   * @param byteOffset Offset (from the start of the packet) to the byte containing the size information.\n   * @param remainingBytes Remaining number of bytes to parse from the Opus packet.\n   * @param sizeBytes Variable to store the parsed frame size (in bytes).\n   * @returns Number of bytes that were parsed to determine the frame size.\n   */\n  private opusParseSize(\n    packet: DataView,\n    byteOffset: number,\n    remainingBytes: number,\n    sizeBytes: [number]\n  ): number {\n    // See https://www.rfc-editor.org/rfc/rfc6716#section-3.2.1 for an explanation of how frame size is represented.\n\n    // If there are no remaining bytes to parse the size from, then the size cannot be determined.\n    if (remainingBytes < 1) {\n      sizeBytes[0] = -1;\n      return -1;\n    }\n    // If the first byte is in the range 0...251, then this value is the size of the frame.\n    else if (packet.getUint8(byteOffset) < 252) {\n      sizeBytes[0] = packet.getUint8(byteOffset);\n      return 1;\n    }\n    // If the first byte is in the range 252...255, a second byte is needed. If there is no second byte, then the size\n    // cannot be determined.\n    else if (remainingBytes < 2) {\n      sizeBytes[0] = -1;\n      return -1;\n    }\n    // The total size of the frame given two size bytes is:\n    // (4 * secondSizeByte) + firstSizeByte\n    else {\n      sizeBytes[0] = 4 * packet.getUint8(byteOffset + 1) + packet.getUint8(byteOffset);\n      return 2;\n    }\n  }\n\n  /**\n   * Parse binary data containing an Opus packet into one or more Opus frames.\n   *\n   * @param data Binary data containing an Opus packet to be parsed. The data should begin with the first byte (i.e the\n   *             TOC byte) of an Opus packet. Note that the size of the data does not have to equal the size of the\n   *             contained Opus packet.\n   * @param lenBytes Size of the data (in bytes).\n   * @param selfDelimited Indicates if the Opus packet is self-delimiting\n   *                      (https://www.rfc-editor.org/rfc/rfc6716#appendix-B).\n   * @param tocByte Optional variable to store the TOC (table of contents) byte.\n   * @param frameOffsets Optional variable to store the offsets (from the start of the data) to the first bytes of each\n   *                     Opus frame.\n   * @param frameSizes Required variable to store the sizes (in bytes) of each Opus frame.\n   * @param payloadOffset Optional variable to store the offset (from the start of the data) to the first byte of the\n   *                      payload.\n   * @param packetLenBytes Optional variable to store the length of the Opus packet (in bytes).\n   * @returns Number of Opus frames.\n   */\n  private opusPacketParseImpl(\n    data: DataView,\n    lenBytes: number,\n    selfDelimited: boolean,\n    tocByte: [number],\n    frameOffsets: Array<[number]>,\n    frameSizes: Array<[number]>,\n    payloadOffset: [number],\n    packetLenBytes: [number]\n  ): number {\n    if (!frameSizes || lenBytes < 0) return this.OPUS_BAD_ARG;\n    if (lenBytes === 0) return this.OPUS_INVALID_PACKET;\n\n    // The number of Opus frames in the packet.\n    let numFrames: number;\n\n    // Intermediate storage for the number of bytes parsed to determine the size of a frame.\n    let numBytesParsed: number;\n\n    // The number of the padding bytes (excluding the padding count bytes) in the packet.\n    let paddingBytes = 0;\n\n    // Indicates whether CBR (constant bitrate) framing is used.\n    let cbr = false;\n\n    // The TOC (table of contents) byte (https://www.rfc-editor.org/rfc/rfc6716#section-3.1).\n    const toc = data.getUint8(0);\n\n    // Store the TOC byte.\n    if (tocByte) tocByte[0] = toc;\n\n    // The remaining number of bytes to parse from the packet. Note that the TOC byte has already been parsed, hence the\n    // minus 1.\n    let remainingBytes = lenBytes - 1;\n\n    // This keeps track of where we are in the packet. This starts at 1 since the TOC byte has already been read.\n    let byteOffset = 1;\n\n    // The size of the last Opus frame in bytes.\n    let lastSizeBytes = remainingBytes;\n\n    // Read the `c` bits (i.e. code bits) from the TOC byte.\n    switch (toc & 0x3) {\n      // A code 0 packet (https://www.rfc-editor.org/rfc/rfc6716#section-3.2.2) has one frame.\n      case 0:\n        numFrames = 1;\n        break;\n      // A code 1 packet (https://www.rfc-editor.org/rfc/rfc6716#section-3.2.3) has two CBR (constant bitrate) frames.\n      case 1:\n        numFrames = 2;\n        cbr = true;\n\n        if (!selfDelimited) {\n          // Undelimited code 1 packets must be an even number of data bytes, otherwise the packet is invalid.\n          if (remainingBytes & 0x1) return this.OPUS_INVALID_PACKET;\n\n          // The sizes of both frames are equal (i.e. half of the number of data bytes).\n          lastSizeBytes = remainingBytes / 2;\n\n          // If `lastSizeBytes` is too large, we will catch it later.\n          frameSizes[0][0] = lastSizeBytes;\n        }\n        break;\n      // A code 2 packet (https://www.rfc-editor.org/rfc/rfc6716#section-3.2.4) has two VBR (variable bitrate) frames.\n      case 2:\n        numFrames = 2;\n\n        numBytesParsed = this.opusParseSize(data, byteOffset, remainingBytes, frameSizes[0]);\n        remainingBytes -= numBytesParsed;\n\n        // The parsed size of the first frame cannot be larger than the number of remaining bytes in the packet.\n        if (frameSizes[0][0] < 0 || frameSizes[0][0] > remainingBytes) {\n          return this.OPUS_INVALID_PACKET;\n        }\n\n        byteOffset += numBytesParsed;\n\n        // The size of the second frame is the remaining number of bytes after the first frame.\n        lastSizeBytes = remainingBytes - frameSizes[0][0];\n        break;\n      // A code 3 packet (https://www.rfc-editor.org/rfc/rfc6716#section-3.2.5) has multiple CBR/VBR frames (from 0 to\n      // 120 ms).\n      default:\n        // Code 3 packets must have at least 2 bytes (i.e. at least 1 byte after the TOC byte).\n        if (remainingBytes < 1) return this.OPUS_INVALID_PACKET;\n\n        // Frame count byte format:\n        //  0\n        //  0 1 2 3 4 5 6 7\n        // +-+-+-+-+-+-+-+-+\n        // |v|p|     M     |\n        // +-+-+-+-+-+-+-+-+\n        //\n        // Read the frame count byte, which immediately follows the TOC byte.\n        const frameCountByte = data.getUint8(byteOffset++);\n        --remainingBytes;\n\n        // Read the 'M' bits of the frame count byte, which encode the number of frames.\n        numFrames = frameCountByte & 0x3f;\n\n        // The number of frames in a code 3 packet must not be 0.\n        if (numFrames <= 0) return this.OPUS_INVALID_PACKET;\n\n        const samplesPerFrame = this.opusPacketGetSamplesPerFrame(data, 48000);\n\n        // A single frame can have at most 2880 samples, which happens in the case where 60ms of 48kHz audio is encoded\n        // per frame. A code 3 packet cannot contain more than 120ms of audio, so the total number of samples cannot\n        // exceed 2880 * 2 = 5760.\n        if (samplesPerFrame * numFrames > 5760) return this.OPUS_INVALID_PACKET;\n\n        // Parse padding bytes if the 'p' bit is 1.\n        if (frameCountByte & 0x40) {\n          let paddingCountByte: number;\n          let numPaddingBytes: number;\n\n          // Remove padding bytes (including padding count bytes) from the remaining byte count.\n          do {\n            // Sanity check that there are enough bytes to parse and remove the padding.\n            if (remainingBytes <= 0) return this.OPUS_INVALID_PACKET;\n\n            // Get the next padding count byte.\n            paddingCountByte = data.getUint8(byteOffset++);\n            --remainingBytes;\n\n            // If the padding count byte has a value in the range 0...254, then the total size of the padding is the\n            // value in the padding count byte.\n            //\n            // If the padding count byte has value 255, then the total size of the padding is 254 plus the value in the\n            // next padding count byte. Therefore, keep reading padding count bytes while the value is 255.\n            numPaddingBytes = paddingCountByte === 255 ? 254 : paddingCountByte;\n            remainingBytes -= numPaddingBytes;\n            paddingBytes += numPaddingBytes;\n          } while (paddingCountByte === 255);\n        }\n\n        // Sanity check that the remaining number of bytes is not negative after removing the padding.\n        if (remainingBytes < 0) return this.OPUS_INVALID_PACKET;\n\n        // Read the 'v' bit (i.e. VBR bit).\n        cbr = !(frameCountByte & 0x80);\n\n        // VBR case\n        if (!cbr) {\n          lastSizeBytes = remainingBytes;\n\n          // Let M be the number of frames. There will be M - 1 frame length indicators (which can be 1 or 2 bytes)\n          // corresponding to the lengths of frames 0 to M - 2. The size of the last frame (i.e. frame M - 1) is the\n          // number of data bytes after the end of frame M - 2 and before the start of the padding bytes.\n          for (let i = 0; i < numFrames - 1; ++i) {\n            numBytesParsed = this.opusParseSize(data, byteOffset, remainingBytes, frameSizes[i]);\n            remainingBytes -= numBytesParsed;\n\n            // The remaining number of data bytes must be enough to contain each frame.\n            if (frameSizes[i][0] < 0 || frameSizes[i][0] > remainingBytes) {\n              return this.OPUS_INVALID_PACKET;\n            }\n\n            byteOffset += numBytesParsed;\n\n            lastSizeBytes -= numBytesParsed + frameSizes[i][0];\n          }\n\n          // Sanity check that the size of the last frame is not negative.\n          if (lastSizeBytes < 0) return this.OPUS_INVALID_PACKET;\n        }\n        // CBR case\n        else if (!selfDelimited) {\n          // The size of each frame is the number of data bytes divided by the number of frames.\n          lastSizeBytes = Math.trunc(remainingBytes / numFrames);\n\n          // The number of data bytes must be a non-negative integer multiple of the number of frames.\n          if (lastSizeBytes * numFrames !== remainingBytes) return this.OPUS_INVALID_PACKET;\n\n          // All frames have equal size in the undelimited CBR case.\n          for (let i = 0; i < numFrames - 1; ++i) {\n            frameSizes[i][0] = lastSizeBytes;\n          }\n        }\n    }\n\n    // Self-delimited framing uses an extra 1 or 2 bytes, immediately preceding the data bytes, to indicate either the\n    // size of the last frame (for code 0, code 2, and VBR code 3 packets) or the size of all the frames (for code 1 and\n    // CBR code 3 packets). See https://www.rfc-editor.org/rfc/rfc6716#appendix-B.\n    if (selfDelimited) {\n      // The extra frame size byte(s) will always indicate the size of the last frame.\n      numBytesParsed = this.opusParseSize(\n        data,\n        byteOffset,\n        remainingBytes,\n        frameSizes[numFrames - 1]\n      );\n      remainingBytes -= numBytesParsed;\n\n      // There must be enough data bytes for the last frame.\n      if (frameSizes[numFrames - 1][0] < 0 || frameSizes[numFrames - 1][0] > remainingBytes) {\n        return this.OPUS_INVALID_PACKET;\n      }\n\n      byteOffset += numBytesParsed;\n\n      // For CBR packets, the sizes of all the frames are equal.\n      if (cbr) {\n        // There must be enough data bytes for all the frames.\n        if (frameSizes[numFrames - 1][0] * numFrames > remainingBytes) {\n          return this.OPUS_INVALID_PACKET;\n        }\n\n        for (let i = 0; i < numFrames - 1; ++i) {\n          frameSizes[i][0] = frameSizes[numFrames - 1][0];\n        }\n      }\n      // At this point, `lastSizeBytes` contains the size of the last frame plus the size of the extra frame size\n      // byte(s), so sanity check that `lastSizeBytes` is the upper bound for the size of the last frame.\n      else if (!(numBytesParsed + frameSizes[numFrames - 1][0] <= lastSizeBytes)) {\n        return this.OPUS_INVALID_PACKET;\n      }\n    }\n    // Undelimited case\n    else {\n      // Because the size of the last packet is not encoded explicitly, it is possible that the size of the last packet\n      // (or of all the packets, for the CBR case) is larger than maximum frame size.\n      if (lastSizeBytes > this.OPUS_MAX_FRAME_SIZE_BYTES) return this.OPUS_INVALID_PACKET;\n\n      frameSizes[numFrames - 1][0] = lastSizeBytes;\n    }\n\n    // Store the offset to the start of the payload.\n    if (payloadOffset) payloadOffset[0] = byteOffset;\n\n    // Store the offsets to the start of each frame.\n    for (let i = 0; i < numFrames; ++i) {\n      if (frameOffsets) frameOffsets[i][0] = byteOffset;\n\n      byteOffset += frameSizes[i][0];\n    }\n\n    // Store the length of the Opus packet.\n    if (packetLenBytes) packetLenBytes[0] = byteOffset + paddingBytes;\n\n    return numFrames;\n  }\n\n  /**\n   * Parse a single undelimited Opus packet into one or more Opus frames.\n   *\n   * @param packet Opus packet to be parsed.\n   * @param lenBytes Size of the packet (in bytes).\n   * @param tocByte Optional variable to store the TOC (table of contents) byte.\n   * @param frameOffsets Optional variable to store the offsets (from the start of the packet) to the first bytes of\n   *                     each Opus frame.\n   * @param frameSizes Required variable to store the sizes (in bytes) of each Opus frame.\n   * @param payloadOffset Optional variable to store the offset (from the start of the packet) to the first byte of the\n   *                      payload.\n   * @returns Number of Opus frames.\n   */\n  private opusPacketParse(\n    packet: DataView,\n    lenBytes: number,\n    tocByte: [number],\n    frameOffsets: Array<[number]>,\n    frameSizes: Array<[number]>,\n    payloadOffset: [number]\n  ): number {\n    return this.opusPacketParseImpl(\n      packet,\n      lenBytes,\n      /* selfDelimited */ false,\n      tocByte,\n      frameOffsets,\n      frameSizes,\n      payloadOffset,\n      null\n    );\n  }\n\n  /**\n   * This function returns the SILK VAD (voice activity detection) information encoded in the Opus packet. For CELT-only\n   * packets that do not have VAD information, it returns -1.\n   *\n   * @param packet Opus packet.\n   * @param lenBytes Size of the packet (in bytes).\n   * @returns  0: no frame had the VAD flag set.\n   *           1: at least one frame had the VAD flag set.\n   *          -1: VAD status could not be determined.\n   */\n  private opusPacketHasVoiceActivity(packet: DataView, lenBytes: number): number {\n    if (!packet || lenBytes <= 0) return 0;\n\n    // In CELT-only mode, we can not determine whether there is VAD.\n    if (this.opusPacketIsCeltOnly(packet)) return -1;\n\n    const numSilkFrames = this.opusNumSilkFrames(packet);\n\n    // It is not possible for `opusNumSilkFrames()` to return 0, so we ignore the next sanity check for test coverage.\n    /* istanbul ignore next */\n    if (numSilkFrames === 0) return -1;\n\n    const opusFrameOffsets = new Array<[number]>(this.OPUS_MAX_OPUS_FRAMES);\n    const opusFrameSizes = new Array<[number]>(this.OPUS_MAX_OPUS_FRAMES);\n    for (let i = 0; i < this.OPUS_MAX_OPUS_FRAMES; ++i) {\n      opusFrameOffsets[i] = [undefined];\n      opusFrameSizes[i] = [undefined];\n    }\n\n    // Parse packet to get the Opus frames.\n    const numOpusFrames = this.opusPacketParse(\n      packet,\n      lenBytes,\n      null,\n      opusFrameOffsets,\n      opusFrameSizes,\n      null\n    );\n\n    // VAD status cannot be determined for invalid packets.\n    if (numOpusFrames < 0) return -1;\n\n    // Iterate over all Opus frames, which may contain multiple SILK frames, to determine the VAD status.\n    for (let i = 0; i < numOpusFrames; ++i) {\n      if (opusFrameSizes[i][0] < 1) continue;\n\n      // LP layer header bits format (https://www.rfc-editor.org/rfc/rfc6716#section-4.2.3):\n      //\n      // Mono case:\n      // +-----------------+----------+\n      // | 1 to 3 VAD bits | LBRR bit |\n      // +-----------------+----------+\n      //\n      // Stereo case:\n      // +---------------------+--------------+----------------------+---------------+\n      // | 1 to 3 mid VAD bits | mid LBRR bit | 1 to 3 side VAD bits | side LBRR bit |\n      // +---------------------+--------------+----------------------+---------------+\n\n      // The upper 1 to 3 bits (dependent on the number of SILK frames) of the LP layer contain VAD bits. If any of\n      // these VAD bits are 1, then voice activity is present.\n      if (packet.getUint8(opusFrameOffsets[i][0]) >> (8 - numSilkFrames)) return 1;\n\n      // In the stereo case, there is a second set of 1 to 3 VAD bits, so also check these VAD bits.\n      const channels = this.opusPacketGetNumChannels(packet);\n      if (\n        channels === 2 &&\n        (packet.getUint8(opusFrameOffsets[i][0]) << (numSilkFrames + 1)) >> (8 - numSilkFrames)\n      ) {\n        return 1;\n      }\n    }\n    // No voice activity was detected.\n    return 0;\n  }\n\n  /**\n   * This method is based on Definition of the Opus Audio Codec\n   * (https://tools.ietf.org/html/rfc6716). Basically, this method is based on\n   * parsing the LP layer of an Opus packet, particularly the LBRR flag.\n   *\n   * @param packet Opus packet.\n   * @param lenBytes Size of the packet (in bytes).\n   * @returns  true: packet has fec encoding about previous packet.\n   *           false: no fec encoding present.\n   */\n  private opusPacketHasFec(packet: DataView, lenBytes: number): boolean {\n    if (!packet || lenBytes <= 0) return false;\n\n    // In CELT-only mode, packets should not have FEC.\n    if (this.opusPacketIsCeltOnly(packet)) return false;\n\n    const opusFrameOffsets = new Array<[number]>(this.OPUS_MAX_OPUS_FRAMES);\n    const opusFrameSizes = new Array<[number]>(this.OPUS_MAX_OPUS_FRAMES);\n    for (let i = 0; i < this.OPUS_MAX_OPUS_FRAMES; ++i) {\n      opusFrameOffsets[i] = [undefined];\n      opusFrameSizes[i] = [undefined];\n    }\n\n    // Parse packet to get the Opus frames.\n    const numOpusFrames = this.opusPacketParse(\n      packet,\n      lenBytes,\n      null,\n      opusFrameOffsets,\n      opusFrameSizes,\n      null\n    );\n\n    if (numOpusFrames < 0) return false;\n\n    /* istanbul ignore next */\n    if (opusFrameSizes[0][0] <= 1) return false;\n\n    const numSilkFrames = this.opusNumSilkFrames(packet);\n    /* istanbul ignore next */\n    if (numSilkFrames === 0) return false;\n\n    const channels = this.opusPacketGetNumChannels(packet);\n    /* istanbul ignore next */\n    if (channels !== 1 && channels !== 2) return false;\n\n    // A frame starts with the LP layer. The LP layer begins with two to eight\n    // header bits.These consist of one VAD bit per SILK frame (up to 3),\n    // followed by a single flag indicating the presence of LBRR frames.\n    // For a stereo packet, these first flags correspond to the mid channel, and\n    // a second set of flags is included for the side channel. Because these are\n    // the first symbols decoded by the range coder and because they are coded\n    // as binary values with uniform probability, they can be extracted directly\n    // from the most significant bits of the first byte of compressed data.\n    for (let i = 0; i < channels; i++) {\n      if (packet.getUint8(opusFrameOffsets[0][0]) & (0x80 >> ((i + 1) * (numSilkFrames + 1) - 1)))\n        return true;\n    }\n    return false;\n  }\n}\n\nnamespace RedundantAudioEncoder {\n  export interface Encoding {\n    timestamp?: number;\n    seq?: number;\n    payload: ArrayBuffer;\n    isRedundant?: boolean;\n    hasFec?: boolean;\n  }\n\n  export interface PacketLog {\n    window: Array<number>;\n    index: number;\n    windowSize: number;\n  }\n}\n"]}